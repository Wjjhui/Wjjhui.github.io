<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秃哦鸡</title>
  
  
  <link href="https://wjjhui.github.io/atom.xml" rel="self"/>
  
  <link href="https://wjjhui.github.io/"/>
  <updated>2023-06-08T11:18:10.144Z</updated>
  <id>https://wjjhui.github.io/</id>
  
  <author>
    <name>wjjhui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习环境配置</title>
    <link href="https://wjjhui.github.io/2023/06/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://wjjhui.github.io/2023/06/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2023-06-08T10:50:18.000Z</published>
    <updated>2023-06-08T11:18:10.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习环境配置"><a href="#学习环境配置" class="headerlink" title="学习环境配置"></a>学习环境配置</h2><p>入门深度学习，首先要做的事情就是要搭建深度学习的环境。不管你是Windows用户，Mac用户还是Ubuntu用户，只要电脑配置允许，都可以做深度学习，毕竟Windows、Mac和Ubuntu系统都可以进行深度学习环境的搭建。接下来就记录下自己在Windows系统上搭建深度学习环境的过程，方便自己存档也为大家提供一个参考。<br>本次环境配置主要模式是基于Minianaconda+CUDA+cuDNN+PyTorch(GPU版)进行搭建的。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>Python集成开发环境：Minianaconda<br>CUDA、cuDNN：英伟达提供的针对英伟达显卡的运算平台。用来提升神经网络的运行效率，如果电脑显卡不满足要求也是可以不用安装，使用cpu来进行运算。<br>开发工具：PyCharm<br>深度学习库：PyTorch（也可以使用Google开源的TensorFlow平台，不过一般学术界多用PyTorch平台。）</p><h4 id="一、安装Minianaconda"><a href="#一、安装Minianaconda" class="headerlink" title="一、安装Minianaconda"></a>一、安装Minianaconda</h4><p><a href="https://docs.conda.io/en/latest/miniconda.html#">minianaconda官网下载</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">清华大学开源镜像下载</a></p><p>两个网站都可以下载，选择适合自己电脑的版本下载即可。</p><p>安装之后会自动配置环境变量，检查是否安装成功即可。</p><p>1.查看conda版本</p><p><code>conda --version</code></p><p>2.创建新的虚拟环境</p><p><code>conda create --name dl2</code></p><p>3.激活conda虚拟环境</p><p><code>activate dl2</code></p><p>4.关闭虚拟环境</p><p><code>deactivate</code></p><p>5.查看已创建环境</p><p><code>conda info -e</code><br><code>或</code><br><code>conda env list</code></p><p>6.删除环境</p><p><code>conda remove --name &lt;env_name&gt; --all</code></p><p>7.复制环境</p><p><code>conda create --name &lt;new_env_name&gt; --clone &lt;old_evn_name&gt;</code></p><p>8.查看当前环境已安装的包</p><p><code>conda list</code></p><p>9.卸载当前环境的包</p><p><code>conda remove &lt;package_name&gt;</code></p><h4 id="二、安装CUDA"><a href="#二、安装CUDA" class="headerlink" title="二、安装CUDA"></a>二、安装CUDA</h4><p>首先安装NVDIA显卡驱动，<a href="https://www.nvidia.cn/geforce/drivers/">NVIDIA官网</a></p><p>安装完NVIDIA以后我们还需要安装CUDA以及cuDNN，这两个是NVIDIA官方给出的便于深度学习计算的补丁</p><p>CUDA的安装之前我们先要看看相适配的版本，桌面空白处右键，打开NVIDIA控制面板，依次点击帮助-系统信息，在弹出的界面中选择组件:</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20230608185048826.png" alt="image-20230608185048826"></p><p>在第三行我们可以看出我这台电脑要安装cuda11.6的版本，我们去下载cuda不可以高于这个版本，最好也别过低。</p><p><a href="https://developer.nvidia.com/cuda-downloads">CUDA官网</a></p><p><strong>下载完之后存放CUDA的文件夹会自动消失，后面可以从C盘找到相对应的路径。</strong></p><h4 id="三、安装cuDNN"><a href="#三、安装cuDNN" class="headerlink" title="三、安装cuDNN"></a>三、安装cuDNN</h4><p><a href="https://developer.nvidia.com/[rdp](https://so.csdn.net/so/search?q=rdp&spm=1001.2101.3001.7020)/cudnn-download">cuDNN官网</a></p><p>下载的时候注意版号，一定要让cudnn和cuda的版号完全一样才可以。<br>下载好之后打开cudnn的压缩包，再打开cuda的目录（目录在图里）：</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20230608185431539.png" alt="image-20230608185431539"></p><p>可以看到cudnn有三个文件夹，把这些文件夹中的东西放入C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6下</p><p>至此cuda+cudnn就安装完成了，我们打开anaconda prompt，输入<code>nvcc -V</code>来看看cuda信息：</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20230608185614677.png" alt="image-20230608185614677"></p><h4 id="四：安装PyTorch-GPU版"><a href="#四：安装PyTorch-GPU版" class="headerlink" title="四：安装PyTorch(GPU版)"></a>四：安装PyTorch(GPU版)</h4><p>1.激活conda虚拟环境</p><p><code>activate dl2</code></p><p><del>安装pytorch：conda install pytorch</del></p><p>此命令会安装基于CPU版本的pytorch</p><p>正确安装方法</p><p>进入<a href="https://pytorch.org/get-started/locally/">PyTorch官网</a>,选择相关的电脑配置，然后进入虚拟环境运行，加上镜像源</p><p>镜像源：<br>-i <a href="https://opsx.alibaba.com/mirror">https://opsx.alibaba.com/mirror</a><br>-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20230608190652453.png" alt="image-20230608190652453"></p><p>检查是否安装成功</p><p><code>python</code></p><p><code>import torch</code></p><p><code>torch.__version__ //注意version前后是两个下划线</code></p><p><code>torch.cuda.is_available()</code></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20230608190405974.png" alt="image-20230608190405974"></p><h3 id="此时，深度学习环境配置完成。"><a href="#此时，深度学习环境配置完成。" class="headerlink" title="此时，深度学习环境配置完成。"></a>此时，深度学习环境配置完成。</h3>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    
    <category term="DeepLearning" scheme="https://wjjhui.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习吴恩达</title>
    <link href="https://wjjhui.github.io/2023/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <id>https://wjjhui.github.io/2023/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE/</id>
    <published>2023-06-05T02:25:40.000Z</published>
    <updated>2023-06-05T14:08:11.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220704164533714.png" alt="image-20220704164533714"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="机器器学习" scheme="https://wjjhui.github.io/categories/%E6%9C%BA%E5%99%A8%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://wjjhui.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>第八章:排序</title>
    <link href="https://wjjhui.github.io/2022/07/03/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
    <id>https://wjjhui.github.io/2022/07/03/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/</id>
    <published>2022-07-03T02:25:40.000Z</published>
    <updated>2022-07-04T10:10:25.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><p><strong>排序</strong>:就是重新排列表中的数据，使表中的元素满足按关键字有序的过程</p><p><strong>基本类型</strong></p><ol><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>基数排序</li></ol><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>基本思想</strong>：每次将一个待排序的记录按其关键字大小插入到前面已排好的子序列中，直到全部记录插入完成</p><p><strong>引申出的算法</strong>：</p><ol><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li></ol><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>将一个待排序的记录用<strong>顺序查找</strong>的方式找到应当插入的位置，然后插入</p><p>空间复杂度：O（1）</p><p>时间复杂度：O（n^2）</p><p>稳定算法</p><p>适用于顺序存储和链式存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)    <span class="comment">//将个元素插入已排好的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;<span class="comment">//若A[i]小于前面的</span></span><br><span class="line">            temp=A[i];<span class="comment">//将A[i]暂存</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;<span class="number">0</span> &amp;&amp; A[j]&gt;temp;--j)<span class="comment">//找到A[i]应当放的位置</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//所有大于A[i]的元素后移</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;<span class="comment">//将temp插入</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序带哨兵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)    <span class="comment">//依次将A[2]-A[n]插入</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;<span class="comment">//若A[i]小于前面的</span></span><br><span class="line">            A[<span class="number">0</span>]=A[i];<span class="comment">//将A[i]暂存A[0]作为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; A[j]&gt;A[<span class="number">0</span>];--j)<span class="comment">//找到A[0]应当放的位置</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//所有大于A[0]的元素后移</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//将A[0]插入</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>将一个待排序的记录用<strong>折半查找</strong>的方式找到应当插入的位置，然后插入</p><p>空间复杂度：O（1）</p><p>时间复杂度：O（n^2）</p><p>稳定算法</p><p>适用于顺序存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;<span class="comment">//依次将A[2]-A[n]插入</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i];<span class="comment">//将A[i]暂存A[0]作为哨兵</span></span><br><span class="line">       low=<span class="number">1</span>,high=i<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">           mid=(low+gihg)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])</span><br><span class="line">               high=mid<span class="number">-1</span>;<span class="comment">//查找左边</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               low=mid+<span class="number">1</span>；<span class="comment">//查找右边</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;high+<span class="number">1</span>;--j)</span><br><span class="line">           A[j+<span class="number">1</span>]=A[j];<span class="comment">//统一后移</span></span><br><span class="line">       A[high+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将表中元素部分有序，在全局有序。假设增量d，对子表进行直接插入排序，再缩小d进行直接插入排序，直到d为1进行直接插入排序</p><p>空间复杂度：O（1）</p><p>时间复杂度：O（n^2）</p><p>不稳定算法</p><p>适用于顺序算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)  <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;   <span class="comment">//将A[i]插入有序子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];<span class="comment">//暂存A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span> &amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];<span class="comment">//记录后移，查找插入位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li>从后往前（从前往后）两两比较相邻元素的值，若为逆序，则交换他们，直到序列比较完</li><li>将最小的元素交换到待排序的第一个位置</li><li>进行下一趟冒泡时，前面确定的最小元素不参与比较，每趟冒泡的结果都是把序列中最小的元素放到了序列的最初位置</li><li>如果某一趟为发生交换，则算法结束</li></ol><p>空间复杂度：O（1）</p><p>时间复杂度：O（n^2）</p><p>稳定算法</p><p>适用于顺序存储和链式存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a.<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;     </span><br><span class="line">        <span class="type">bool</span> falg=<span class="literal">false</span>;       <span class="comment">//本轮排序是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--) <span class="comment">//一轮冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;   <span class="comment">//交换</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">                flag=<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(falg==<span class="literal">false</span>)</span><br><span class="line">              <span class="keyword">return</span> ;     <span class="comment">//没有发生交换，说明有序</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是基于比较的内部排序方法中最好的方法</p><ol><li>首先选取一个元素作为基准，然后以基准作为分界分为两个部分，左边的小于基准，右边的大于基准</li><li>对左右两个子序列递归的进行上述步骤</li></ol><p>空间复杂度：O（nlog2(n)）</p><p>时间复杂度：O（nlog2(n)）</p><p>不稳定算法</p><p>适用于顺序存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];<span class="comment">//第一个元素作为基准</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;<span class="comment">//用low、high搜索基准的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp;  A[high]&gt;=pivot) --high;</span><br><span class="line">        A[low]=A[high];<span class="comment">//比基准小的元素放左边</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp;  A[low]&gt;=pivot) ++low;</span><br><span class="line">        A[high]=A[low];<span class="comment">//比基准大的元素放右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;<span class="comment">//基准元素存放最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">//返回基准元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotops=<span class="built_in">Partition</span>(A,low,high);</span><br><span class="line">        <span class="built_in">QickSort</span>(A.low,pivotops<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QickSort</span>(A.pivotops+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排的优化</strong></p><p>1）选取头、中、尾三个位置的元素，取中间值作为基准元素</p><p>2）随机选一个元素作为基准元素</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ol><li>将表分为两个部分、有序部分和无序部分</li><li>每次从无序部分选取最小的元素，然后将其放入有序部分中</li></ol><p>空间复杂度：O（1）</p><p>时间复杂度：O（n^2）</p><p>不稳定算法</p><p>适用于顺序存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;    <span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min=i;<span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n+<span class="number">1</span>;j&lt;n;j++)<span class="comment">//在A[i~n-1]选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min]) min=j;<span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i) <span class="built_in">swap</span>(A[i],A[min])<span class="comment">//最小元素放最前面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>大根堆：父节点的值大于孩子结点的值</p><p>小根堆：父节点的值小于孩子结点的值</p><ol><li><p>建堆：按照大根堆的规则建立起相应的二叉树，那么根结点一定是最大值</p></li><li><p>调整堆：当根结点输出后，整颗二叉树可能被破坏，这是要根据相应的建堆规则，自底向上，从左往右，进行父节点与子节点的交换</p></li></ol><p>空间复杂度：O（1）</p><p>时间复杂度：O（nlog2（n））</p><p>不稳定算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)  <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k];<span class="comment">//A[0]暂存根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k,i&lt;len;i*=<span class="number">2</span>)&#123;<span class="comment">//沿着key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp;  A[i]&lt;A[i+<span class="number">1</span>])<span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;A[i])  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k]=A[i];<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k=i;<span class="comment">//修改k值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];<span class="comment">//被赛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">   <span class="built_in">BuildMaxHeap</span>(A,len);<span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//调整堆</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i],A[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>每次选定相应的元素分别合成一个新的有序表（2路归并&#x2F;多路归并）</p><p><img src="https://raw.githubusercontent.com/Wjjhui/picodemo/master/img/image-20220704160801193.png" alt="image-20220704160801193"></p><p>时间复杂度：O（nlog2（n））</p><p>空间复杂度：O（n）</p><p>稳定算法</p><p>适用于顺序表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low,mid]和A[mid+1,high]各自有序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> mid;<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k];</span><br><span class="line">    <span class="keyword">for</span>(i=low;j=mid+<span class="number">1</span>,k=i;i&lt;mid &amp;&amp;  j&lt;high ;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])</span><br><span class="line">            A[k]=B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">              A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=mid)  A[k++]=B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>按关键字位权重递减（递增）逐层划分成若干个更小的子序列，最后将所有子序列依次连接成一个有序的序列</p><p>d：将整个关键拆分为d组，r：关键字位可能取得r个值</p><p>时间复杂度：O（d（n+1））</p><p>空间复杂度：O（r）</p><p>稳定算法</p><p>按“个位”进行分配——&gt;收集——&gt;“十位”进行分配——&gt;收集——&gt;”百位“进行分配——&gt;收集</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220704161802598.png" alt="image-20220704161802598"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220704164533714.png" alt="image-20220704164533714"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第七章:查找</title>
    <link href="https://wjjhui.github.io/2022/06/29/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/"/>
    <id>https://wjjhui.github.io/2022/06/29/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/</id>
    <published>2022-06-29T10:30:51.000Z</published>
    <updated>2022-07-02T03:40:10.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>又称为线性查找。对顺序表和链表都适用。</p><h3 id="一般线性表的顺序查找"><a href="#一般线性表的顺序查找" class="headerlink" title="一般线性表的顺序查找"></a>一般线性表的顺序查找</h3><p><strong>基本思想</strong></p><ol><li>从线性表的一端开始，逐个检查关键字是否满足给定的条件</li><li>若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置</li><li>若已经查找到表的另一端。但还没有查找到符合给定条件的元素，则返回查找失败的信息</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *elem;</span><br><span class="line">    <span class="type">int</span> TableLen;   <span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.TableLen &amp;&amp; ST.elem[i]!=key;i++);</span><br><span class="line">    <span class="comment">//查找成功，返回下标，否则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> i==ST.TableLen?<span class="number">-1</span>:i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ASL（成功）&#x3D;（n+1）&#x2F;2</p><p>ASL（失败）&#x3D;n+1</p><p><strong>缺点</strong></p><ul><li>当n较大时，平均查找长度较大，效率低</li></ul><p><strong>优点</strong></p><ul><li>对数据元素的存储没有要求，顺序存储和链式存储都可以</li><li>对表中记录的有序性也没有要求，无论记录是否按关键字有序</li></ul><h3 id="有序表的顺序查找"><a href="#有序表的顺序查找" class="headerlink" title="有序表的顺序查找"></a>有序表的顺序查找</h3><p><strong>基本思想</strong></p><ol><li>假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key</li><li>当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，这时返回查找失败</li><li>因为第i个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的关键字</li></ol><p>ASL（成功）&#x3D;（n+1）&#x2F;2</p><p>ASL（失败）&#x3D;n&#x2F;2+n&#x2F;（n+1）</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>又称折半查找，适用于有序的顺序表</p><p><strong>基本思想</strong></p><ol><li>首先将key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置</li><li>若不等，则所需查找的元素只能在中间元素意外的前半部分或后半部分</li><li>然后在缩小的范围进行同样的查找，如此重复，直到找到为止</li><li>或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *elem;</span><br><span class="line">    <span class="type">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binart_Searcg</span><span class="params">(SSTable L,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[i]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220701150336675.png" alt="image-20220701150336675"></p><p>树高h&#x3D;log2（n+1）</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>又称索引顺序查找，吸取了顺序查找和折半查找各自的优点</p><p><strong>基本思想</strong></p><ol><li>将查找元素分为若干块</li><li>块内的元素可以无序，但块之间有序，第一个块中的最大关键字小于第个块中的所有记录的关键字</li><li>再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中第一个元素的地址，索引表按关键字排序</li></ol><p>折半查找+顺序查找：ASL&#x3D;L1+L2&#x3D;log2（b+1） + （s+1）&#x2F;2</p><p>顺序查找+顺序查找：ASL&#x3D;L1+L2&#x3D;（b+1）&#x2F;2  +  （s+1）&#x2F;2     s&#x3D;根号n，则平均查找长度最小</p><h2 id="二叉排序树（BST树）"><a href="#二叉排序树（BST树）" class="headerlink" title="二叉排序树（BST树）"></a>二叉排序树（BST树）</h2><p>又称二叉查找树，<strong>左子树结点值 &lt; 跟节点值 &lt; 右节点值</strong></p><h3 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220701150838141.png" alt="image-20220701150838141"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BSTSearch</span><span class="params">(BSTree T,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSTSreach</span>(T-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSTSreach</span>(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h3><p><img src="https://raw.githubusercontent.com/Wjjhui/picodemo/master/img/image-20220701151239683.png" alt="image-20220701151239683"></p><h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220701151558956.png" alt="image-20220701151558956"></p><h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>结点z的直接后继（直接前驱代替z）</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220701151815790.png" alt="image-20220701151815790"></p><h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p>简称平衡树，树上任一结点的左子树和右子树的高度之差不超过1</p><p>调整最小不平衡子树A</p><ul><li>LL：A的左孩子右上旋</li><li>RR：A的右孩子左上旋</li><li>LR：A的左孩子的右孩子 先左后右旋</li><li>RL：A的右孩子的左孩子 先右后左旋</li></ul><p>平均查找长度&#x2F;查找的时间复杂度：log2（n）</p><h2 id="红黑树（RBT"><a href="#红黑树（RBT" class="headerlink" title="红黑树（RBT)"></a>红黑树（RBT)</h2><p><img src="https://raw.githubusercontent.com/Wjjhui/picodemo/master/img/image-20220701153846660.png" alt="image-20220701153846660"></p><p>左根右、根叶黑、不红红、黑路同</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220701153921483.png" alt="image-20220701153921483"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第六章:图</title>
    <link href="https://wjjhui.github.io/2022/06/23/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE/"/>
    <id>https://wjjhui.github.io/2022/06/23/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE/</id>
    <published>2022-06-23T15:00:42.000Z</published>
    <updated>2022-06-28T08:25:29.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>图的定义：图G由顶点集V和边集E组成,记为G&#x3D;(V，E ) ,其中V(G)表示图G中顶点的有限非空集:E( G )表示图G中顶点之间的关系(边)集合</p><p><strong>注意！</strong>：线性表可以是空表，树可以是空树，图不能是空图</p><p><strong>简单图</strong>：不存在重复边，不存在顶点到自身的边</p><p><strong>多重图</strong>：若图中某两个结点之间的边数多于一条，有允许顶点通过同一条边和自己关联，则G为多重图</p><p><strong>子图</strong>：设有两个图G&#x3D;(VE)和G’&#x3D;(VE’),若V是V的子集,且E是E的子集,则称G’是G的子图。若有满足V(G’)&#x3D;V(G)的子图G，则称其为G的生成子图</p><p><strong>连通、连通图和连通分量</strong>：</p><ol><li>在无向图中，若顶点b到顶点w有路径存在，则称v和w是连通的</li><li>若图G中任意两个顶点都是连通，即有路径即可，则称图G为连通图</li><li>无向图中的极大连通子图称为连通分量</li><li>若一个图G有n个顶点且变数小于n-1，则G必为非连通图</li></ol><p><strong>强连通图、强连通分量</strong></p><ol><li>强连通图：在有向图G中，任意一对顶点之间存在相互通路的路径</li><li>强连通分量：有向图中的极大强连通图</li></ol><p><strong>无向完全图</strong>：无向图中任意两个顶点都存在边（）</p><p><strong>有向完全图</strong>：有向图中任意两个顶点之间存在方向相反的两条弧&lt;&gt;</p><h2 id="图的存储和基本操作"><a href="#图的存储和基本操作" class="headerlink" title="图的存储和基本操作"></a>图的存储和基本操作</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>用一个一维数组存储图顶点中的信息，用一个二位数组存储图中边的信息（即各顶点之间的邻接关系）</p><p>存储顶点之间邻接关系的二位数组称为邻接矩阵，在无向图中可以通过矩阵压缩。</p><p><strong>优点</strong>：</p><ol><li><p>直观，简单，方便检查任意一对顶点间是否存在边</p></li><li><p>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</p></li><li><p>方便计算任一节点的 “度” （从该点出发的边数为“出度”，指向该点的边数为“入度”</p><ul><li><p>无向图：对应行（列）的非0元素的个数</p></li><li><p>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”</p></li></ul></li></ol><p><strong>缺点</strong>：</p><ul><li>浪费空间—存储稀疏的时候，有大量无效元素，但是如果稠密的话，就不会有这个问题</li><li>浪费时间—统计稀疏图中一共有多少边</li><li>空间复杂度为O（n^2）</li></ul><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>对于稀疏图使用邻接矩阵法要浪费大量的存储空间，邻接表法了结合了顺序存储和链式存储。类似于树的孩子表示法。</p><p>对于图G中的每个顶点建立一个链表，链表中的结点表示依附于顶点</p><p>边表和头指针和顶点的数据信息采用顺序存储（顶点表）</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220627221450297.png" alt="image-20220627221450297"></p><p>特点：</p><ol><li>若G为无向图，则所需的存储空间为O（|v|+2|E|）,若G为有向图，则所需的存储空间为O（|v|+|E|）</li><li>对于稀疏图，采用邻接表法可以大量的节省存储空间</li><li>在无向图的邻接表中，给定一顶点，能很容易的找出它的所有邻边</li><li>在有向图的邻接表中，求一个给定顶点的出度只需要计算其邻接表中的结点个数，但求其顶点的入度则需要遍历全部的邻接表</li><li>图的邻接表表示并不唯一</li></ol><h3 id="十字链表法（有向图）"><a href="#十字链表法（有向图）" class="headerlink" title="十字链表法（有向图）"></a>十字链表法（有向图）</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220627224308042.png" alt="image-20220627224308042"></p><h3 id="邻接多重表法（无向图）"><a href="#邻接多重表法（无向图）" class="headerlink" title="邻接多重表法（无向图）"></a>邻接多重表法（无向图）</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220627225156835.png" alt="image-20220627225156835"></p><h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><p>AdjacentG（G，x，y）：判断图G是否存在边&lt;x，y&gt;或（x，y）</p><p>Neihbors（G，x）：列出图G中与x邻接的边</p><p>InsertVertex（G，x）：在图G中插入顶点x</p><p>DeleteVertex（G，x）：从图中删除顶点x</p><p>AddEdge（G，x，y）：若无向边（x，y）或有向边&lt;x，y&gt;不存在，则向图中添加该边</p><p>RemoveEdge（G，x，y）：若无向边（x，y）或有向边&lt;x，y&gt;存在，则从图G中删除该边</p><p>FirstNeighbor（G，x）：求图G中顶点x的第一个邻接点</p><p>NextNeighbor（G，x，y）：求图G中除y之外顶点x的下一个邻接点的定点号</p><p>Get_egde_value(G，x，y)：获取图G中边（x，y）或&lt;x，y&gt;对应的权值</p><p>Set_egde_value(G，x，y)：设置图G中边（x，y）或&lt;x，y&gt;对应的权值</p><h2 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h2><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><ul><li>邻接矩阵存储图的时间复杂度为：O（V^2）</li><li>邻接表存储图的时间复杂度为：O（V+E）</li></ul><p>空间复杂为：O（V）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对图进行遍历，初始值标记全部为false，遍历过标记为true</span></span><br><span class="line"><span class="comment">//对于每个连通分量调用一次BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            <span class="built_in">BFS</span>(G,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;    <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=TRUE;<span class="comment">//对v做已访问的标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);<span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);<span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=True;<span class="comment">//对w标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w)<span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><ul><li>邻接矩阵存储图的时间复杂度为：O（V^2）</li><li>邻接表存储图的时间复杂度为：O（V+E）</li></ul><p>空间复杂为：O（V）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对图进行遍历，初始值标记全部为false，遍历过标记为true</span></span><br><span class="line"><span class="comment">//对于每个连通分量调用一次BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            <span class="built_in">DFS</span>(G,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;    <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=TRUE;<span class="comment">//对v做已访问的标记</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);<span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">              <span class="built_in">DFS</span>(G,w)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><strong>Prim算法（从顶点出发）</strong></p><p>从一个顶点开始构建生成树，每次讲代价最小的新顶点纳入生成树，直到所有顶点都纳入为止</p><p>时间复杂度为：O（V^2）</p><p><strong>Kruskal算法（从边出发）</strong></p><p>每次选择一条权值最小的边，使这条边的两头连通（原来已经连通的就不选），直到所有结点都连通</p><p>时间复杂度为：O（Elog2E）</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="BFS广度优先算法（无权图）"><a href="#BFS广度优先算法（无权图）" class="headerlink" title="BFS广度优先算法（无权图）"></a><strong>BFS广度优先算法（无权图）</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        d[i]=+<span class="number">00</span>;   <span class="comment">//路径前驱</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[v]=TRUE;<span class="comment">//对v做已访问的标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);<span class="comment">//顶点v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;</span><br><span class="line">                path[w]=u;</span><br><span class="line">                visited[w]=True;<span class="comment">//对w标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w)<span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220628153614030.png" alt="image-20220628153614030"><strong>Dijkstra算法</strong></h4><ol><li>初始化：集和S初始为{0}，dist[]初始值为与顶点v0的路径长度，path[]初始值为路径上的前驱。</li><li>从顶点集S选出路径长度最短的顶点v</li><li>修改从v出发到集和上其他顶点可达的路径长度，比当前长度短则修改dist长度并将前驱修改为v</li><li>重复2-3操作n-1次，直到多有顶点都包含在S中</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220628153805303.png" alt="image-20220628153805303"></p><p><strong>注意！:不适用于权值存在负数的情况</strong></p><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a><strong>Floyd算法</strong></h4><p>求每一对顶点之间的最短路径</p><p>使用动态规划思想，将问题的求解分为多个阶段</p><ol><li>初始：不允许存在其他顶点中转，最短路径是？</li><li>若允许v0中转，最短路径是？</li><li>若允许v0，v1中转，最短路径是？</li><li>……</li><li>若允许v0，v1，v2，v3……vn-1中转，最短路径是？</li></ol>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第五章:树</title>
    <link href="https://wjjhui.github.io/2022/06/21/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%A0%91/"/>
    <id>https://wjjhui.github.io/2022/06/21/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%A0%91/</id>
    <published>2022-06-21T03:15:37.000Z</published>
    <updated>2022-06-27T16:08:00.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ol><li><strong>结点的度</strong>（Degree）：结点的<strong>子树个数</strong></li><li><strong>树的度</strong>：树的所有结点中最大的度数</li><li><strong>叶结点</strong>（Leaf）：<strong>度为0</strong>的结点</li><li><strong>父结点</strong>（Parent）：若一个结点含有子结点，则这个结点称为其结点的父结点</li><li><strong>子结点</strong>（Child）：若A结点是B节点的父结点，则B节点是A节点的子结点，也称孩子结点</li><li><strong>兄弟结点</strong>（Sibling）：具有同一父结点的各结点彼此是兄弟结点</li><li><strong>路径和路径长度</strong>：从结点N1到Nk的路径为一个结点序列，结点的个数为路径的长度</li><li><strong>祖先结点</strong>（Ancestor）：沿树根到某一结点路径上所有结点都是这个结点的祖先结点</li><li><strong>子孙结点</strong>（Descendant）：某一结点的子树中的所有结点是这个结点的子孙</li><li><strong>结点的层次</strong>（Level）：规定根结点在1层</li><li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度</li><li><strong>有序树</strong>：树中结点的各子树从左到右是有次序的，不能互换</li><li><strong>森林</strong>：森林是n颗互不相交的树的集和</li></ol><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ol><li>m叉树：每个结点至多有m个子树</li><li>度为m的树：至少有一个结点度为m</li><li>树的结点数等于所有结点的度+1   n&#x3D;n0+n1+n2+…+1</li><li>度为m的树中第i层至多有m^(i-1)个结点</li><li>高度为h的m叉树至少有h个结点</li><li>高度为h的m叉树至多有(m^i-1)&#x2F;(m-1)个结点</li><li>高度为h，度为m的树至少有h+m-1个结点</li><li>具有n个结点的m叉树的最小高度为<img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220621160952357.png" alt="image-20220621160952357"></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220621161349528.png" alt="image-20220621161349528"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220621161446711.png" alt="image-20220621161446711"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220622165732541.png" alt="image-20220622165732541"></p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol><li><p>n&#x3D;n0+n1+n2    , n&#x3D;n1+2n2+1  &#x3D;&#x3D;&gt;   n0&#x3D;n2+1</p></li><li><p>一个二叉树第 i 层 至多有<strong>2^(i-1)</strong> 个结点</p></li><li><p>深度为h的二叉树至多有<strong>2^h-1</strong>个结点</p></li><li><p>n个结点的完全二叉树的高度为【log2（n+1）】或者【log2（n）】+1</p></li><li><p>在n个结点的二叉链表中，含有n+1个空链域。</p></li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value; <span class="comment">//结点中的数据元素</span></span><br><span class="line"><span class="type">bool</span> isEmpty; <span class="comment">//是否为空</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在完全二叉树中</p><p>i的左孩子为：2i</p><p>i的右孩子为：2i+1</p><p>i的父结点为：【i&#x2F;2】</p><p>i所在的层次为：【log2（n+1）】或者【log2（n）】+1</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* lchild, * rchild;<span class="comment">//左右孩子结点</span></span><br><span class="line">&#125;BiTNode,* BiTree;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ol><li>先序——根，左子树，右子树</li><li>中序——左子树，根，右子树</li><li>后序—–左子树，右子树，根</li><li>层次遍历—从上到下，从左到右（一层一层的遍历，从左到右）</li></ol><p>二叉树的<strong>先序&#x2F;后序&#x2F;层序</strong>和<strong>中序</strong>遍历可以唯一确定一颗二叉树</p><p><strong>递归遍历二叉树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreTraversalRecursion</span><span class="params">(BiTree t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历 递归 根 左 右</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;Data);</span><br><span class="line">        <span class="built_in">PreTraversalRecursion</span>(t-&gt;Left);</span><br><span class="line">        <span class="built_in">PreTraversalRecursion</span>(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiddleTraversalRecursion</span><span class="params">(BiTree t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历 递归，左 根 右</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">MiddleTraversalRecursion</span>(t-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;Data);</span><br><span class="line">        <span class="built_in">MiddleTraversalRecursion</span>(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostTraversalRecursion</span><span class="params">(BiTree t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历 递归，左 右 根</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostTraversalRecursion</span>(t-&gt;Left);</span><br><span class="line">        <span class="built_in">PostTraversalRecursion</span>(t-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历二叉树</strong></p><ol><li>算法思想</li><li>初始化一个辅助队列</li><li>根结点入队</li><li>若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾</li><li>重复3直到队列空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);    <span class="comment">//二叉树的链式存储</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,T);  <span class="comment">//根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;  <span class="comment">//队列不空则循环</span></span><br><span class="line">        <span class="built_in">DeleteQ</span>(Q,p); <span class="comment">//队头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p)      <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Left)  <span class="built_in">EnQueue</span>(Q,p-&gt;Left);    <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right) <span class="built_in">EnQueue</span>(Q,p-&gt;Right);   <span class="comment">//右孩子入队 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>基本概念</p><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列</p><p>使得该序列中的每个结点（除第一个和最后一个）都有一个直接前驱和直接后继</p><p>利用n+1<strong>个空链域</strong>作为线索</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220622170630862.png" alt="image-20220622170630862"></p><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="comment">//*lchild   ltag  data   rtag  *rchild</span></span><br><span class="line"><span class="comment">//tag为0：表示指针指向其孩子    tag为1：表示指针是线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild;<span class="comment">//左右孩子结点</span></span><br><span class="line"><span class="type">int</span> ltag, rtag;<span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t!= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">InThread</span>(t-&gt;lchild);<span class="comment">//  中序左 根  右</span></span><br><span class="line"><span class="built_in">visit</span>(t);</span><br><span class="line"><span class="built_in">InThread</span>(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;  <span class="comment">//左子树为空，建立前驱索引</span></span><br><span class="line">q-&gt;lchild = pre;      <span class="comment">//q的前驱为pre</span></span><br><span class="line">q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继索引</span></span><br><span class="line">pre-&gt;ltag = <span class="number">1</span>;<span class="comment">//pre的后继为q</span></span><br><span class="line">&#125;</span><br><span class="line">pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">InThread</span>(T);</span><br><span class="line"><span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//处理最后一个结点</span></span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序线索二叉树找中序后继"><a href="#中序线索二叉树找中序后继" class="headerlink" title="中序线索二叉树找中序后继"></a>中序线索二叉树找中序后继</h3><p>p为根的子树，p节点的后继为右子树最左边的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索二叉树找中序后继</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//找到最左边的结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到p节点的后继结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//右子树中最左下结点</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ThreadNode* p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line"><span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序线索二叉树找中序前驱"><a href="#中序线索二叉树找中序前驱" class="headerlink" title="中序线索二叉树找中序前驱"></a>中序线索二叉树找中序前驱</h3><p>p为根的子树，p节点的前驱为左子树最右边的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索二叉树找中序前驱</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//找到最右边的结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到p节点的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//右子树中最左下结点</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;lchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ThreadNode* p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line"><span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法（顺序存储）"><a href="#双亲表示法（顺序存储）" class="headerlink" title="双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h4><p>采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中位置</p><p>优点：利用了每个结点只有唯一双亲的性质，可以很快的到每个结点的双亲结点</p><p>缺点：求每个结点的孩子时需要遍历整个结构</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220622185736582.png" alt="image-20220622185736582"></p><h4 id="孩子表示法（顺序-链式存储）"><a href="#孩子表示法（顺序-链式存储）" class="headerlink" title="孩子表示法（顺序+链式存储）"></a>孩子表示法（顺序+链式存储）</h4><p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，此时n个结点就有n个孩子链表</p><p>优点：寻找子女的操作非常简单</p><p>缺点：寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220622190338813.png" alt="image-20220622190338813"></p><h4 id="孩子兄弟表示法（链式存储）"><a href="#孩子兄弟表示法（链式存储）" class="headerlink" title="孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h4><p>以二叉链表作为树的存储结构，左指针为孩子、右指针为兄弟</p><p>结点值、指向结点第一个孩子结点的指针、指向结点下一个兄弟结点的指针</p><p>优点：可以很方便地实现树转换为二叉树的操作，易于查找结点的孩子</p><p>缺点：从当前结点查找其双亲结点比较麻烦</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/image-20220622190506702.png" alt="image-20220622190506702"></p><h3 id="树、二叉树、森林的转换"><a href="#树、二叉树、森林的转换" class="headerlink" title="树、二叉树、森林的转换"></a>树、二叉树、森林的转换</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><p>每个结点左指针指向孩子，右指针指向兄弟</p><h4 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h4><ol><li>将森林中的每个颗树转换为相应的二叉树</li><li>每棵树的根视为兄弟关系，在每棵树的根之间加一根连线</li><li>以第一棵树的根为轴心顺时针转45度</li></ol><h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4><p>二叉树的根及其左子树为第一棵树的二叉树形式</p><p>二叉树根的右子树可视为一个由除了第一棵树外的森林转换后的二叉树</p><h3 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h3><h4 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h4><p>若树非空，先访问根结点，再依次遍历根结点的每颗子树，遍历子树仍遵循先根后子树的规则</p><p>其遍历的序列与这颗树相应的二叉树的先序序列相同</p><h4 id="后跟遍历"><a href="#后跟遍历" class="headerlink" title="后跟遍历"></a>后跟遍历</h4><p>若树非空，先依次遍历根结点的每颗子树，在访问根结点，遍历子树仍遵循先子树后根的规则</p><p>其遍历的序列与这棵树相应的二叉树的中序序列相同</p><h4 id="先序遍历森林"><a href="#先序遍历森林" class="headerlink" title="先序遍历森林"></a>先序遍历森林</h4><ol><li>访问森林中第一颗树的根结点</li><li>先序遍历第一棵树中根节点的子树森林</li><li>先序遍历除去第一棵树后剩余的树构成的森林</li></ol><h4 id="中序遍历森林"><a href="#中序遍历森林" class="headerlink" title="中序遍历森林"></a>中序遍历森林</h4><ol><li>中序遍历森林中的第一颗树的根结点的子树森林</li><li>访问第一棵树的根结点</li><li>中序遍历除去第一棵树之后剩余的树构成的森林</li></ol><h2 id="哈夫曼"><a href="#哈夫曼" class="headerlink" title="哈夫曼"></a>哈夫曼</h2><p>  **带权路径长度(WPL)**： 树中所有叶子结点的带权路径长度之和</p><p>特点：</p><ul><li>没有度为1的节点</li><li>n个叶子节点的哈夫曼树共有2n-1个节点</li><li>哈夫曼树任意非叶子的左右子树交换仍然是哈夫曼树</li><li>同一组权值，存在不同构的哈夫曼树</li></ul><p>哈夫曼树：WPL最小的二叉树</p><p><strong>构造哈夫曼树</strong>：每次选择两个根结点权值最小的树合并，并将二者权值之和作为新的根结点的权值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *HuffmanTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line"><span class="comment">//我们所有节点假设权值已经算好在weight中</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="built_in">BuildMinHeap</span>(H);<span class="comment">//构建最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt; H-&gt;size; i++)&#123;</span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        <span class="comment">//从最小堆删除节点，作为左节点和右节点</span></span><br><span class="line">        T-&gt;Left = <span class="built_in">DeleteMin</span>(H);</span><br><span class="line">        T-&gt;Right = <span class="built_in">DeleteMin</span>(H);</span><br><span class="line">        <span class="comment">//计算新的权值</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        <span class="comment">//插入最小堆</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T = <span class="built_in">DeleteMin</span>(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈夫曼编码</strong>：将字符频此作为节点权值，构造哈夫曼树。使用不等长编码，利用前缀码perfix code（任何字符的编码都不是另一字符编码的前缀）</p><p>类似于<a href="https://wjjhui.github.io/2022/05/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">扩展操作码指令格式</a></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第四章:串</title>
    <link href="https://wjjhui.github.io/2022/06/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2/"/>
    <id>https://wjjhui.github.io/2022/06/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2/</id>
    <published>2022-06-20T11:27:30.000Z</published>
    <updated>2022-06-20T11:42:13.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>字符串简称串，是由零个或多个字符组成的有限序列。</p><p>串中任意个连续的字符组成的子序列成为该串的子串，包含子串的串成为主串</p><p>子串在主串中的位置以子串的第一个字符在主串中的位置表示</p><p>当两个串的长度相等且每个对应位置的字符都相等时，称这个两个串是相等的</p><p>由一个或多个空格组成串成为空格串</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>StrAssign（T,chars）：赋值操作</p><p>StrCopy（&amp;T，S）：复制操作</p><p>StrEmpty（S）：判空操作</p><p>StrCompare（S,T）:比较操作</p><p>StrLength（S）：求串长</p><p>SubString（&amp;Sub，S,pos，len）：求子串</p><p>Concat（&amp;T,S1,S2）:串连接</p><p>Index（S,T）:定位操作</p><p>ClearString（S）:清空操作</p><p>DestoryString（&amp;S）:销毁操作</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态数组实现,</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> ch[MaxSize];   <span class="comment">//每个分量存储一个字符</span></span><br><span class="line"><span class="type">int</span> length;         <span class="comment">//串的实际长度</span></span><br><span class="line"> &#125;SString;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组实现，</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span>* ch;<span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line"><span class="type">int</span> length;         <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StringNode</span>* next;</span><br><span class="line">&#125;StringNode,* StringStr;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串  返回S的第pos个字符起长度为len的子串</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length)  <span class="comment">//子串范围越界</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos,j=<span class="number">1</span>; i &lt; pos + len; i++,j++) &#123;</span><br><span class="line">Sub.ch[j] = S.ch[i];</span><br><span class="line">&#125;</span><br><span class="line">Sub.length = len;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较操作  S&gt;T 返回值&gt;0;S=T 返回值=0；S&lt;T 返回值&lt;0 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; S.length &amp;&amp; i &lt; T.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (S.ch[i] != T.ch[i])</span><br><span class="line"><span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作  主串S中存在与串T相同的子串，返回第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Index</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, n = S.length, m = T.length;</span><br><span class="line">SString temp;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n - m + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">SubString</span>(temp, S, i, m);  <span class="comment">//找出所有与T串长度相等的子串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StrCompare</span>(S, temp) != <span class="number">0</span>)  <span class="comment">//所有字串与T相比较</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不存在与T 相等的子串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模式匹配算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index2</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (S.ch[i] == T.ch[j])&#123;</span><br><span class="line">++i;<span class="comment">//比较后继字符 </span></span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = i - j + <span class="number">2</span>;   <span class="comment">//指针后退重新匹配</span></span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line"><span class="keyword">return</span> i - T.length;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KMP算法</span></span><br><span class="line"> <span class="comment">//首先进行预处理，对模式串进行右移得出next数组 </span></span><br><span class="line"><span class="comment">//next[]= null   0 1 1 2 2 3 </span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;S.length&amp;&amp;j&lt;T.length) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">++i;</span><br><span class="line">++j;     <span class="comment">//比较后继字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];<span class="comment">//模式串移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line"><span class="keyword">return</span> i - T.length;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//KMP的优化</span></span><br><span class="line"><span class="comment">//nextval数组代替next数组</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第三章:栈和队列</title>
    <link href="https://wjjhui.github.io/2022/06/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://wjjhui.github.io/2022/06/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-06-20T02:59:07.000Z</published>
    <updated>2022-06-20T06:43:31.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>只允许在一段进入插入或删除操作的线性表  先进后出</p><p>栈的基本操作</p><p>InitStack（&amp;S）：初始化</p><p>StackEmpty（S）：判空</p><p>Pop（&amp;S,&amp;X）：出栈</p><p>Push（&amp;S,X）:入栈</p><p>GetTop（S,&amp;X）:读取栈顶元素</p><p>DestoryStack（&amp;S）：销毁栈</p><h3 id="1）栈的顺序结构"><a href="#1）栈的顺序结构" class="headerlink" title="1）栈的顺序结构"></a>1）栈的顺序结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个顺序栈</span></span><br><span class="line"><span class="comment">//先进后出</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];  <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//栈为空</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)  <span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.top = S.top + <span class="number">1</span>;  <span class="comment">//指针+1</span></span><br><span class="line">S.data[S.top] = x;</span><br><span class="line"><span class="comment">//等价于S.data[++S.top]=x</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)   <span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top];   <span class="comment">//栈顶元素出栈</span></span><br><span class="line">S.top = S.top - <span class="number">1</span>;   <span class="comment">//指针减1 </span></span><br><span class="line"><span class="comment">//等价于x=S.data[S.top--]</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">getTop</span><span class="params">(SqStack S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)   <span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈定向共享空间的中间延伸</p><p>当两个栈的栈顶指针都指向栈定元素top0&#x3D;-1，top1&#x3D;MaxSize时  栈空</p><p>入栈时++top0，–top1</p><h3 id="2）栈的链式结构"><a href="#2）栈的链式结构" class="headerlink" title="2）栈的链式结构"></a>2）栈的链式结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个链栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;<span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,*LiStack; </span><br><span class="line"><span class="comment">//LNode *L  等同于LiStack L</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个链栈 ，带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitLStack</span><span class="params">(LiStack &amp;s)</span> </span>&#123;</span><br><span class="line">s=(LNode * )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">(LiStack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack&amp; s, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line"> LNode* temp=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    temp-&gt;data=data;</span><br><span class="line">    temp-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack&amp; S, <span class="type">int</span>  &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEmpty</span>(S))   <span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* temp = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">temp = S-&gt;next;</span><br><span class="line">S-&gt;next = temp-&gt;next;</span><br><span class="line">x = temp-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">getTop</span><span class="params">(LiStack S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEmpty</span>(S))   <span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>只允许在一段进行插入另一端进行删除操作  先进先出</p><p>队列的基本操作</p><p>InitQueue（&amp;Q）：初始化</p><p>QueueEmpty（Q）；判空</p><p>EnQueue（&amp;Q,X）:入队</p><p>DeQueue（&amp;Q,&amp;X）:出队</p><p>GetHead（Q,&amp;x）:读取队头元素</p><h3 id="1）队列的顺序结构"><a href="#1）队列的顺序结构" class="headerlink" title="1）队列的顺序结构"></a>1）队列的顺序结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列 先进先出</span></span><br><span class="line"><span class="comment">//定义一个队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];  <span class="comment">//数组存放队列元素</span></span><br><span class="line"><span class="type">int</span> front, rear;<span class="comment">//队头和队位指针</span></span><br><span class="line">&#125;SeQueue;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">InitQueue</span><span class="params">(SeQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">Q.rear = Q.front=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(SeQueue Q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">EnQueue</span><span class="params">(SeQueue&amp; Q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize==Q.front)  <span class="comment">//判断队满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Q.data[Q.rear] = x;</span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize ;    <span class="comment">//循环队列</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队  删除队头元素并用x返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SeQueue&amp; Q,<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)  <span class="comment">//判断队空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">x = Q.data[Q.front];</span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Gethead</span><span class="params">(SeQueue Q, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)  <span class="comment">//判断队空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">x = Q.data[Q.front];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）队列的链式结构"><a href="#2）队列的链式结构" class="headerlink" title="2）队列的链式结构"></a>2）队列的链式结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;    <span class="comment">//链式队列节点</span></span><br><span class="line"><span class="type">int</span> data;                <span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;   <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">LinkNode* front, * rear;  <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素x入队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//创建一个新节点</span></span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next = s;    <span class="comment">//新节点插入到队尾后</span></span><br><span class="line">Q.rear = s;<span class="comment">//修改队尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队  并用x带出 出队数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//队空</span></span><br><span class="line">LinkNode* p = Q.front-&gt;next;   <span class="comment">//保存队头的后一个指针</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//保存队友的后一个元素数据</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;<span class="comment">//队头指针向后移</span></span><br><span class="line"><span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">Q.front == Q.rear;          <span class="comment">//出队的是最后一个节点</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个顺序栈</span></span><br><span class="line"><span class="comment">//先进后出</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> data[MaxSize];  <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, <span class="type">char</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, <span class="type">char</span>&amp; x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">getTop</span><span class="params">(SqStack S, <span class="type">char</span>&amp; x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> lens)</span> </span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line"><span class="built_in">InitStack</span>(S);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lens; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line"><span class="built_in">Push</span>(S, str[i]);      <span class="comment">//左括号入栈</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StackEmpty</span>(S))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//扫描到右括号， 但是栈空</span></span><br><span class="line"><span class="type">char</span> topElem;</span><br><span class="line"><span class="built_in">Pop</span>(S, topElem);   <span class="comment">//栈定元素出栈</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StackEmpty</span>(S))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆波兰式"><a href="#逆波兰式" class="headerlink" title="逆波兰式"></a>逆波兰式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span><span class="comment">//压栈和出栈都在栈顶进行(这里的栈顶指前一段)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> val;<span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;<span class="comment">//指针</span></span><br><span class="line">&#125;pnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">seqstack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//记录栈的大小</span></span><br><span class="line">    pnode* top;<span class="comment">//指向栈顶元素</span></span><br><span class="line">&#125;phead;</span><br><span class="line"><span class="function">phead*  <span class="title">initstack</span><span class="params">()</span><span class="comment">//创建栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phead* istack=(phead*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(phead));<span class="comment">//为头节点分配空间</span></span><br><span class="line">    <span class="keyword">if</span>(istack!=<span class="literal">NULL</span>)<span class="comment">//健壮性判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        istack-&gt;top=<span class="literal">NULL</span>;</span><br><span class="line">        istack-&gt;size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> istack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(phead* istack)</span><span class="comment">//判断栈为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(istack-&gt;top==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈不为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pnode* <span class="title">seqstack_top</span><span class="params">(phead* istack)</span><span class="comment">//获取栈顶元素的数据节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(istack-&gt;size!=<span class="number">0</span>)<span class="comment">//栈不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> istack-&gt;top;<span class="comment">//返回的是栈顶的数据节点而不是栈顶的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pnode* <span class="title">seqstack_pop</span><span class="params">(phead* istack)</span><span class="comment">//弹出栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isempty</span>(istack)==<span class="number">0</span>)<span class="comment">//栈不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        pnode* account=istack-&gt;top;<span class="comment">//记录栈顶的数据节点</span></span><br><span class="line">        istack-&gt;top=istack-&gt;top-&gt;next;<span class="comment">//指向栈顶下一个元素</span></span><br><span class="line">        istack-&gt;size--;<span class="comment">//记录栈的大小</span></span><br><span class="line">        <span class="keyword">return</span> account;<span class="comment">//返回弹出的数据节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqstack_push</span><span class="params">(phead* istack,<span class="type">char</span> x)</span><span class="comment">//压栈(入栈)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pnode* temp;<span class="comment">//进行压栈的数据节点</span></span><br><span class="line">   temp=(pnode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(pnode));</span><br><span class="line">   temp-&gt;val=x;<span class="comment">//填充数据域</span></span><br><span class="line">   temp-&gt;next=istack-&gt;top;<span class="comment">//连接栈顶的数据节点</span></span><br><span class="line">   istack-&gt;top=temp;<span class="comment">//充当栈顶</span></span><br><span class="line">   istack-&gt;size++;<span class="comment">//记录栈大小的变化</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//下面是中缀表达式转后缀表达式的函数</span></span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//即对数组中每个数据都初始化为&#x27;\0&#x27;(\0的ascill码是0)</span></span><br><span class="line"> <span class="comment">//buffer为结果串</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">char_put</span><span class="params">(<span class="type">char</span> ch)</span><span class="comment">//用来将字符放入放入结果串</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> index=<span class="number">0</span>;<span class="comment">//static定义静态变量,放函数中表示index只初始化一次,只保留index的改变</span></span><br><span class="line">     buffer[index++]=ch;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">(<span class="type">char</span> ch)</span><span class="comment">//用来比较优先级</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">switch</span>(ch)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="comment">//case穿透,即上一个case没有break语句时会继续向下执行</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            ret=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            ret=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">//这里直接break也可以</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">is_number</span><span class="params">(<span class="type">char</span> ch)</span><span class="comment">//是不是数字</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>);<span class="comment">//数字返回1，否则返回0</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">is_operator</span><span class="params">(<span class="type">char</span> ch)</span><span class="comment">//是不是运算符</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>(ch==<span class="string">&#x27;+&#x27;</span>||ch==<span class="string">&#x27;-&#x27;</span>||ch==<span class="string">&#x27;*&#x27;</span>||ch==<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">is_left</span><span class="params">(<span class="type">char</span> ch)</span><span class="comment">//是不是左括号</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>(ch==<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">is_right</span><span class="params">(<span class="type">char</span> ch)</span><span class="comment">//是不是右括号</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>(ch==<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">transform</span><span class="params">(<span class="type">char</span> str[])</span><span class="comment">//使用const保护数据,函数用来将中缀转换成后缀</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     phead* istack=<span class="built_in">initstack</span>();<span class="comment">//创建一个栈</span></span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//遍历整个字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是不是数字</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_number</span>(str[i])==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">is_number</span>(str[i+<span class="number">1</span>])==<span class="number">1</span>)<span class="comment">//后面1也是数字,则直接放</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char_put</span>(str[i]);<span class="comment">//数字直接放入结果串(即输出)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//后面不是数字,添加一个空格作为分隔符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char_put</span>(str[i]);</span><br><span class="line">                <span class="built_in">char_put</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_operator</span>((str[i]))==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ILLEGAL&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isempty</span>(istack)==<span class="number">0</span>)<span class="comment">//栈不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>((<span class="built_in">isempty</span>(istack)==<span class="number">0</span>)&amp;&amp;(<span class="built_in">priority</span>(str[i])&lt;=(<span class="built_in">priority</span>(<span class="built_in">seqstack_top</span>(istack)-&gt;val))))<span class="comment">//栈不为空并且新运算符优先级不高于栈顶</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">char_put</span>(<span class="built_in">seqstack_pop</span>(istack)-&gt;val);<span class="comment">//满足条件的栈顶就弹出直到不满足条件</span></span><br><span class="line">                    <span class="built_in">char_put</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">seqstack_push</span>(istack,str[i]);<span class="comment">//再将该运算符入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_left</span>(str[i]))<span class="comment">//左括号直接入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">seqstack_push</span>(istack,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_right</span>(str[i]))<span class="comment">//判断是不是右括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">is_left</span>(<span class="built_in">seqstack_top</span>(istack)-&gt;val)!=<span class="number">1</span>)<span class="comment">//栈顶不是左括号的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char_put</span>(<span class="built_in">seqstack_pop</span>(istack)-&gt;val);<span class="comment">//弹出并存储到结果串</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isempty</span>(istack)==<span class="number">1</span>)<span class="comment">//栈为空仍未找到左括号</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;没有匹配到左括号\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时匹配到了左括号</span></span><br><span class="line">            <span class="built_in">seqstack_pop</span>(istack);</span><br><span class="line">            <span class="comment">//弹出左括号,这里并不用保存,即两个括号相抵消</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;有不能识别的字符\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历完了已经</span></span><br><span class="line">    <span class="keyword">if</span>(str[i]==<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//成功遍历到字符串末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isempty</span>(istack)==<span class="number">0</span>)<span class="comment">//弹出全部栈中元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">seqstack_top</span>(istack)-&gt;val==<span class="string">&#x27;(&#x27;</span>)<span class="comment">//栈顶元素为左括号</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;有没有匹配到的&#x27;(&#x27;,缺少&#x27;)&#x27;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">char_put</span>(<span class="built_in">seqstack_pop</span>(istack)-&gt;val);<span class="comment">//将栈中元素放入最终串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;遍历没有完成！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//将数组每个元素赋值为&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入四则运算表达式:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="type">int</span> number=<span class="built_in">transform</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表达式转换错误:\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;转化后的表达式: %s\n&quot;</span>,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5.png" alt="对称矩阵"></p><p>三角矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B51.png" alt="三角矩阵1"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B52.png" alt="三角矩阵2"></p><p>三对角矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5.png" alt="三对角矩阵"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第二章:顺序表</title>
    <link href="https://wjjhui.github.io/2022/06/18/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>https://wjjhui.github.io/2022/06/18/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/</id>
    <published>2022-06-18T06:53:51.000Z</published>
    <updated>2022-06-20T02:59:08.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、线性表的定义和操作"><a href="#1、线性表的定义和操作" class="headerlink" title="1、线性表的定义和操作"></a>1、线性表的定义和操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1、元素个数有限</p><p>2、表中的元素具有逻辑上的顺序性，表中元素有先后次序</p><p>3、表中元素都是数据元素，每个元素都是单个元素</p><p>4、每个元素占有相同大小的存储空间</p><h4 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h4><p>线性表是一种逻辑结构，表示元素之间一对一的相邻关系</p><p>顺序表和链表是指存储结构</p><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><p>InitList（&amp;L）；初始化</p><p>length（L）:求表长</p><p>locateElem（L,e）：按值查找</p><p>getElem（L,I）：按位查找</p><p>listInsert（&amp;L，e）：插入操作</p><p>liseDelete（&amp;L，&amp;e）：删除操作</p><p>printList（L）：输出操作</p><p>empty（L）：判空操作</p><p>destory（&amp;L）:销毁操作</p><h2 id="2、线性表的顺序表示"><a href="#2、线性表的顺序表示" class="headerlink" title="2、线性表的顺序表示"></a>2、线性表的顺序表示</h2><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><p>用一组地址连续的存储单元依次存放线性表中的数据元素</p><p>静态分配：数组的大小和空间已经固定，一旦空间占满，再加入新的数据会产生溢出，程序就会崩溃。</p><p>动态分配：存储出租的空间是再程序执行过程中通过动态分配语句分配的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、随机访问，即通过首地址和元素序号可在时间O（1）内找到指定的元素</p><p>2、存储密度高，每个节点只存储数据元素</p><p>3、逻辑上相邻的元素物理上也相邻，当执行插入和删除操作时，需要移动大量元素</p><h3 id="2）静态分配"><a href="#2）静态分配" class="headerlink" title="2）静态分配"></a>2）静态分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的静态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的数组存放数据元素</span></span><br><span class="line"><span class="type">int</span> length;         <span class="comment">//顺序表的当前长度  </span></span><br><span class="line"></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">L.data[i] = <span class="number">0</span>;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置为i，元素值为e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="comment">//判断插入元素下边是否越界</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L.length &gt; MaxSize)<span class="comment">//判断顺序表元素是否满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;  <span class="comment">//将第i各元素及之后的元素后移</span></span><br><span class="line">L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i - <span class="number">1</span>] = e;<span class="comment">//在位置i插入e</span></span><br><span class="line">L.length++;<span class="comment">//长度加1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入成功！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第i个元素 并返回删除的元素值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span> </span>&#123;  <span class="comment">//&amp;e引用型参数 将删除的元素返回</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>) <span class="comment">//判断插入元素下边是否越界</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e = L.data[i<span class="number">-1</span>];<span class="comment">//下标=个数-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;L.length; j++) &#123;</span><br><span class="line">L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.length--; <span class="comment">//长度减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">VolueGetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateGetElem</span><span class="params">(SqList L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出操作</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">disp</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:data:%d,length:%d\n&quot;</span>, i, L.data[i], L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）动态分配"><a href="#3）动态分配" class="headerlink" title="3）动态分配"></a>3）动态分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的动态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span>* data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前容量</span></span><br><span class="line"></span><br><span class="line">&#125;SqList; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="comment">//malloc申请一片连续的空间</span></span><br><span class="line">L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(InitSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加表的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SqList&amp; L, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* p = L.data;</span><br><span class="line">L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.MaxSize + len) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">L.data[i] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize = L.MaxSize + len;</span><br><span class="line"><span class="comment">//free释放旧的内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、线性表的链式表示"><a href="#3、线性表的链式表示" class="headerlink" title="3、线性表的链式表示"></a>3、线性表的链式表示</h2><h3 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h3><p>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素，对每个链表节点，除了存放数据元素本身外，还需要存放下一个指向后继的指针。</p><p>优点：解决顺序表需要大量连续地址的缺点</p><p>缺点：存储密度低，差找元素需要从头开始遍历</p><h3 id="2）单链表"><a href="#2）单链表" class="headerlink" title="2）单链表"></a>2）单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;<span class="comment">//定义单表表的节点类型</span></span><br><span class="line"><span class="type">int</span> data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> *next;<span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode,*LinkList;   </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表  不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList1</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">L = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表    带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList2</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//分配一个头节点</span></span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//内存不住，分配失败</span></span><br><span class="line">L-&gt;next == <span class="literal">NULL</span>;                <span class="comment">//头节点之后暂无节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//判断插入下标</span></span><br><span class="line"></span><br><span class="line">LNode *p;<span class="comment">//定义一个指针p  指向当前扫描到的节点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//定义一个数值j，当前指向的是第几个节点</span></span><br><span class="line">p = L; <span class="comment">//L指向头节点，头节点是第0个节点</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;<span class="comment">//循环找到第i-1个节点</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//第i个位置的节点指针不存在，即i值越界</span></span><br><span class="line">LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入成功第%d个节点的值为%d\n&quot;</span>,i,e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作：在p节点后插入元素e</span></span><br><span class="line"><span class="comment">//LNode *P=LinkList</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode* p, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插入操作，在p节点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">InsertProNode</span><span class="params">(LNode* p, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">s-&gt;data = p-&gt;data;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位序删除第i个节点，并返回其值e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* p;<span class="comment">//定义一个指针p  指向当前扫描到的节点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//定义一个数值j，当前指向的是第几个节点</span></span><br><span class="line">p = L; <span class="comment">//L指向头节点，头节点是第0个节点</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;<span class="comment">//循环找到第i-1个节点</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)     <span class="comment">//i下标越界</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//i-1个节点后无节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode *q = p-&gt;next;  <span class="comment">//暂存删除的节点</span></span><br><span class="line">e = q-&gt;data;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定节点删除   类似前插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DleleteNode</span><span class="params">(LNode* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* q = p-&gt;next; <span class="comment">//暂存删除的节点</span></span><br><span class="line"><span class="comment">//如果删除的节点是最后一个节点呢？，无后继节点则出现bug</span></span><br><span class="line">p-&gt;data = p-&gt;next-&gt;data;  <span class="comment">//和后继节点交换数据域</span></span><br><span class="line">p-&gt;next = q-&gt;next;        <span class="comment">//将q节点断开</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找  找到第i个节点的值</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateGetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">LNode* p;<span class="comment">//定义一个指针p  指向当前扫描到的节点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//定义一个数值j，当前指向的是第几个节点</span></span><br><span class="line">p = L; <span class="comment">//L指向头节点，头节点是第0个节点</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i ) &#123;<span class="comment">//循环找到第i个节点</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找  找到值为e的节点</span></span><br><span class="line"><span class="function">LNode* <span class="title">ValueGetELem</span><span class="params">(LinkList L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">LNode* p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;  <span class="comment">//找到返回节点 未找到返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求链表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LengthList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">L = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (L!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">L = L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法 建立单链表</span></span><br><span class="line"><span class="comment">//step1：初始化一个单链表，带头节点</span></span><br><span class="line"><span class="comment">//step2：每次取一个数据元素，插入到表尾</span></span><br><span class="line"><span class="function">LinkList <span class="title">TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">1</span>;</span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建头节点</span></span><br><span class="line">LNode* s, * r = L;</span><br><span class="line"><span class="built_in">printf_s</span>(<span class="string">&quot;请输入第%d个节点的值&quot;</span>,y);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (x!=<span class="number">9999</span>) <span class="comment">//输入9999结束</span></span><br><span class="line">&#123;</span><br><span class="line">s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = s;</span><br><span class="line">y++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入第%d个节点的值&quot;</span>, y);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">LNode* s;</span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建头节点</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化为空</span></span><br><span class="line"><span class="built_in">printf_s</span>(<span class="string">&quot;请输入倒数第%d个节点的值&quot;</span>, y);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">9999</span>) <span class="comment">//输入9999结束</span></span><br><span class="line">&#123;</span><br><span class="line">s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line">y++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入第%d个节点的值&quot;</span>, y);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历单链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(LinkList &amp;L)</span> </span>&#123; </span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">L = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(L != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第%d个值为：%d\n&quot;</span>, i, L-&gt;data);</span><br><span class="line">L = L-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）双链表"><a href="#3）双链表" class="headerlink" title="3）双链表"></a>3）双链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义双链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;<span class="comment">//定义单表表的节点类型</span></span><br><span class="line"><span class="type">int</span> data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span> *next,*prior;<span class="comment">//前驱和后继节点</span></span><br><span class="line">&#125;DNode, * DLinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">InitDlinkList</span><span class="params">(DLinkList&amp; L)</span> </span>&#123;</span><br><span class="line">L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode)); <span class="comment">//分配头节点</span></span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s-&gt;next = p-&gt;next;     </span><br><span class="line"><span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)     <span class="comment">//判断是否是最后一个元素</span></span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p系欸但那的后继节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">DNode* q = p-&gt;next;  <span class="comment">//找到p节点的后继节点 赋值给q</span></span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>)   <span class="comment">//p节点无后继节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)  <span class="comment">//q节点不是最后一个节点</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryList</span><span class="params">(DLinkList&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (L-&gt;next= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">DeleteNextDNode</span>(L);  <span class="comment">//删除后继节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(L); <span class="comment">//释放L    </span></span><br><span class="line">L = <span class="literal">NULL</span>;  <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表的遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">L = L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前向遍历</span></span><br><span class="line"><span class="keyword">while</span> (L!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">L = L-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第七章:I/O系统</title>
    <link href="https://wjjhui.github.io/2022/05/27/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9AIO%E7%B3%BB%E7%BB%9F/"/>
    <id>https://wjjhui.github.io/2022/05/27/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9AIO%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-27T10:46:33.000Z</published>
    <updated>2022-06-18T06:55:32.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-I-x2F-O系统的基本概念"><a href="#7-1-I-x2F-O系统的基本概念" class="headerlink" title="7.1 I&#x2F;O系统的基本概念"></a>7.1 I&#x2F;O系统的基本概念</h2><h3 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h3><p>外部设备：包括输入&#x2F;输出设备以及通过输入&#x2F;输出结课才能访问的外存储设备</p><p>接口：在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件</p><p>输入设备：用于向计算机系统输入命令和文本、数据等信息的部件</p><p>输出设备：用于将计算机系统中的信息输出到计算机外部进行显示的部件</p><p>外存设备：除计算机内存及CPU缓存等外的存储器</p><p>I&#x2F;O软件：驱动程序、用户程序、管理程序、升级补丁。通常采用I&#x2F;O指令和通道指令实现CPU与I&#x2F;O设备的交互</p><p>I&#x2F;O硬件：包括外部设备、设备控制器和接口、I&#x2F;O总线等</p><h3 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><p>程序查询方式：CPU通过程序查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备进行主机交换信息</p><p>程序中断方式：只在I&#x2F;O设备准备就绪并向CPU发出中断请求时才予响应</p><p>DMA方式：主存和I&#x2F;O设备之间有一条直接数据通路，当主存和I&#x2F;O设备交换信息时无须调用中断服务程序</p><p>通道方式：在系统中设有通道控制部件，每个通道挂接若干外设，主机在执行I&#x2F;O指令时，只需要启动有关通道。通道执行通道程序完成I&#x2F;O设备</p><h2 id="7-2-外部设备"><a href="#7-2-外部设备" class="headerlink" title="7.2 外部设备"></a>7.2 外部设备</h2><h3 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h3><p>键盘：1）查出按下的是哪个键位，2）将该键翻译成能被主机接收的键码，3）将编码发给主机</p><p>鼠标：鼠标在平面上移动，底部传感器将移动距离与方向检测出来，从而控制光标的移动</p><h3 id="输出设备-1"><a href="#输出设备-1" class="headerlink" title="输出设备"></a>输出设备</h3><h4 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h4><p>屏幕大小：对角长度</p><p>分辨率：所能显示的像素个数，宽与高的乘积</p><p>灰度级：黑白显示器中所显示的像素点的亮暗差别，彩色显示器的中颜色不同。如RGB</p><p>刷新：光点只能褒词极短的时间就会消失，必须在其消失前重新扫描一遍</p><p>刷新频率：单位时间内扫描整个屏幕内容的次数，刷新频率大于30HZ时人眼无法分辨除刷新。</p><p>显示存储器（VRAM）：也称为出阿信存储器，将一帧的图像存储在刷新存储器中，从而提高刷新图像的信号</p><h4 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h4><h5 id="针式打印机"><a href="#针式打印机" class="headerlink" title="针式打印机"></a>针式打印机</h5><p>#原理：主机发出打印命令，经过接口、检测和控制电路、间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带打印内容。</p><p>#优点：擅长多层复习打印，实现各种票据和蜡纸等打印，工作原理简单，造假低廉，耗材便宜</p><p>#缺点：打印分辨率和打印速度不够高</p><h5 id="喷墨式打印机"><a href="#喷墨式打印机" class="headerlink" title="喷墨式打印机"></a>喷墨式打印机</h5><p>#原理：带点的喷墨雾点经过电极偏转后，直接在之上形成所需要的字形</p><p>#优点：打印噪声小，实现高质量彩色打印，打印速度比针式打印机快</p><p>#缺点：防水性、打印成本高、需要专用打印纸</p><h5 id="激光打印机"><a href="#激光打印机" class="headerlink" title="激光打印机"></a>激光打印机</h5><p>#原理：计算机输出二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，经过显影、转印和定影，在纸上得到所需的字符或图像</p><p>#优点：打印质量高，速度快，噪音小，处理能力强</p><p>#缺点：耗材多、价格贵、不能复写打印多份、对纸张要求高</p><h3 id="磁表面存储器"><a href="#磁表面存储器" class="headerlink" title="磁表面存储器"></a>磁表面存储器</h3><p>优点：纯储容量大，价格低，非破坏性读出，记录信息可以长久保存</p><p>缺点：存取速度慢、机械机构复杂、对工作环境要求高</p><p>磁盘存储器</p><p>组成</p><p>#磁头：用于读&#x2F;写盘片上的记录面信息，一个记录面对应一个磁头</p><p>#柱面数：表示硬盘每个盘片上有多少磁盘</p><p>#扇区数：表示每条磁道有多少哥扇区</p><p>#磁盘驱动器：核心部件是磁头组件和盘片组件</p><p>#磁盘控制器：硬盘存储器和主机的接口</p><p>磁盘地址</p><p>#柱面号、盘面号、扇区号</p><p>硬盘工作过程</p><p>#寻址、读盘、写盘</p><p>#第一步是取控制字、第二部是执行控制字</p><p>#读写操作是串行的，不能既读又写</p><h2 id="7-3-I-x2F-O接口"><a href="#7-3-I-x2F-O接口" class="headerlink" title="7.3 I&#x2F;O接口"></a>7.3 I&#x2F;O接口</h2><h3 id="I-x2F-O接口功能"><a href="#I-x2F-O接口功能" class="headerlink" title="I&#x2F;O接口功能"></a>I&#x2F;O接口功能</h3><p>1）实现主机和外设之间的通信联络控制</p><p>2）进行地址译码和设备选择</p><p>3）实现数据的缓冲，相处CPU和外设之间的速度差异</p><p>4）信号格式转换：实现消除主机与外设之间的电平、数据格式等差异</p><p>5）传送控制命令和状态信息：协调外设的运作状态</p><h3 id="I-x2F-O接口的基本结构"><a href="#I-x2F-O接口的基本结构" class="headerlink" title="I&#x2F;O接口的基本结构"></a>I&#x2F;O接口的基本结构</h3><p>内部接口：内部接口与系统总线相连。数据传输方式只能是并行传输</p><p>外部接口：外部接口通过接口电缆和外设相连。外部接口可能串行结构，所以I&#x2F;O接口要有串&#x2F;并转换功能</p><h3 id="I-x2F-O接口类型"><a href="#I-x2F-O接口类型" class="headerlink" title="I&#x2F;O接口类型"></a>I&#x2F;O接口类型</h3><h4 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h4><p>并行接口：一个字节或一个字的所有位同时传送</p><p>串行接口：一位一位的传输</p><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>程序查询接口</p><p>程序中断接口</p><p>DMA接口</p><h4 id="按照功能分类"><a href="#按照功能分类" class="headerlink" title="按照功能分类"></a>按照功能分类</h4><p>可编程接口</p><p>不可编程接口</p><h3 id="I-x2F-O端口及其编址"><a href="#I-x2F-O端口及其编址" class="headerlink" title="I&#x2F;O端口及其编址"></a>I&#x2F;O端口及其编址</h3><h4 id="统一编址"><a href="#统一编址" class="headerlink" title="统一编址"></a>统一编址</h4><p>将I&#x2F;O端口当作存储器单元进行地址分配</p><p>优点：不需要设置专门输入输出指令，CPU访问存储器更灵活，端口编址空间较大</p><p>缺点：端口占用存储器地址，数据输入输出的适合，执行速度较慢</p><h4 id="独立编址"><a href="#独立编址" class="headerlink" title="独立编址"></a>独立编址</h4><p>I&#x2F;O地址与存储器地址无关</p><p>优点：程序编址清晰，便于理解</p><p>缺点：需要设置专门的输入&#x2F;输出指令，增加了控制的复杂性</p><h2 id="7-4-I-x2F-O方式"><a href="#7-4-I-x2F-O方式" class="headerlink" title="7.4 I&#x2F;O方式"></a>7.4 I&#x2F;O方式</h2><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p>原理：信息交换完全交给主机执行程序实现，主机对设备的状态进行询问吗，然后根据结构决定下一步是传输数据还是等待。</p><p>优点：设计简单且设备量小</p><p>缺点：CPU需要花费大量时间进行查询和等待，一段时间内只能和一台外设交互信息，效率低</p><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><h4 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h4><h5 id="内-x2F-外中断"><a href="#内-x2F-外中断" class="headerlink" title="内&#x2F;外中断"></a>内&#x2F;外中断</h5><p>#内中断：内中断是指在处理器和内存内部产生的中断，包括程序运算引起的各种错误。如地址非法、校验错等</p><p>#外中断：外中断是指来处理器和内存外的部件引起的中断，包括I&#x2F;O设备发出的I&#x2F;O中断等</p><h5 id="硬件中断-x2F-软件中断"><a href="#硬件中断-x2F-软件中断" class="headerlink" title="硬件中断&#x2F;软件中断"></a>硬件中断&#x2F;软件中断</h5><p>#硬件中断：通过外部的硬件产生的中断，硬件中断属于外中断</p><p>#软件中断：通过某条指令产生的中断，这种中断是可以编程实现，软件中断是内终端</p><h5 id="非屏蔽和可屏蔽中断"><a href="#非屏蔽和可屏蔽中断" class="headerlink" title="非屏蔽和可屏蔽中断"></a>非屏蔽和可屏蔽中断</h5><p>#非屏蔽中断：非屏蔽中断是一种硬件中断，不受中断位IF的影响，即使处在关中断的情况下也会被响应</p><p>#可屏蔽中断：可屏蔽中断也是一种硬件中断，收中断位IF的影响，关中断时不可被响应</p><h4 id="中断判优"><a href="#中断判优" class="headerlink" title="中断判优"></a>中断判优</h4><p>通过中断判优逻辑确定响应那个中断源的请求</p><p>硬件实现：硬件实现是通过硬件排队器实现的，它既可以设置在CPU中，也可以分散在中断源中</p><p>软件实现：软件实现是通过查询程序实现的</p><p>一般逻辑</p><p>#硬件故障中断属于最高级</p><p>#非屏蔽中断优于可屏蔽中断</p><p>DMA请求优于I&#x2F;O设备传输</p><p>#高速设备优于低速设备</p><p>#输入设备优于输出设备</p><p>#实时设备优于普通设备</p><h4 id="CPU响应中断条件"><a href="#CPU响应中断条件" class="headerlink" title="CPU响应中断条件"></a>CPU响应中断条件</h4><p>中断源有中断请求</p><p>CPU允许中断及开中断</p><p>一条执行完毕，且没有更紧迫的任务</p><h4 id="中断响应过程"><a href="#中断响应过程" class="headerlink" title="中断响应过程"></a>中断响应过程</h4><p>1）关中断</p><p>2）保存断电</p><p>3）引出中断服务程序</p><p>4）保存现场和屏蔽字</p><p>5）开中断</p><p>6）执行中断服务程序</p><p>7）关中断</p><p>8）恢复现场和屏蔽字</p><p>9）开中断、中断返回</p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1）DMA方式是一种完全由硬件进行成组的信息传送的控制方式，DMA方式在外设与内存之间开辟一条”直接数据通路”</p><p>2）适用于磁盘机，磁带机等高速设备</p><p>3）硬件开销大</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1）它使主存与CPU的固定联系脱钩，主存既可以被CPU访问又可以被DMA控制器访问</p><p>2）在数据块传送时，主存地址的确定，传送数据的计数等都由硬件电路直接实现</p><p>3）主存中要开启专用缓冲区，及时供给和接受外设的数据</p><p>4）DMA传送速度快，CPU和外设并行工作，提高了工作效率</p><p>5）DMA在传送开始前要通过程序进行预处理，结束后要通过程序中断方式进行后处理</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>1）主存地址计数器：存放要交换数据的主存地址</p><p>2）传送长度计数器：记录要传送数据的长度，计数溢出时，数据传送完毕，自动发出中断请求信号</p><p>3）数据缓冲寄存器：暂存每次传送的数据</p><p>4）DMA请求触发器：I.O发出控制信号，使得DMA请求触发置位</p><p>5）”控制&#x2F;状态”逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步</p><p>6）中断机构：当一个数据块传送完毕后触发中断机构，向CPU提出中断请求</p><h4 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h4><p>1）停止CPU访问主存：CPU放弃对地址线、数据线和有关控制线的使用权，DMA接口获得总线控制权</p><p>2）DMA与CPU交替访存:适用于CPU的工作周期比主存存取周期长的情况，CPU与DMA接口交替获得总线控制权</p><p>3）周期挪用：在交替访问的基础上，当DMA接口空闲时，CPU获得总线控制权</p><h4 id="传送过程"><a href="#传送过程" class="headerlink" title="传送过程"></a>传送过程</h4><p>1）预处理：由CPU完成一些必要的工作（寄存器置初值、设置传送方向、启动改设备）</p><p>2）数据传送：DMA的数据传输可以以单字节或数据块为基本单位，完全由DMA控制</p><p>3）后处理：DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理</p><h3 id="DMA方式和中断方式的区别"><a href="#DMA方式和中断方式的区别" class="headerlink" title="DMA方式和中断方式的区别"></a>DMA方式和中断方式的区别</h3><p>1）中断方式是程序的切换，需要保护和恢复现场 ，DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源</p><p>2）中断请求的响应只能发生在每条指令执行完毕时，DMA请求的响应可以发生在每个机器周期结束时</p><p>3）中断传送过程需要CPU的干预，DMA传送过程由DMA完全控制</p><p>4）DMA请求的优先级高于中断请求</p><p>5）中断方式具有对异常事件的处理能力</p><p>6）DMA方式靠硬件传送</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9AIO%E7%B3%BB%E7%BB%9F.png" alt="第七章：IO系统"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第六章:总线</title>
    <link href="https://wjjhui.github.io/2022/05/23/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%80%BB%E7%BA%BF/"/>
    <id>https://wjjhui.github.io/2022/05/23/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%80%BB%E7%BA%BF/</id>
    <published>2022-05-23T14:16:08.000Z</published>
    <updated>2022-05-23T14:24:27.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-总线的概述"><a href="#6-1-总线的概述" class="headerlink" title="6.1 总线的概述"></a>6.1 总线的概述</h2><h3 id="6-1-1-总线的基本概念"><a href="#6-1-1-总线的基本概念" class="headerlink" title="6.1.1 总线的基本概念"></a>6.1.1 总线的基本概念</h3><h4 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h4><p>总线是一组能为多个部件分时共享的公共信息传送线路</p><p>分时：同一时刻只允许有一个部件向总线发送信息</p><p>共享：总线上可以挂接多个部件，各个部件互相交换的信息可以通过这组线路分时共享</p><h4 id="总线设备"><a href="#总线设备" class="headerlink" title="总线设备"></a>总线设备</h4><p>主设备：总线的主设备是指获得总线控制权的设备</p><p>从设备：总线的从设备是指被主设备访问的设备</p><h4 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h4><p>机械特性：尺寸，形状</p><p>电器特性：传输方向和有效的电平范围</p><p>功能特性：每根传输的功能</p><p>时间特性：信号和时序的关系</p><h4 id="总线的猝发传输"><a href="#总线的猝发传输" class="headerlink" title="总线的猝发传输"></a>总线的猝发传输</h4><p>一个总线周期内存储地址连续的多个数据字的总线传输方式</p><h3 id="6-1-2-总线的分类"><a href="#6-1-2-总线的分类" class="headerlink" title="6.1.2 总线的分类"></a>6.1.2 总线的分类</h3><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p>芯片内部的总线，是CPU芯片内部寄存器和寄存器之间，寄存器于ALU之间的公共连接线</p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>1、传输个功能部件之间的数据信息</p><p>2、双向传输总线</p><p>3、位数于机器字长、存储字长有关</p><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>1、数据总线上的源数据或目的数据所在的主存单元或I&#x2F;O端口的地址</p><p>2、单向传输总线</p><p>3、地址总线的位数于主存地址空间的大小有关</p><h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>传输控制信息，CPU送出的控制命令和主存返回CPU的反馈信号</p><h3 id="6-1-3-系统总线的结构"><a href="#6-1-3-系统总线的结构" class="headerlink" title="6.1.3 系统总线的结构"></a>6.1.3 系统总线的结构</h3><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>1、将CPU、主存、I&#x2F;O设备都挂载到一组总线上</p><p>2、优点：结构简单。成本低，容易接入新设备</p><p>3、缺点：带宽低，负载重，多个部件只能争用唯一饿总线，并且不支持并传送操作</p><h4 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h4><p>1、一条主存总线，用于CPU，主存和通道之间传送数据，另一条是I&#x2F;O总线用于在多个外部设备和通道之间传输数据</p><p>2、优点：将低速I&#x2F;O设备从单总线上分离出来，实现了存储总线和I&#x2F;O总线分离</p><p>3、缺点：需要增加通道等硬件设备</p><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p>1、计算机系统个部件之间采用三条独立总线来构成信息通路（主存总线，I&#x2F;O总线，DMA总线）</p><p>2、优点：提高了I&#x2F;O设备的性能，使其更快的响应命令，提高系统的吞吐量</p><p>3、缺点：系统工作效率较低</p><h3 id="6-1-4-总线的性能指标"><a href="#6-1-4-总线的性能指标" class="headerlink" title="6.1.4 总线的性能指标"></a>6.1.4 总线的性能指标</h3><p>1、总线的传输周期：一次总线操作所需要的时间，总线传输周期由若干个总线时钟周期构成</p><p>2、总线时钟周期：即机器的时钟周期</p><p>3、总线的工作频率：总线周期的倒数</p><p>4、总线的时钟频率：时钟周期的倒数</p><p>5、总线带宽：&#x3D; 总线工作频率 × 总线宽度 （bit&#x2F;s）&#x3D; 总线工作频率 × (总线宽度&#x2F;8) （B&#x2F;s）</p><p>6、总线复用：一种信号线在不同时间传输不同的信息，节约了空间和成本</p><p>7、信号线数：地址总线，数据总线，控制总线</p><h2 id="6-2总线仲裁"><a href="#6-2总线仲裁" class="headerlink" title="6.2总线仲裁"></a>6.2总线仲裁</h2><h3 id="6-2-1-集中仲裁方式"><a href="#6-2-1-集中仲裁方式" class="headerlink" title="6.2.1 集中仲裁方式"></a>6.2.1 集中仲裁方式</h3><h4 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h4><p>1、一根总线请求线，一根总线忙线，一根总线允许线</p><p>2、优点：优先级固定，结构简单，扩充容易</p><p>3、缺点：对于电路故障敏感，优先级不变</p><h4 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h4><p>1、使用计数器控制总线优先权</p><p>2、优点：设备优先级相等，优先次序可以改变</p><p>3、缺点：增加了控制线数- 若设备有n个，则需log2n +2条控制线</p><h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><p>1、每个设备均有请求线于总线允许线</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81-16533157997361.png" alt="总线仲裁"></p><h3 id="6-2-2-分布总裁方式"><a href="#6-2-2-分布总裁方式" class="headerlink" title="6.2.2 分布总裁方式"></a>6.2.2 分布总裁方式</h3><p>不需要中央仲裁器，每个潜在主模块，都有自己的仲裁号和仲裁器，然后进行仲裁号比较，获胜者仲裁号保留在仲裁总线上</p><h2 id="6-3总线操作与定时"><a href="#6-3总线操作与定时" class="headerlink" title="6.3总线操作与定时"></a>6.3总线操作与定时</h2><h3 id="总线传输的五个阶段"><a href="#总线传输的五个阶段" class="headerlink" title="总线传输的五个阶段"></a>总线传输的五个阶段</h3><p>1、请求阶段：主设备发出总线传输请求，并且获得总线控制权</p><p>2、仲裁阶段：总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者</p><p>3、寻址阶段：主设备通过总线给出要访问的从设备地址及有关命令，启动从模块</p><p>4、传输结构：主模块和从模块进行数据交换，可单向或双向进行数据传送</p><p>5、释放阶段：主模块的有关信息均从系统总线上撤除，让出总线控制权</p><h3 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h3><p>1、系统采用统一的时钟信号来协调发送和接收方的传送定时关系</p><p>2、优点：传送速度块，拥有较高的传输速率，总线控制逻辑简单</p><p>3、缺点：主设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差</p><h3 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h3><p>1、没有统一的时钟，完全按照传送双方相互制约的握手信号实现定时控制</p><p>2、优点：总线周期长度可变，可以保证两个速度相差较大部件或设备的信息传输</p><p>3、缺点：控制相对复杂，并且速度相对较慢</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%88%86%E7%B1%BB.png" alt="分类"></h4><h2 id="6-4总线标准"><a href="#6-4总线标准" class="headerlink" title="6.4总线标准"></a>6.4总线标准</h2><h3 id="常见总线标准"><a href="#常见总线标准" class="headerlink" title="常见总线标准"></a>常见总线标准</h3><p>系统总线：ISA、EISA</p><p>局部总线：VESA、PCI、PCI-Express、AGP</p><p>设备总线：RS-232C、USB</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%80%BB%E7%BA%BF.png" alt="第六章：总线"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第四章:指令系统</title>
    <link href="https://wjjhui.github.io/2022/05/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://wjjhui.github.io/2022/05/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-16T13:24:52.000Z</published>
    <updated>2022-05-23T14:31:05.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1指令格式"><a href="#4-1指令格式" class="headerlink" title="4.1指令格式"></a>4.1指令格式</h2><h3 id="4-1-1-指令的基本格式-（操作码-地址码）"><a href="#4-1-1-指令的基本格式-（操作码-地址码）" class="headerlink" title="4.1.1 指令的基本格式 （操作码+地址码）"></a>4.1.1 指令的基本格式 （操作码+地址码）</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>操作码：指出指令中应该执行什么性质的操作和具有何种功能</p><p>地址码：给出被操作的信息的地址</p><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>单字长指令：长度等于机器字长</p><p>双字长指令：长度等于两倍机器字长</p><p>半字长指令：长度等于半个机器字长</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h5><p>OP</p><p>1）不需要操作数的指令，如空指令、停机指令、关中断指令</p><p>2）仅使用在堆栈计算机中</p><h5 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h5><p>OP A1</p><p>1）只有目的操作数的单操作数指令，按照A1地址读取操作数后进行OP操作，结果存回原地址</p><p>2）隐含约定目的地址的双操作数指令</p><h5 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h5><p>OP A1 A2</p><p>1）算术和逻辑运算指令</p><p>2）两个操作数，目的操作数和源操作数，结果返回到目的操作数</p><h5 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h5><p>OP A1 A2 A3</p><p>1）算术和逻辑运算指令</p><p>2）目的操作数、源操作数、结果操作数</p><h5 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h5><p>OP A1 A2 A3 A4</p><p>1）算术和逻辑运算指令</p><p>2）目的操作数、源操作数、结果操作数、下地址</p><h3 id="4-1-2-定长操作码指令格式"><a href="#4-1-2-定长操作码指令格式" class="headerlink" title="4.1.2 定长操作码指令格式"></a>4.1.2 定长操作码指令格式</h3><p>优点：定长操作码对于简化计算机硬件设计，提高指令移码和识别速度很有利</p><p>缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限</p><h3 id="4-1-3-扩展操作码指令格式"><a href="#4-1-3-扩展操作码指令格式" class="headerlink" title="4.1.3 扩展操作码指令格式"></a>4.1.3 扩展操作码指令格式</h3><p>实现：全部指令的操作码字段位数不固定，分散在指令字的不同位置上</p><p>优点：丰富了指令的种类</p><p>缺点：增加了 指令译码和分析难度，控制器设计变的复杂</p><h2 id="4-2指令的寻址方式"><a href="#4-2指令的寻址方式" class="headerlink" title="4.2指令的寻址方式"></a>4.2指令的寻址方式</h2><h3 id="4-2-1-指令寻址"><a href="#4-2-1-指令寻址" class="headerlink" title="4.2.1 指令寻址"></a>4.2.1 指令寻址</h3><p>1）顺序寻址：通过PC+”1”自动形成下一条指令的地址，单字长指令+1，双字长指令+2</p><p>2）跳跃寻址：本条指令给出下一条指令的地址</p><h3 id="4-2-2数据寻址"><a href="#4-2-2数据寻址" class="headerlink" title="4.2.2数据寻址"></a>4.2.2数据寻址</h3><h4 id="1）隐含寻址"><a href="#1）隐含寻址" class="headerlink" title="1）隐含寻址"></a>1）隐含寻址</h4><p>不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址 。</p><p>优点：有利于缩短指令字长</p><p>缺点：需增加存储操作数或隐含地址的硬件</p><h4 id="2）立即寻址"><a href="#2）立即寻址" class="headerlink" title="2）立即寻址"></a>2）立即寻址</h4><p>形式地址A就是操作数本身，又称为立即数，一般采用补码形式。 #表示立即寻址特征。</p><p>优点：指令执行阶段不访问主存，指令执行时间最短</p><p>缺点：A的位数限制了立即数的范围。数据范围为−2^n～(2^n) − 1</p><h4 id="3）直接寻址"><a href="#3）直接寻址" class="headerlink" title="3）直接寻址"></a>3）直接寻址</h4><p>指令字中的形式地址A就是操作数的真实地址EA，即EA&#x3D;A</p><p>优点：：简单，指令执行阶段仅访问一次主存， 不需专门计算操作数的地址。</p><p>缺点：A的位数决定了该指令操作数的寻址范围。 操作数的地址不易修改。</p><h4 id="4）间接寻址"><a href="#4）间接寻址" class="headerlink" title="4）间接寻址"></a>4）间接寻址</h4><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址 所在的存储单元的地址，也就是操作数地址的地址，即EA&#x3D;(A) 。</p><p>优点：可扩大寻址范围，方便编址程序</p><p>缺点：指令在执行阶段要多次访存</p><h4 id="5）寄存器寻址"><a href="#5）寄存器寻址" class="headerlink" title="5）寄存器寻址"></a>5）寄存器寻址</h4><p>在指令字中直接给出操作数所在的寄存器编号，即EA &#x3D;Ri，其操作数在由Ri所 指的寄存器内。</p><p>优点：指令在执行阶段不访问主存，只访问寄存器， 指令字短且执行速度快，支持向量&#x2F;矩阵运算。</p><p>缺点：寄存器价格昂贵，计算机中寄存器个数有限 。</p><h4 id="6）寄存器间接寻址"><a href="#6）寄存器间接寻址" class="headerlink" title="6）寄存器间接寻址"></a>6）寄存器间接寻址</h4><p>寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址， 即EA&#x3D;(Ri) 。</p><p>特点：与一般间接寻址相比速度更快，但指令的执 行阶段需要访问主存(因为操作数在主存中)。</p><h4 id="7）相对寻址"><a href="#7）相对寻址" class="headerlink" title="7）相对寻址"></a>7）相对寻址</h4><p>把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址， 即EA&#x3D;(PC)+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示 。</p><p>在PC+1的基础上进行一定的位移</p><h4 id="8）基址寻址"><a href="#8）基址寻址" class="headerlink" title="8）基址寻址"></a>8）基址寻址</h4><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A， 而形成操作数的有效地址，即EA&#x3D;(BR)+A。</p><p>优点：便于程序”浮动”，方便实现多道程序并发运行</p><p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。</p><h4 id="9）变址寻址"><a href="#9）变址寻址" class="headerlink" title="9）变址寻址"></a>9）变址寻址</h4><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和， 即EA&#x3D; (IX)+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。</p><p>优点：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便 可很容易形成数组中任一数据的地址，特别适合编制循环程序。</p><p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变 （IX作为偏移量），形式地址A不变（作为基地址）</p><h4 id="10）堆栈寻址"><a href="#10）堆栈寻址" class="headerlink" title="10）堆栈寻址"></a>10）堆栈寻址</h4><p>操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按”后进先出（LIFO）” 原则管理的存储区，该存储区中被读&#x2F;写单元的地址是用一个特定的寄存 器给出的，该寄存器称为堆栈指针（SP）</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo@master/img/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="寻址方式"></p><h2 id="4-3-CISC和RISC"><a href="#4-3-CISC和RISC" class="headerlink" title="4.3 CISC和RISC"></a>4.3 CISC和RISC</h2><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo@master/img/CISC%E5%92%8CRISC.png" alt="CISC和RISC"></p><h2 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h2><h3 id="1、各常见指令寻址方式的特点和使用情况"><a href="#1、各常见指令寻址方式的特点和使用情况" class="headerlink" title="1、各常见指令寻址方式的特点和使用情况"></a>1、各常见指令寻址方式的特点和使用情况</h3><p>​        1）立即寻址操作数获取便捷，通常用于给寄存去赋初值</p><p>​        2）直接寻址相对于立即寻址，缩短了指令长度</p><p>​        3）间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回</p><p>​        4）寄存器寻址的指令字较短，指令执行速度较快</p><p>​        5）寄存器间接寻址扩大了寻址范围</p><p>​        6）基址寻址扩大了操作寻址范围，使用于多道程序设计，常用于为程序设计或数据分配存储空间</p><p>​        7）变址寻址主要用于处理数组问题，适合编制循环程序</p><p>​        8）相对寻址用于控制程序的执行顺序、转移等</p><p>​        9）基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址是动态的，基址寄存器的内容由操作系统控制固定不变的；在变址寻址中，程序员操作的是变址寄存器是动态的，偏移地址是固定不变的</p><h3 id="2、一个操作数在内存中可能占多个单元，怎么在指令中给出操作数的地址"><a href="#2、一个操作数在内存中可能占多个单元，怎么在指令中给出操作数的地址" class="headerlink" title="2、一个操作数在内存中可能占多个单元，怎么在指令中给出操作数的地址"></a>2、一个操作数在内存中可能占多个单元，怎么在指令中给出操作数的地址</h3><p>​        现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数可能是8位、16位、32位、64位。因此可能占用1个、2个、4个、8个内存单元。一个操作数可能有多个内存地址对应</p><p>​    大端方式：指令中给出的地址是操作数最高有效字节所在的地址</p><p>​    小端方式：指令中给出的地址是操作数最低有效字节所在的地址</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.png" alt="第四章：指令系统"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第三章:存储系统</title>
    <link href="https://wjjhui.github.io/2022/05/15/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>https://wjjhui.github.io/2022/05/15/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-15T13:24:52.000Z</published>
    <updated>2022-05-15T12:51:35.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟存储器和Cache"><a href="#虚拟存储器和Cache" class="headerlink" title="虚拟存储器和Cache"></a>虚拟存储器和Cache</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>1、目的都是为了提高系统性能</p><p>2、数据分为小信息块</p><p>3、都存在地址映射，替换算法，更新策略</p><p>4、按照局部性原理，讲活跃的数据放到高速部件中</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>1、Cache解决系统速度问题，虚拟存储器解决主存容量问题</p><p>2、Cache全部由硬件实现，是硬件存储器。虚拟存储器由OS和硬件共同实现，是逻辑上的存储器</p><p>3、Cache对程序员透明，虚拟存储器对应用程序员透明，对系统程序员不透明</p><p>4、虚拟存储器不命中对系统性能影响更大</p><p>5、CPU只能与Cache和主存直接交互，虚拟存储系统只能先将数据从硬盘调入主存，不能与CPU直接通信</p><h2 id="3-1存储器的层次结构"><a href="#3-1存储器的层次结构" class="headerlink" title="3.1存储器的层次结构"></a>3.1存储器的层次结构</h2><h3 id="3-1-1存储器的分类"><a href="#3-1-1存储器的分类" class="headerlink" title="3.1.1存储器的分类"></a>3.1.1存储器的分类</h3><h4 id="层次分类"><a href="#层次分类" class="headerlink" title="层次分类"></a>层次分类</h4><p>多级存储器结构</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="多级存储器结构"></p><p>主存</p><p>存放计算机运行时的程序与数据</p><p>可以被CPU直接访问，也可以与Cache和赋存进行交换数据</p><p>容量小、速度块、价格高</p><p>辅存</p><p>存储当前暂时不用的程序和数据，以及一些永久保留数据</p><p>不可以与CPU直接交换数据</p><p>容量大、速度慢、价格低</p><p>高速缓冲存储器</p><p>位于主存与辅存之间，缓解CPU与主存之间的速度差距问题</p><p> CPU可以直接访问</p><p>容量小、速度与CPU想匹配，价格高</p><h4 id="存储介质分类"><a href="#存储介质分类" class="headerlink" title="存储介质分类"></a>存储介质分类</h4><p>磁表面存储器：磁盘、磁带</p><p>磁芯存储器半导体存储器</p><p>光存储器：光盘</p><h4 id="存取方式分类"><a href="#存取方式分类" class="headerlink" title="存取方式分类"></a>存取方式分类</h4><p>随机存储器（RAM）</p><p>随机存取：读写方便、使用灵活</p><p>用途：主存、高速缓冲存储器</p><p>类型：静态SRAM（触发器原理），动态DRAM（电容原理）</p><p>只读存储器（ROM）</p><p>只能读出不能写入</p><p>用途：与随机存储器构成主存，存储固定不变的程序</p><p> ROM也派生出可以反复重写的类型</p><h4 id="信息可保存性"><a href="#信息可保存性" class="headerlink" title="信息可保存性"></a>信息可保存性</h4><p>易失性存储器</p><p> RAM,断电后信息丢失</p><p>非易失性存储器</p><p> ROM，断电后信息保持</p><h3 id="3-1-2存储器的性能指标"><a href="#3-1-2存储器的性能指标" class="headerlink" title="3.1.2存储器的性能指标"></a>3.1.2存储器的性能指标</h3><p>计算机追求目标：大容量、低成本、高速度</p><p>存储容量&#x3D;存储字数*字长</p><p>单位成本&#x3D;总成本&#x2F;容量</p><h2 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h2><h3 id="3-2-1-半导体存储芯片"><a href="#3-2-1-半导体存储芯片" class="headerlink" title="3.2.1 半导体存储芯片"></a>3.2.1 半导体存储芯片</h3><p>1、存储矩阵：大量相同点的为存储单元阵列构成</p><p>2、译码驱动：地址信号翻译成对应存储单元的选通信号</p><p>3、读写电路：完成读写操作</p><p>4、读&#x2F;写控制线：决定芯片读&#x2F;写</p><p>5、片选线：确定那个芯片被选中</p><p>6、地址线：单项输入、位数与存储字的个数有关</p><p>7、数据线：双向的，位数与读出或写入的数据位有关</p><p>8、存储器的读写周期</p><p>RAM读周期：存储芯片进行两次连续读操作时，必须间隔一定的时间，读周期总是大于等于读出时间</p><p>RAM写周期：数据总线上的信息能够可靠的写入存储器</p><h3 id="3-2-1-SRAM"><a href="#3-2-1-SRAM" class="headerlink" title="3.2.1 SRAM"></a>3.2.1 SRAM</h3><p>1、使用双稳态触发器记忆信息</p><p>2、非破坏性读出，易失性存储器</p><p>3、存取速度块、集成度低、功耗大、成本高、常用于高速缓冲存储器</p><p>4、同时送行列地址</p><h3 id="3-2-3-SDAM"><a href="#3-2-3-SDAM" class="headerlink" title="3.2.3 SDAM"></a>3.2.3 SDAM</h3><p>1、利用电容存储信息</p><p>2、破坏性读出，易失性存储器</p><p>3、存取速度慢、集成度高、功耗低、容量大、成本低、常用来组成主存</p><p>4、分两次送行列地址</p><p>5、刷新方法</p><p>刷新的单位是行</p><p>集中刷新：在一个周期利用一段固定的时间进行刷新操作，存在死区</p><p>分散刷新：把每行的刷新分散到各个工作周期中，存取周期变长</p><p>异步刷新：刷新周期除以行数得到t，没隔t时间就刷新一次</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%88%B7%E6%96%B0%E5%9B%BE%E8%A7%A3.png" alt="刷新图解"></p><h3 id="3-2-4-ROM"><a href="#3-2-4-ROM" class="headerlink" title="3.2.4 ROM"></a>3.2.4 ROM</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、随机存取、非易失性存储器</p><p>2、结构简单，位密度比可读写存储器高</p><h4 id="ROM类型"><a href="#ROM类型" class="headerlink" title="ROM类型"></a>ROM类型</h4><p>掩膜式只读存储器MROM</p><p>一次性可编程只读存储器PROM</p><p>紫外线擦除只读存储器EPROM</p><p>点擦除只读存储器EEPROM</p><h2 id="3-3主存储器和CPU的连接"><a href="#3-3主存储器和CPU的连接" class="headerlink" title="3.3主存储器和CPU的连接"></a>3.3主存储器和CPU的连接</h2><h3 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h3><p>主存储器与CPU连接（数据总线、地址总线、控制总线）</p><h3 id="主存容量的扩充"><a href="#主存容量的扩充" class="headerlink" title="主存容量的扩充"></a>主存容量的扩充</h3><p>位扩展</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="位扩展"></p><p>字扩展</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="字扩展"></p><p>字位扩展</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%AD%97%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="字位扩展"></p><h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><h4 id="选择合理的存储芯片"><a href="#选择合理的存储芯片" class="headerlink" title="选择合理的存储芯片"></a>选择合理的存储芯片</h4><p>RAM：为用户编程设置的</p><p>ROM：存放系统程序</p><h4 id="地址线的选择"><a href="#地址线的选择" class="headerlink" title="地址线的选择"></a>地址线的选择</h4><p>CPU地址线地位与存储芯片的地址线连接</p><p>CPU地址线高为用于扩充芯片使用</p><h4 id="数据线的连接"><a href="#数据线的连接" class="headerlink" title="数据线的连接"></a>数据线的连接</h4><p>CPU数据线与存储芯片线数相等时直接连接</p><p>CPU数据线与存储芯片数不等时：必须对存储芯片进行扩充</p><h4 id="读-x2F-写命令线的连接"><a href="#读-x2F-写命令线的连接" class="headerlink" title="读&#x2F;写命令线的连接"></a>读&#x2F;写命令线的连接</h4><p>可能是一根也可能是两根</p><p>片选线的选择</p><p>片选线的作用在于选择那一片存储芯片被选中</p><h2 id="3-4双端口RAM和多模块存储器"><a href="#3-4双端口RAM和多模块存储器" class="headerlink" title="3.4双端口RAM和多模块存储器"></a>3.4双端口RAM和多模块存储器</h2><h3 id="目的：为了提高CPU访问存储器的速度采用双端口存储器、多模块存储器"><a href="#目的：为了提高CPU访问存储器的速度采用双端口存储器、多模块存储器" class="headerlink" title="目的：为了提高CPU访问存储器的速度采用双端口存储器、多模块存储器"></a>目的：为了提高CPU访问存储器的速度采用双端口存储器、多模块存储器</h3><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p>一个存储器有左、右两个独立端口、分别具有两组相互独立的地址线、数据线、读写控制线</p><p>冲突</p><p>1、对同一个地址单元，两个端口同时写入数据</p><p>2、对于同一个地址单元，一个端口写、一个端口读</p><p>无冲突</p><p>1、对同一个地址单元，两个端口同时读</p><p>2、对于同一个地址单元，两个端口不同时写</p><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>目的：为了提高访问速度</p><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><p>按照地址顺序读出数据，存储单元存储m个字，总线宽度也为m个字，一次性并行读出m个字</p><p>有点：增大了存储器带宽，提高单体存储器工作速度</p><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><p>多个模块构成，每个模块有这相同的容量和存取速度，各模块即可并行工作又可以交叉工作</p><p>高为交叉地址：本质上仍然是顺序存储器</p><p>低位交叉编址：可以提高存储器的带宽</p><h2 id="3-5高速缓冲存储器"><a href="#3-5高速缓冲存储器" class="headerlink" title="3.5高速缓冲存储器"></a>3.5高速缓冲存储器</h2><h3 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h3><p>时间局部性：将要使用的信息，可能是现在正在使用的信息</p><p>空间局部性：将来要使用的信息，可能正在使用信息的存储空间的附近</p><h3 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h3><p>通常使用SRAM制作</p><p>存储主存中最为活跃的信息副本，按照某种策略将这些活跃的信息写入Cache中</p><p>CPU发出读请求，Cache命中直接对Cache进行操作，Cache未命中则访问主存操作并将访问数据送入Cache中</p><h4 id="Cache工作原理-1"><a href="#Cache工作原理-1" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h4><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/Cache%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="Cache工作原理"></p><h3 id="Cache与主存的映射方式"><a href="#Cache与主存的映射方式" class="headerlink" title="Cache与主存的映射方式"></a>Cache与主存的映射方式</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p>主存数据块只能装入Cache中的唯一位置</p><p>地址结构 ：主存字快标记 Cache行号 字块内地址</p><p>Cache行号&#x3D;主存块号 mod Cache总行数</p><h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p>主存数据块可以放在Cache中的任何位置</p><p>地址结构：主存块号 块内地址</p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p>将Cache分成Q大小相等的组，主存的数据块可以装入一组内的任何位置</p><p>地址结构：标记 Cache组号 块内地址</p><p>Cache组号&#x3D;主存块号 mod Cache组数</p><h3 id="Cache中的替换算法"><a href="#Cache中的替换算法" class="headerlink" title="Cache中的替换算法"></a>Cache中的替换算法</h3><h4 id="随机算法：随机替换Cache块"><a href="#随机算法：随机替换Cache块" class="headerlink" title="随机算法：随机替换Cache块"></a>随机算法：随机替换Cache块</h4><p>优点：实现简单</p><p>缺点：没有依据局部性原理，命中率低</p><h4 id="先进先出算法（FIFO）：最早调入的行进行替换"><a href="#先进先出算法（FIFO）：最早调入的行进行替换" class="headerlink" title="先进先出算法（FIFO）：最早调入的行进行替换"></a>先进先出算法（FIFO）：最早调入的行进行替换</h4><p>优点：容易实现</p><p>缺点：没有依据局部性原理</p><h4 id="近期最少使用算法（LRU）：根据局部性原理，选这近期内最久没有访问的存储行"><a href="#近期最少使用算法（LRU）：根据局部性原理，选这近期内最久没有访问的存储行" class="headerlink" title="近期最少使用算法（LRU）：根据局部性原理，选这近期内最久没有访问的存储行"></a>近期最少使用算法（LRU）：根据局部性原理，选这近期内最久没有访问的存储行</h4><p>优点：平均命中率高</p><p>缺点：需要设计计数器比较存储行</p><h4 id="最不经常使用算法：一段时间内访问次数最少的存储行换出"><a href="#最不经常使用算法：一段时间内访问次数最少的存储行换出" class="headerlink" title="最不经常使用算法：一段时间内访问次数最少的存储行换出"></a>最不经常使用算法：一段时间内访问次数最少的存储行换出</h4><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><p>全写法：对Cache命中后，数据同时写入Cache和主存</p><p>写回法：对Cache命中后时，只修改Cache内容，当Cache交换时才修改主存内容</p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><p>写分配法：加载主存中的块到Cache中，然后更新Cache块</p><p>非写分配法：只写入主存，不进行调块</p><h4 id="多级Cache：可以有效避免频繁写时造成的写缓冲和溢出"><a href="#多级Cache：可以有效避免频繁写时造成的写缓冲和溢出" class="headerlink" title="多级Cache：可以有效避免频繁写时造成的写缓冲和溢出"></a>多级Cache：可以有效避免频繁写时造成的写缓冲和溢出</h4><h2 id="3-6虚拟存储器"><a href="#3-6虚拟存储器" class="headerlink" title="3.6虚拟存储器"></a>3.6虚拟存储器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、将主存或者辅存的地址空间统一编址</p><p>2、实地址对应的是主存地址空间</p><p>3、使用虚拟地址需要辅助硬件找出虚地址和实地址之间的关系，并对其对应存储单元装入状态进行判断</p><p>4、实际情况：需要使用的先送入主存，暂时不用的放在磁盘中</p><h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><p>以页为基本单位的虚拟存储器称为页式虚拟存储器</p><p>计算过程</p><p>虚拟地址&#x3D;虚页号+页内地址</p><p>虚页号+页表起始地址&#x3D;页表地址</p><p>实页号+页内地址&#x3D;实地址</p><p>地址变换过程</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="页式地址变换过程"></p><h3 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h3><p>按照程序的逻辑结构划分</p><p>计算过程</p><p>虚地址&#x3D;段号+段内地址</p><p>段号+段表起始地址&#x3D;段表地址</p><p>实地址&#x3D;段表所得数据+段内地址</p><p>地址变换过程</p><p><img src="G:\Blog\MyBlog\source_posts\操作系统img\段式地址变换过程.png" alt="段式地址变换过程"></p><h3 id="段页式存储器"><a href="#段页式存储器" class="headerlink" title="段页式存储器"></a>段页式存储器</h3><p>先将程序按逻辑分段，再将每段分为固定大小页</p><p>段长必须是页的整数倍</p><p>虚地址&#x3D;段号+段内页号+页内地址</p><h3 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h3><p>根据局部性原理，将一些经常访问的页放入高速缓冲器中构成快表，可以极大的提高查询的效率</p><p>采用相联存储器的构成，可以按照内容查询</p><p>访问顺序：TLB–&gt;页表–&gt;Cache–&gt;主存</p><h4 id="命中情况"><a href="#命中情况" class="headerlink" title="命中情况"></a>命中情况</h4><p>Cache命中，page必然命中，TLB不一定命中</p><p>Cache不命中，无法判断TLB和page命中情况</p><p>page不命中，Cache和主存不会命中，此时要执行调页策略</p><h2 id="3-7注意！！"><a href="#3-7注意！！" class="headerlink" title="3.7注意！！"></a>3.7注意！！</h2><h3 id="1、存取时间Ta和存储周期Tm"><a href="#1、存取时间Ta和存储周期Tm" class="headerlink" title="1、存取时间Ta和存储周期Tm"></a>1、存取时间Ta和存储周期Tm</h3><p>​    存取时间Ta是执行一次读操作或写操作的时间，分为读出时间和写入时间。读出时间是从主存接收到有效地址开始到数据稳定为止的时间；写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间</p><p>​    存取周期Tm 是指存储器进行连续两次独立地读或写操作所需的最小时间间隔。所以Tm&gt;Ta</p><h3 id="2、Cache行的大小和命中率之间的关系"><a href="#2、Cache行的大小和命中率之间的关系" class="headerlink" title="2、Cache行的大小和命中率之间的关系"></a>2、Cache行的大小和命中率之间的关系</h3><p>​    行的长度较大，可以充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个</p><p>​        1）行长太大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块</p><p>​        2）行长太大，Cache项数变少，因而命中的可能性变小</p><h3 id="3、发生取指令Cache缺失的处理过程"><a href="#3、发生取指令Cache缺失的处理过程" class="headerlink" title="3、发生取指令Cache缺失的处理过程"></a>3、发生取指令Cache缺失的处理过程</h3><p>​        1）程序计数器恢复当前指令的指</p><p>​        2）对主存进行读的操作</p><p>​        3）将读入的指令写入Cache中，更改有效位和标记位</p><p>​        4）重新执行当前指令</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt="第三章：存储系统"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第二章:运算方法与运算器</title>
    <link href="https://wjjhui.github.io/2022/05/11/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8/"/>
    <id>https://wjjhui.github.io/2022/05/11/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8/</id>
    <published>2022-05-11T13:24:52.000Z</published>
    <updated>2022-05-15T10:43:50.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1定点数的表示"><a href="#2-1定点数的表示" class="headerlink" title="2.1定点数的表示"></a>2.1定点数的表示</h2><h3 id="有符号与无符号"><a href="#有符号与无符号" class="headerlink" title="有符号与无符号"></a>有符号与无符号</h3><p>无符号数：整个机器字长的全部二进制均为数值位</p><p>有符号数：最高位的0&#x2F;1表示正&#x2F;负</p><h3 id="机器数定点表示"><a href="#机器数定点表示" class="headerlink" title="机器数定点表示"></a>机器数定点表示</h3><p>定点小数：定点小数是纯小数，约定小数点位置在符号位之后</p><p>定点整数：定点整数是纯整数，小数点位置在有效数值部分的最低位后</p><h3 id="机器数表示方法"><a href="#机器数表示方法" class="headerlink" title="机器数表示方法"></a>机器数表示方法</h3><p>原码表示：最高位位符号位，其余的为数值位</p><p>反码表示：符号位不变，数值位取反。</p><p>补码表示：符号位不变，数值位取反+1，实现加法器做减法</p><p>移码表示：符号位取反，数值位不变，用于真值比较大小</p><h2 id="2-2定点数的运算"><a href="#2-2定点数的运算" class="headerlink" title="2.2定点数的运算"></a>2.2定点数的运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>算数移位</p><p>1、正数：移位补0</p><p>2、负数</p><p>#原码：补0</p><p>#反码：补1</p><p>#补码：左移补0，右移补1</p><p>符号位不参与</p><p>逻辑移位</p><p>将操作数看作无符号数</p><p>左移或右移都补0</p><p>循环移位</p><p>带进位标志位的循环移位</p><p>不带进位标志位的循环移位</p><h3 id="原码加减"><a href="#原码加减" class="headerlink" title="原码加减"></a>原码加减</h3><p>加法准则</p><p>符号相同：绝对值相加，符号不变</p><p>符号不同，绝对值大的间去绝对值小的</p><p>减法准则</p><p>减去一个数&#x3D;加上这个数的负数</p><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>[A+B]补 &#x3D; [A]补 + [B]补</p><p>[A-B]补 &#x3D; [A]补 + [-B]补</p><h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><p>溢出判断：01为正溢出，10为负溢出</p><p>1、一位符号位：参加运算的两个符号数相同，但结果符号发生变化，即发生了溢出</p><p>2、双符号位：01正溢出，10负溢出</p><p>3、单符号位与数据进位：符号位与最高位进位相同，则无溢出</p><h3 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h3><p>符号位：两个符号位异或</p><p>累加次数：n</p><p>右移补0</p><p>符号位不参与运算</p><p>原码一位乘法图解</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E5%9B%BE%E8%A7%A3.png" alt="原码一位乘法图解"></p><h3 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h3><p>累加次数：n+1</p><p>负数右移补1</p><p>符号位参与运算</p><p>补码一位乘法图解</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/1.png" alt="1"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E5%9B%BE%E8%A7%A3.png" alt="补码一位乘法图解"></p><h3 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h3><h4 id="恢复余数"><a href="#恢复余数" class="headerlink" title="恢复余数"></a>恢复余数</h4><p>符号位不参与运算</p><p>左移补0</p><p>每次减法之后判断余数是否为负数，若为负数则恢复</p><p>若最终余数为负数，则需要恢复余数</p><p>原码除法：恢复余数法（手算）</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95%EF%BC%9A%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95%EF%BC%88%E6%89%8B%E7%AE%97%EF%BC%89.png" alt="原码除法：恢复余数法（手算）"></p><h4 id="不恢复余数（加减交替法）"><a href="#不恢复余数（加减交替法）" class="headerlink" title="不恢复余数（加减交替法）"></a>不恢复余数（加减交替法）</h4><p>符号位不参与运算</p><p>左移补0</p><p>余数符号位为1商0，符号位为0则商1</p><p>原码除法：加减交替法</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95%EF%BC%9A%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="原码除法：加减交替法"></p><h3 id="补码除法（加减交替法）"><a href="#补码除法（加减交替法）" class="headerlink" title="补码除法（加减交替法）"></a>补码除法（加减交替法）</h3><p>符号位参与运算，采用双符号位</p><p>除数与余数同号商1，异号商0</p><p>商末位恒置1</p><p>补码除法：加减交替法</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95%EF%BC%9A%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95.png" alt="补码除法：加减交替法"></p><h2 id="2-3浮点数的表示"><a href="#2-3浮点数的表示" class="headerlink" title="2.3浮点数的表示"></a>2.3浮点数的表示</h2><h3 id="表示格式"><a href="#表示格式" class="headerlink" title="表示格式"></a>表示格式</h3><p>1、阶码：整数，阶符与阶码的位数共同反映浮点数的表示范围与小数点的实际位置</p><p>2、数符：表示浮点数的符号</p><p>3、尾数：尾数的位数表示浮点数的精度</p><h3 id="规格化浮点数"><a href="#规格化浮点数" class="headerlink" title="规格化浮点数"></a>规格化浮点数</h3><p>左规：尾数算术左移一位，阶码减1</p><p>右规：尾数算术右移一位，阶码加1，可能出现溢出</p><h3 id="原码规格化"><a href="#原码规格化" class="headerlink" title="原码规格化"></a>原码规格化</h3><p>正数：0.1xxxx</p><p>负数：1.1xxx</p><p>尾数最高一位不为0，基数4最高两位不为0，基数5最高三位不为0</p><h3 id="补码规格化"><a href="#补码规格化" class="headerlink" title="补码规格化"></a>补码规格化</h3><p>正数：0.1xxx</p><p>负数：1.0xxx</p><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p>阶码&#x3D;真值+偏置值</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/IEEE754.png" alt="IEEE754"></h4><h2 id="2-4浮点数的加减运算"><a href="#2-4浮点数的加减运算" class="headerlink" title="2.4浮点数的加减运算"></a>2.4浮点数的加减运算</h2><h3 id="运算步骤"><a href="#运算步骤" class="headerlink" title="运算步骤"></a>运算步骤</h3><p>1、对阶：小阶向大阶对齐，尾数右移，阶码+1</p><p>2、尾数求和：按照定点数加减规则运算</p><p>3、规格化：最高数值位与符号位不同即为规格化形式</p><p>4、舍入：</p><p>0舍1入法</p><p>恒置1法</p><p>5、溢出判断：</p><p>只有右规，仍然溢出，此时才是真正溢出</p><p>上溢出：进入中断处理</p><p>下溢出：按机器零处理</p><p>6、强制类型转换</p><p>char–&gt; 在前面补0</p><p>int&lt;—-&gt;unsigned 彼此都可能因为溢出丢失数据</p><p>int&lt;—&gt;float</p><h3 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h3><p>现代计算机通常是字节编址，即每个字节对应1个地址</p><p>通常也支持按字、半字、字节寻址</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8.png" alt="运算方法与运算器"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第一章:计算机系统的概述</title>
    <link href="https://wjjhui.github.io/2022/05/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://wjjhui.github.io/2022/05/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/</id>
    <published>2022-05-01T12:50:18.000Z</published>
    <updated>2022-05-15T10:44:23.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1计算机发展历程"><a href="#1-1计算机发展历程" class="headerlink" title="1.1计算机发展历程"></a>1.1计算机发展历程</h2><h3 id="计算机的硬件发展"><a href="#计算机的硬件发展" class="headerlink" title="计算机的硬件发展"></a>计算机的硬件发展</h3><p>第一代：电子管时代</p><p>第二代：晶体管时代</p><p>第三代：中小规模集成电路时代</p><p>第四代：超大规模集成电路时代</p><p>元件的更新变化</p><p>摩尔定律：18个月晶体管翻一番</p><p>半导体存储器不断发展</p><p>微处理器不断地发展</p><h3 id="计算机软件发展"><a href="#计算机软件发展" class="headerlink" title="计算机软件发展"></a>计算机软件发展</h3><p>面向机器：机器语言和汇编语言</p><p>高级语言：FORTRAN-&gt;PASCAL-&gt;C++-&gt;…</p><h3 id="计算机的分类和发展方向"><a href="#计算机的分类和发展方向" class="headerlink" title="计算机的分类和发展方向"></a>计算机的分类和发展方向</h3><p>电子计算机</p><p>电子模拟计算机</p><p>电子数字计算机</p><p>数字计算机</p><p>专用计算机</p><p>通用计算机</p><h2 id="1-2计算机体系结构"><a href="#1-2计算机体系结构" class="headerlink" title="1.2计算机体系结构"></a>1.2计算机体系结构</h2><h3 id="计算机系统的构成"><a href="#计算机系统的构成" class="headerlink" title="计算机系统的构成"></a>计算机系统的构成</h3><p>硬件和软件</p><p>功能实现：硬件和软件再逻辑上是等效的，硬件实现效率高但成本高</p><h3 id="计算机的硬件的基本组成"><a href="#计算机的硬件的基本组成" class="headerlink" title="计算机的硬件的基本组成"></a>计算机的硬件的基本组成</h3><p>早期 冯·诺依曼</p><p>组成：运算器、存储器、控制器、输入设备、输出设备</p><p>指令与数据共存与存储器，按地址访问</p><p>指令与数据以二进制代码构成</p><p>指令组成：操作码与地址吗</p><p>指令顺序存放，顺序执行</p><p>运算器为中心，输入输出设备通过运算器与存储器传送数据</p><p>“存储程序”：讲指令以二进制代码的形式事先输入计算机的主存储器，然后再执行</p><p>现代计算机体系结构</p><p>存储器为中心</p><p>I&#x2F;O操作尽可能的绕开CPU，实现I&#x2F;O设备与存储器直接完成，从而提高运行效率</p><h3 id="计算机软件的分类"><a href="#计算机软件的分类" class="headerlink" title="计算机软件的分类"></a>计算机软件的分类</h3><p>以功能分类</p><p>系统软件</p><p>应用软件</p><p>语言分类</p><p>机器语言</p><p>汇编语言</p><p>高级语言</p><h3 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h3><p>具体步骤</p><p>1、程序、数据装入主存</p><p>2、从程序起始地址开始运行</p><p>3、程序首地址取出指令-&gt;指令译码-&gt;完成功能并计算下一条指令地址</p><p>4、新得到的指令地址读出下一条指令，直到程序结束</p><p>信息流程</p><p>取指令：PC–&gt;MAR–&gt;M–&gt;MDR–&gt;R</p><p>分析指令:OP(IR)–&gt;CU</p><p>执行指令:AD(IR)–&gt;MAR–&gt;M–&gt;MDR–&gt;ACC</p><h3 id="计算机系统得多级层次结构"><a href="#计算机系统得多级层次结构" class="headerlink" title="计算机系统得多级层次结构"></a>计算机系统得多级层次结构</h3><p>1、虚拟机器（高级语言机器）</p><p>2、虚拟机器（汇编语言机器）</p><p>3、虚拟机器（操作系统机器）</p><p>4、—-软硬件交互界面—-</p><p>5、传统机器（使用机器语言的机器）</p><p>6、微程序机器（微指令系统）</p><h3 id="各硬件"><a href="#各硬件" class="headerlink" title="各硬件"></a>各硬件</h3><p>主存</p><p>存储体：存储元、存储单元、存储字、存储字长、地址</p><p>  MAR：地址寄存器，用于指明要读&#x2F;写哪个存储单元</p><p>  MDR：数据寄存器，存放操作数，用于暂存要读&#x2F;写的数据</p><p>运算器</p><p>  ACC：累加计数器，存放操作数、运算的结果</p><p>  MQ：乘商寄存器，进行乘，除法时的寄存器</p><p>  X：通用寄存器，存放操作数</p><p>  ALU：算术逻辑运算单元，用电路实现各种式算法运算、逻辑运算</p><p>控制器</p><p>  PC：程序计数器，存放下一条指令的地址</p><p>  IR：指令寄存器，存放当前执行的指令</p><p>  CU：控制单元，分析指令，给出控制信号</p><p>工作过程</p><p>初始：指令、数据存入主存，PC指向第一条指令</p><p>从主存中取出指令放入IR、PC自动加1，CU分析指令、CU指挥其他部件执行指令</p><p>1.3计算机性能指标</p><h3 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h3><p>计算机进行一次整数运算课处理的二进制位数</p><p>1、受到CPU寄存器位、加法器影响</p><p>2、一般情况下机器字长等于内部寄存器大小</p><p>3、字长越长，表示范围越大，精度越高</p><h3 id="数据通路带宽"><a href="#数据通路带宽" class="headerlink" title="数据通路带宽"></a>数据通路带宽</h3><p>数据总线一次性所能传送信息的位数</p><h3 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h3><p>主存储器的最大容量，MAR位数反应了存储单元的个数，反映了最大寻址范围</p><h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><p>吞吐量</p><p>单位时间内处理请求的数量</p><p>取决于主存的存取周期</p><p>响应时间</p><p>用于发送请求，然后系统对请求做出响应并且获得所得结果的等待时间</p><h4 id="CPU时钟周期"><a href="#CPU时钟周期" class="headerlink" title="CPU时钟周期"></a>CPU时钟周期</h4><p>节拍脉冲或者是T周期，1&#x2F;主频</p><p>  CPU的最小时间单位，每个动做至少需要一个时钟周期</p><p>主频</p><p>机器内部主时钟的频率，衡量机器速度的重要参数</p><h4 id="CPI"><a href="#CPI" class="headerlink" title="CPI"></a>CPI</h4><p>执行一条指令所需要的时钟周期数</p><h4 id="CPU执行时间"><a href="#CPU执行时间" class="headerlink" title="CPU执行时间"></a>CPU执行时间</h4><p>运行一个程序所花时间</p><p>影响因素：主频、指令条数、每条指令的执行周期</p><p>计算能力</p><p>  MIPS：每秒执行多少条百万指令</p><p>  MFLOPS：每秒执行多少百万次浮点运算</p><p>  GFLOPS：每秒执行多少十亿次浮点运算</p><p>  TFLOPS：每秒执行多少万亿浮点运算</p><h2 id="1-3注意问题"><a href="#1-3注意问题" class="headerlink" title="1.3注意问题"></a>1.3注意问题</h2><h3 id="1、翻译程序、解释程序、汇编程序、编译程序的区别和联系"><a href="#1、翻译程序、解释程序、汇编程序、编译程序的区别和联系" class="headerlink" title="1、翻译程序、解释程序、汇编程序、编译程序的区别和联系"></a>1、翻译程序、解释程序、汇编程序、编译程序的区别和联系</h3><p>翻译程序程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无需重新翻译。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直到所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并不会生成目标程序</p><p>汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序</p><h3 id="2、字、字长、机器字长、指令字长、存储字长的区别和联系"><a href="#2、字、字长、机器字长、指令字长、存储字长的区别和联系" class="headerlink" title="2、字、字长、机器字长、指令字长、存储字长的区别和联系"></a>2、字、字长、机器字长、指令字长、存储字长的区别和联系</h3><p>通常说的“某16位或32位机器”中，16、32指的是字长，也就是机器字长。所谓字长，通常是指CPU内部用于整数运算得数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度。</p><p>指令字长：一个指令字中包含的二进制代码的位数</p><p>存储字长：一个存储单元存储的二进制代码的长度</p><p>它们都必须是字节的整数倍</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0.png" alt="计算机系统的概述"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第五章:IO管理</title>
    <link href="https://wjjhui.github.io/2022/04/30/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AIO%E7%AE%A1%E7%90%86/"/>
    <id>https://wjjhui.github.io/2022/04/30/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AIO%E7%AE%A1%E7%90%86/</id>
    <published>2022-04-30T12:28:49.000Z</published>
    <updated>2022-05-15T10:44:11.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-IO管理概述"><a href="#5-1-IO管理概述" class="headerlink" title="5.1 IO管理概述"></a>5.1 IO管理概述</h2><h3 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><h4 id="人机交互的外部设备"><a href="#人机交互的外部设备" class="headerlink" title="人机交互的外部设备"></a>人机交互的外部设备</h4><p> 用于计算机用户之间交互设备（打印机，鼠标，键盘）</p><p> 交换速度相对较慢，以字节为单位进行数据交换</p><h4 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h4><p> 用于存储程序和数据的设备（磁盘、磁带、光盘）</p><p> 交换速度较快，以多字节组成的块为基本单位交换</p><h4 id="网络通信设备"><a href="#网络通信设备" class="headerlink" title="网络通信设备"></a>网络通信设备</h4><p> 用于远程设备通信的设备（网络接口、调制解调器）</p><p> 速度介于前两类之间</p><h4 id="传输速率分类"><a href="#传输速率分类" class="headerlink" title="传输速率分类"></a>传输速率分类</h4><p> 低速设备：每秒进位几个字节到数百字节</p><p> 中速设备：传输速率为每秒在数千字节至数万字节</p><p> 高速设备：传输速率在数百字节到千兆字节的一类设备</p><h4 id="信息交换单位分类"><a href="#信息交换单位分类" class="headerlink" title="信息交换单位分类"></a>信息交换单位分类</h4><p> 块设备：信息存取总是以数据块为基本单位，存储信息的设备为块设备，传输速率高，可寻址，可以任意读写某块</p><p> 字符设备：用于数据输入输出的设备为字符设备，传输的基本单位是字符，传输速率低，不可寻址</p><h3 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><p> 计算机从外部设备读取数据到存储器，每次读一个字的数据，对读入的每个字，CPU都要对外设状态进行循坏检查，知道确定该字已经在I&#x2F;O设备控制器的数据寄存器中</p><p> 读写单位：字</p><p> 优点：容易实现，操作简单</p><p> 缺陷：CPU高速性和IO设备的低速性的矛盾，CPU和IO设备只能串行工作</p><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><p> 允许IO设备主动打断CPU的运行并请求器，进而解放CPU，使其向IO控制器发送读命令后可以继续做其他有用的工作</p><p> 读写单位：字</p><p> 优点：比程序直接控制方式有效</p><p> 缺点：数据的传输必须要经过CPU，仍然后消耗CPU的时间</p><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p> 在IO设备和内存之间开辟直接的数据交换通路，彻底解放CPU</p><p> 特点</p><p> 读写单位：数据块</p><p> 设备直接送入内存</p><p> 只有当一个或多个数据块开始和结束的时候，CPU才会进行干预</p><p> 寄存器</p><p> 命令&#x2F;状态寄存器（CR）：用于接收CPU发送的IO命令和有关控制信息或者设备状态</p><p> 内存地址寄存器（MAR）：数据直接在设备与内存之间交互</p><p> 数据寄存器（DR）：用于暂存从设备到内存或者从内存到设备的数据</p><p> 数据计数器（DC）：存放本次要传送的字节数</p><h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p> 设置一个专门负责输入&#x2F;输出的处理机，实现对一组数块的读写以及相关控制和管理为单位干预</p><p> 读写单位：一组块</p><p> 优点：有效的提高了系统资源利用率</p><p> 缺点：实现较为复杂</p><h4 id="DMA-和通道的区别"><a href="#DMA-和通道的区别" class="headerlink" title="DMA 和通道的区别"></a>DMA 和通道的区别</h4><p>DMA需要CPU来控制传输的数据块的大小，传输的内存位置，而通道方式中这些信息是有通道控制的</p><p>DMA控制器对应一台设备与内存传递数据，通道可以控制多台设备与内存的数据交换</p><h3 id="I-x2F-O系统的的层次结构"><a href="#I-x2F-O系统的的层次结构" class="headerlink" title="I&#x2F;O系统的的层次结构"></a>I&#x2F;O系统的的层次结构</h3><h4 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h4><p> 用户层IO软件：实现与用户交互的接口，用户可以直接调用在用户层提供与IO操作有关的函数，对设备进行操作</p><p> 设备独立性软件：</p><p> 用于实现用户程序与设备驱动的统一接口、设备命令、设备保护及设备分配与释放，同时为设备管理与数据传送提供必要的存储空间</p><p> 设备独立性也称为设备无关性，使得应用程序独立于具体使用的物理设备</p><p> 使用逻辑设备的好处：增加设备分配的灵活性，易于实现IO重定向</p><p> 主要功能：执行所有设备的公有操作，向用户层提供统一接口</p><p> 设备驱动程序：与硬件直接相关，负责实现系统对设备发出的操作命令，驱动IO设备工作的驱动程序</p><p> 中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回被中断的进程</p><p> 硬件设备：IO设备通常包括一个机械部件和电子部件</p><p> 层次划分图解</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86%E5%9B%BE%E8%A7%A3.png" alt="层次划分图解"></p><h4 id="设备控制的功能"><a href="#设备控制的功能" class="headerlink" title="设备控制的功能"></a>设备控制的功能</h4><p> 接收和识别CPU或通道发来的命令</p><p> 实现数据交换</p><p> 发现和记录设备及自身的状态信息，供CPU处理使用</p><p> 设备地址识别</p><h4 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a>设备控制器的组成</h4><p> 设备控制器与CPU的接口</p><p> 信号线</p><p> 数据线</p><p> 地址线</p><p> 控制线</p><p> 设备控制器与设备的接口，每个接口存在数据、控制和状态三种类型的信号</p><p>IO控制逻辑，用于实现对设备的控制。通过一组控制线与CPU进行交互，对从CPU收到的IO命令进行译码</p><p> 注意！！！</p><p> 1、一个I&#x2F;O控制器可能对应多个设备</p><p> 2、数据寄存器、控制寄存器、状态寄存器可能有多个，且这些寄存器都要有相应的地址，才能方便CPU操作</p><p> 3、有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像IO</p><p> 4、一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址</p><h2 id="5-2-IO核心子系统"><a href="#5-2-IO核心子系统" class="headerlink" title="5.2 IO核心子系统"></a>5.2 IO核心子系统</h2><h3 id="IO子系统概述"><a href="#IO子系统概述" class="headerlink" title="IO子系统概述"></a>IO子系统概述</h3><p>主要提供IO调度，缓冲与高速缓存，设备分配与回收、假脱机、设备保护或差错处理</p><h3 id="IO调度概念"><a href="#IO调度概念" class="headerlink" title="IO调度概念"></a>IO调度概念</h3><p>通过IO调度改善系统性能，使得进程之间公平共享设备访问，减少IO完成所需要的的平均等待时间</p><p>使用主存或者磁盘上的存储空间的计数，如缓冲、高速缓存、假脱机等来改善计算机效率</p><h3 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h3><h4 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h4><p> 使用磁盘高速缓存技术可以提高磁盘的IO速度，对高速缓存复制的访问要比原始数据访问更高效</p><p> 磁盘高速缓存，逻辑上属于磁盘，物理上属于驻留在内存中的盘块</p><p> 在内存中的两种形式</p><p> 在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定</p><p> 把未利用的内存空间为作为一个缓冲池，供请求分页系统和磁盘IO时共享</p><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p> 引入缓冲区的目的</p><p> 1、缓和CPU与IO之间的速度差异矛盾</p><p> 2、减少对CPU的中断频率，放宽对CPU中断响应时间的限制</p><p> 3、解决基本数据单元大小不匹配的问题</p><p> 4、提高CPU和IO设备之间的并行性</p><p> 实现方法</p><p> 采用硬件缓冲器（成本高），除了关键位置，一般不使用硬件缓冲器</p><p> 采用缓冲区（位于内存）</p><p> 分类</p><p>c：CPU对数据的处理时间</p><p>t：数据写入缓冲区的时间</p><p>m：缓冲区数据传入用户区的时间</p><p> 单缓冲</p><p> 设备和处理之间设置缓冲区，设备和处理机交换数据的时候，先把被交换的数据写入缓冲区，然后需要数据的设备或处理机从缓冲区中取走数据</p><p> 使用时间max（c,t）+m</p><p> 双缓冲</p><p> 设置两个缓冲区，当缓冲区1满时，向缓冲区2注入数据，只有缓冲区满才能取出数据</p><p> 提高了处理和输入设备的并性操作程度</p><p>####### max（c+m，t）</p><p> 循环缓冲：包含多个大小相等的缓冲区，每个缓冲区有一个链接指针指向下一个缓冲区，最后一个缓冲区指向第一个缓冲区，多个缓冲区构成一个环形</p><p> 缓冲池：</p><p> 缓冲区分为三个队列，空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列</p><p> 四种缓冲区：收容输入数据的工作缓冲区，提取输入数据的缓冲队列，装满输出数据的缓冲队列</p><p> 注意！！！：管道通信中的管道起始就是缓冲区，要实现数据的双向传输必须设置两个管道</p><h4 id="高速缓冲与缓冲区对比"><a href="#高速缓冲与缓冲区对比" class="headerlink" title="高速缓冲与缓冲区对比"></a>高速缓冲与缓冲区对比</h4><p> 相同点：</p><p> 都介入高速设备和低速设备之间</p><p> 不同：</p><p> 存放数据</p><p> 高速缓存：存放的是低速设备上的某些数据的复制数据</p><p> 缓冲区：存放的是低速设备传递给高速设备的数据，这些数据在低速设备上不一定有备份，这些数据再从缓冲区传送到高速设备</p><p> 目的</p><p> 高速缓存：高速缓存存放的高速设备经常要访问的数据，如过高速缓存中数据不在，高速设备就要访问低速设备</p><p> 高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会去直接访问低速设备</p><h3 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h3><p>概述：根据用户IO请求分配设备，原则：充分发挥设备的使用效率，避免进程死锁</p><h4 id="设备类型分类"><a href="#设备类型分类" class="headerlink" title="设备类型分类"></a>设备类型分类</h4><p> 独占式使用设备：设备只能互斥使用</p><p> 分时共享使用设备：通过分时共享来提高设备的利用率</p><p>SPOOLin假脱机：使用空间换时间，对IO设备进行批处理</p><h4 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h4><p> 1、系统设备表（SDT）:记录已经连接到系统中所有物理设备的情况</p><p> 2、设备访问控制表（DCT）：一个设备控制表表示一个设备，控制表中是设备的各项属性</p><p> 3、控制器控制表（COCT）：COCT与DCT一一对应关系，DCT需要一个表项来表示控制器，即一个指向控制器控制表的指针</p><p> 4、通道控制表（CHCT）:CHCT提供服务的哪几个设备控制</p><h4 id="设备分配的策略"><a href="#设备分配的策略" class="headerlink" title="设备分配的策略"></a>设备分配的策略</h4><p> 分配原则：充分发挥设备效率，避免进程死锁</p><p> 分配方式</p><p> 静态</p><p> 系统一次性的把设备分配给响应作业，知道作业结束</p><p> 优点：没有死锁问题</p><p> 缺点：降低了设备使用率</p><p> 动态</p><p> 进程执行过程中根据执行需要进行分配</p><p> 优点：提高了设备利用率</p><p> 缺点：分配算法不当可能导致死锁</p><p> 设备分配算法</p><p> 先请求先分配</p><p> 优先级高者优先</p><p> 独占设备一般使用静态分配，共享设备一般使用动态分配</p><h3 id="IO调度"><a href="#IO调度" class="headerlink" title="IO调度"></a>IO调度</h3><h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4><p> 独占设备：一个时段只能分配给一个进程</p><p> 共享设备：可同时分配给多个进程使用，各进程往往是宏观上同时共享使用设备，而微观上交替使用</p><p> 虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用</p><h4 id="设备分配的安全性"><a href="#设备分配的安全性" class="headerlink" title="设备分配的安全性"></a>设备分配的安全性</h4><p> 安全设备分配</p><p> 进程发出IO请求后便进入阻塞态，知道IO结束才被唤醒</p><p> 优点：设备分配安全</p><p> 缺点：CPU和IO设备串行工作</p><p> 不安全分配方式</p><p> 进程发出IO请求后继续运行，需要时发出第二个，第三个请求</p><p> 优点：进程推进迅速</p><p> 确定点可能产生死锁</p><h4 id="逻辑设备名到物理设备名的映射"><a href="#逻辑设备名到物理设备名的映射" class="headerlink" title="逻辑设备名到物理设备名的映射"></a>逻辑设备名到物理设备名的映射</h4><p> 目的</p><p> 1、提高设备分配的灵活零和利用率</p><p> 2、实现IO重定向</p><p> 3、引入设备独立性</p><p> 实现方法：引入逻辑设备表（LUT），用来将逻辑设备名映射为物理设备名</p><p> 建立方式</p><p> 整个系统设置一张LUT，所有设备分配情况读记录在这张表上</p><p> 每个用户建立一张LUT，分步记录设备的分配情况</p><h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><p>目的：缓解CPU和IO速度差异矛盾</p><p>要实现SPOOLLing技术，必须要有多道程序技术的支持</p><h4 id="输入井和输出井"><a href="#输入井和输出井" class="headerlink" title="输入井和输出井"></a>输入井和输出井</h4><p> 输入并用来收容IO设备的数据</p><p> 输出井用来模拟输出时的磁盘</p><h4 id="输入缓冲区和输出缓冲区"><a href="#输入缓冲区和输出缓冲区" class="headerlink" title="输入缓冲区和输出缓冲区"></a>输入缓冲区和输出缓冲区</h4><p> 输入缓冲区：暂存由输入设备送来的数据</p><p> 输出缓冲区：暂存从输出井送来的设备</p><h4 id="输入进程和输出进程"><a href="#输入进程和输出进程" class="headerlink" title="输入进程和输出进程"></a>输入进程和输出进程</h4><p> 输入进程：模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲送到输入井，当CPU需要数据，直接将输入井的数据送入内存</p><p> 输出进程：模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，在将输出井的数据经过输出缓冲区送到输出设备</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p> 1、提高了速度</p><p> 2、独占设备变成了共享设备</p><p> 3、实现了虚拟设备功能</p><p>通俗一点就是，如果设备被占用就先将数据暂存一下，等到设备空闲了就把这些数据输送到设备中</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/IO%E7%AE%A1%E7%90%86.png" alt="IO管理"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>第四章:文件管理</title>
    <link href="https://wjjhui.github.io/2022/04/25/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://wjjhui.github.io/2022/04/25/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2022-04-25T11:31:50.000Z</published>
    <updated>2022-05-15T10:44:06.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1文件系统基础"><a href="#4-1文件系统基础" class="headerlink" title="4.1文件系统基础"></a>4.1文件系统基础</h2><h3 id="文件的相关概念"><a href="#文件的相关概念" class="headerlink" title="文件的相关概念"></a>文件的相关概念</h3><p> 相关定义</p><p> 1、文件是以计算机硬盘为载体的存储在计算机上的集和，文件可以是文本文档、图片、程序等</p><p> 2、系统运行时，计算机以进程为基本单位进行资源的调度和分配</p><p> 3、在用户输入输出时，以文件为基本单位</p><p> 4、操作系统的文件系统：用于实现文件的权限访问，修改，查询和保存等功能</p><p> 5、文件结构</p><p> 数据项：数据项是文件系统中最低级的数据组织形式</p><p> 记录：一组数据项的集和，用户描述一个对象在某方面的属性</p><p> 文件：创建者所定义的一组相关信息的集和</p><p> 文件的属性</p><p> 1、名称：文件名称唯一，以容易读取的形式保存</p><p> 2、标识符：文件的唯一标签，通常为数字，是对人不可读的一种内部名称</p><p> 3、类型：被支持的不同类型的文件系统所使用</p><p> 4、位置：指向设备和设备上文件的指针</p><p> 5、大小：文件当前的大小，包含文件允许的最大值</p><p> 6、保护：对文件进行保护的访问控制信息</p><p> 7、时间、日期和用户标识：文件的创建、修改和上次访问的相关信息，用于保护和跟踪文件的使用</p><p> 文件的基本操作</p><p> 1、创建文件：1）文件系统为文件找到空间 2）目录为文件创建条目，该条目记录文件名称，在文件系统中的位置以及其他可能的信息</p><p> 2、写文件：执行系统调用：指明文件名和写入内容，查找文件位置，为该文件维护一个写位置的指针，当发生写操作的时候更新写指针</p><p> 3、读文件：执行系统调用：指明文件名和文件位置，搜素目录项，系统维护一个读指针，发生读操作就对该指针进行更新</p><p> 4、文件重定位：按照某种条件搜索目录，将当前文件设置定值，并且不会读、写文件</p><p> 5、删除文件：搜索目录，找到文件的目录项，使其变为空项，然后回收目标文件占用的存储空间</p><p> 6、截断文件：允许文件的所有属性不变，并删除文件内容，即将其长度设为0并释放空间</p><p> 文件的打开和关闭</p><p>open请求</p><p> 首次使用文件，会调用open请求指明文件的属性（包括其物理位置）从外存复制到内存打开文件表的一个表目中，并将该表目的编号返回给用户</p><p> 操作open会根据文件名搜索目录，并将目录条目复制到打开文件</p><p> 文件关联信息</p><p> 1、文件的指针：系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对于打开文件的某个进程说是唯一的，因此必须与磁盘文件属性分开保存</p><p> 2、文件打开计数：文件关闭，必须重用其打开表条目，否则表内空间会不够用，计数器为0关闭文件，删除该条目</p><p> 3、文件磁盘位置：该信息存储在内存存放，以免每个操作都要从磁盘中读取</p><p> 4、访问权限：每个进程打开文件都需要一个访问模式，该信息保存在进程打开的文件表中，以便操作系统能够允许或拒绝之后的I&#x2F;O请求</p><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p> 无结构文件</p><p> 1、最简单的文件组织形式</p><p> 2、将数据按照顺序组织记录并积累、保存、是有序相关信息项的集和</p><p> 3、由于其没有结构，所有只能采用穷举搜索</p><p> 4、管理简单，方便用于对其操作</p><p> 5、基本信息单位操作不多的文件适合采用字符流的无结构方式</p><p> 有结构文件</p><p> 顺序文件</p><p> 1、文件的记录是一个接一个排列，记录通常是定长的，可以顺序存储或者链表存储</p><p> 2、批量处理时，顺序文件的效率是所有逻辑文件中效率最高的</p><p> 3、但是增删改查操作比较困难</p><p> 索引文件</p><p> 定长记录文件</p><p> 按照公式A&#x3D;i*L可以直接得到文件地址</p><p> 变长记录文件</p><p> 查找i-1条记录后，才能查找第i条记录</p><p> 通过建立索引表后可以有效提高查找速度</p><p> 索引顺序文件</p><p> 1、顺序和索引两种组织形式的结合</p><p> 2、索引文件将顺序文件中所有记录分成若干段，为顺序文件建立起一张索引表，在索引表中为每组中第一条记录建立一个索引项，其中含有该记录的关键字和指向该记录的指针</p><p> 3、索引顺序文件提高了查找效率，但是索引表也占用了存储空间</p><p> 直接文件或散列文件</p><p> 1、给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址</p><p> 2、这种映射结构不同于顺序文件或者索引文件，没有顺序的特性</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p> 包含有关文件的信息，如属性、位置和所有权等</p><p> 文件控制块和索引节点</p><p> 文件控制块FCB</p><p> 用来存放控制文件需要的各种信息的数据结构，实现”按名存取”</p><p> 包含信息</p><p> 1、基本信息：文件名、文件的物理位置、逻辑结构、物理结构等</p><p> 2、存取控制信息：文件存取权限</p><p> 3、使用信息：文件建立时间，修改时间</p><p> 索引节点</p><p> 检索目录文件时，不需要将文件调入内存，只是查找其目录项，文件的描述信息单独形成索引节点的数据结构</p><p> 磁盘索引节点</p><p> 1、文件主标识符：拥有该文件的个人或小组的标识符</p><p> 2、文件类型：普通文件、目录文件、特别文件</p><p> 3、文件存取权限：各类用户对该文件的存取权限</p><p> 4、文件物理地址：每个索引节点中含有13个地址项，直接或者间接的方式给出数据文件所在盘块的编号</p><p> 5、文件长度：字节为单位</p><p> 6、文件链接计数：本文件系统中所有指向该文件的文件名的指针计数</p><p> 7、文件存取时间：文件最近被进程存取，修改以及索引节点最近被修改的时间</p><p> 文件打开后内存索引节点增加的内容</p><p> 1、索引节点编号：用于标识内存索引节点</p><p> 2、状态：表明i节点是否被上锁或者被修改</p><p> 3、访问计数：每当有几个进程要访问i节点时，计数加1，访问结束为-1</p><p> 4、逻辑设备号：文件所属文件系统的逻辑设备号</p><p> 5、链接指针：设置分别指向空闲连接和散列队列的指针</p><p> 目录结构</p><p> 1、搜索：用户使用一个文件时，需要搜索目录，找到该文件对应的目录项</p><p> 2、创建文件：创建一个新文件时，需要在目录中增加一个目录项</p><p> 3、删除文件：删除一个文件时，需要在目录中删除相应的目录项</p><p> 4、显示目录：用户可以请求显示目录的内容，显示该用户目录中的所有文件及属性</p><p> 5、修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项</p><p> 目录结构分类</p><p> 单级目录结构</p><p> 整个文件系统只建立一张目录表，每个文件占一个目录项</p><p> 优点：实现了按名存取</p><p> 缺点：查找速度慢，文件不允许重名，不便于文件共享，不适用于多用于的操作</p><p> 二级目录结构</p><p> 将文件分为主目录和用户目录，主目录记录用户名及相应的用户文件目录所在的存储位置，用户目录项记录该用户文件的FCB信息</p><p> 优点：解决了用户文件重名问题，在一定程度上保证了文件的安全</p><p> 缺点：缺乏灵活性，不能对文件进行分类</p><p> 多级目录结构</p><p> 将二级目录结构的层次关系加以推广，就形成了多级目录结构，即树形目录结构</p><p> 进程对个文件的访问都是相对于当前目录进行的</p><p> 优点：有效的对文件进行分类，文件结构层次清晰，能够有效的进行文件管理和保护</p><p> 缺点：按照路径名访问中间节点，增加了磁盘访问次数，降低了查询速度</p><p> 无环图目录结构</p><p> 在树形目录结构基础上增加了一些指向同一节点的有向边，使整个目录称为一个有向无环图</p><p> 优点：有利于实现文件共享</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p> 基于索引节点的共享方式（硬链接）</p><p> 文件目录中只设置文件名及指向相应索引节点的指针，在索引节点中还要一个链接计数count，用于表示本链接到本索引节点上的用户目录项的数目</p><p> 硬链接是多个指针指向一个索引节点，保证只要还要一个指针指向索引节点，索引节点就不能删除</p><p> 优点：硬链接的查找速度比软链接快</p><p> 利用符号链实现文件共享（软连接）</p><p>B用户共享A用户的文件时，系统创建一个link类型的文件，然后将link文件写入用户B的目录中，但是新文件中只包含有被链接的文件的路径名</p><p> 软连接就是把达到共享文件的路径记录下来，当要访问时，根据路径寻找文件</p><p> 优点：网络共享只需要提供该文件所在及其的网络地址及该机器中的文件路径</p><p> 缺点：由于是根据文件路径名找到文件，因此会增加时间开销并且增加了启动磁盘的频率，同时符号链的索引节点也会耗费一定的硬盘空间</p><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p> 为了防止文件共享导致文件被破坏或者未经允许修改文件，文件系统必须控制对用户的存取，解决对文件的读、写、执行等许可问题</p><p> 实现方式</p><p> 1、口令保护：用户请求方式需要提供相应的口令</p><p> 优点：时间和空间开销不多</p><p> 缺点：口令直接俄存储在系统内部不安全</p><p> 2、加密保护：用户对文件进行加密，用户访问时需要密钥解密</p><p> 优点：保密性强，节省了存储空间</p><p> 缺点：加密和解密需要花费一定的时间</p><p> 3、访问控制：根据用户身份进行控制</p><p> 优点：可以使用复杂的访问方法</p><p> 缺点：长度无法预计且可能导致复杂空间管理</p><h2 id="4-2文件系统的实现"><a href="#4-2文件系统的实现" class="headerlink" title="4.2文件系统的实现"></a>4.2文件系统的实现</h2><h3 id="文件层次结构"><a href="#文件层次结构" class="headerlink" title="文件层次结构"></a>文件层次结构</h3><p> 1、用户调用接口：文件系统为用户提供与文件及目录有关的调用</p><p> 2、文件目录系统：管理文件目录，管理活跃文件目录表，管理读写状态信息表，管理用户进程打开的文件表，管理与组织存储设备上的文件目录结构，调用下一级存取控制模块</p><p> 3、存取控制验证：实现文件保护，将用户的访问请求与FCB指示的访问权限控制进行比较，以确认访问的合法性</p><p> 4、逻辑文件系统关于文件信息缓冲区：逻辑文件系统与文件系统信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号</p><p> 5、物理文件系统：把逻辑记录所在的相对块号转换成实际的物理地址</p><p> 6、辅助分配模块：管理辅存空间，负责分配辅存空闲空间和回收辅存空间</p><p> 7、设备管理程序模块：分配设备，分配设备读写用缓冲区，磁盘调度，启动设备，处理设备中断，释放设备读写缓冲区，释放设备</p><p> 文件层次结构实例</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E6%96%87%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B.png" alt="文件层次结构实例"></p><h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><p> 线性列表</p><p> 使用存储文件名和数据块指针的线性表</p><p> 优点：实现简单</p><p> 缺点：耗费时间</p><p> 哈希表</p><p> 根据文件名得到一个值，然后返回一个指向线性列表中元素的指针</p><p> 优点：查找迅速，插入和删除简单</p><p> 缺点：要避免重铸，哈希表长度固定以及哈希函数对表长有依赖性</p><h3 id="文件实现"><a href="#文件实现" class="headerlink" title="文件实现"></a>文件实现</h3><p> 文件的分配方式</p><p> 连续分配</p><p> 每个文件在磁盘上占有一组连续的块，磁盘地址定义了磁盘上的一个线性排序</p><p> 访存1次</p><p> 优点：实现简单，存取速度块，使得访问磁盘需要的寻道数和寻道时间最小</p><p> 缺点：文件长度不宜动态的增加，会产生外部碎片</p><p> 链接分配</p><p> 采用离散分配方式，提高了磁盘空间利用率，消除了外部碎片</p><p> 访存n次</p><p> 隐式链接</p><p> 磁盘块分布在磁盘的任何地方，除最后一个盘块，其他盘块都有指向下一个盘块的指针</p><p> 优点：不会有碎片问题，外存利用率高</p><p> 缺点：不能直接访问，稳定性存在问题</p><p> 显示链接</p><p> 把用于链接文件各物理块的指针，从每个物理块的末尾提取出来，显示的存放在内存的一张连接表中，整个磁盘设置一张</p><p> 优点：显著的提升检索速度，减少了磁盘访问次数</p><p> 缺点，文件分配表需要占用一定的存储空间</p><p> 索引分配</p><p> 索引分配解决了连接分配不能直接访问的问题</p><p>m级要访问m+1次</p><p> 优化机制</p><p> 链接方案：一个索引块通常为一个磁盘块，为了处理大文件，可以将多个索引链接起来</p><p> 多层索引：第一层索引块指向第二层索引块，第二层索引块指向文件快</p><p> 混合索引：系统即采用直接地址又采用单级索引分配方式或者两级索引分配方式</p><p> 文件存储空间管理</p><p> 文件存储在一个文件卷中，文件卷可以是物理盘中的一部分，也可以是整个物理盘</p><p> 文件存储设备分成许多大小相同的物理块，以块为单位交换信息</p><p> 空闲块管理</p><p> 空闲表法：属于连续分配方式，系统为空闲区建立一张空闲盘块表，每个空闲区第一个盘块号，该区的空闲盘块数等信息</p><p> 空闲链表法：将所有的空闲盘区拉成一条空闲链，根据构成链所有的基本元素不同，可以分为空闲盘块链和空闲盘区链</p><p> 位示图法</p><p> 采用二进制的以为来表示一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应</p><p> 成组链接法</p><p>UNIX使用，结合了空闲表和空闲链表法客服了表太大的缺点</p><p> 把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区则保存另以顺序空闲扇区的地址</p><h2 id="4-3磁盘组织与管理"><a href="#4-3磁盘组织与管理" class="headerlink" title="4.3磁盘组织与管理"></a>4.3磁盘组织与管理</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p> 表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头的导体线圈从磁盘读取数据</p><p> 磁盘盘面上的数据存储在一组同心圆中，称为磁道</p><p> 一个盘面有上千个磁道，磁道又划分为几百个扇区，每个扇区固定存储大小，一份扇区称为一个盘块</p><p> 磁盘地址用柱面号-盘面号-扇区号表示</p><p> 磁盘分类</p><p> 1、固定头磁盘：磁头相对于盘片的径方向固定</p><p> 2、活动头磁盘：每个磁道一个磁头，磁头可以移动</p><p> 3、固定盘磁盘：磁头臂可以来回伸缩定位磁道，磁盘永久固定在磁盘驱动器内</p><p> 4、可换盘磁盘：可以移动和替换</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p> 读写时间组成</p><p> 1、寻找时间：活动头磁盘在读写信息前，将磁头移动到指定磁盘所需要的时间</p><p> 2、延迟时间：磁头定位到某一磁道扇区所需要的时间</p><p> 3、传输时间：从磁盘读出或向磁盘写入数据经过的时间</p><p> 磁盘调度算法</p><p> 1、先来先服务算法(FCFS)</p><p> 按照进程请求访问磁盘的先后顺序进行调度</p><p> 优点：公平、实现简单</p><p> 缺点：适用于少量进程访问，如果进程过多算法更倾向于随机调度</p><p> 2、最短寻找时间优先算法(SSTF)</p><p> 选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道</p><p> 优点：性能强于先来先服务算法</p><p> 缺点：容易产生饥饿现象</p><p> 3、扫描算法(SCAN)</p><p> 在磁头当前移动方向上选择与当前磁头所在的磁道距离最近的请求作为下一次服务对象</p><p> 优点：寻道性能好，可以避免饥饿现象</p><p> 缺点：对扫描过的区域不公平，访问局部性方面不如FCFS和SSTF好</p><p> 4、循环扫描算法（C-SCAN)</p><p> 磁头单向移动，回饭时直接回到起始段，而不服务任何请求</p><p> 5、LOOK与C-LOOK算法</p><p> 在SCAN的基础上改良而来，回到第一个请求处而不是回到起始段</p><p> 对盘面交替编号</p><p> 原因：磁头在读&#x2F;写一个物理块后，需要经过短暂的处理时间才能开始处理下一块</p><p> 磁盘的管理</p><p> 磁盘初始化</p><p> 低级格式化：磁盘分扇区，为每个扇区采用特别的数据结构（头、数据区域、尾部组成），头部含有一些磁盘控制器所使用的信息</p><p> 进一步格式化处理：磁盘分区，对物理分区进行逻辑格式化，包括空闲和已分配的空间及一个初始为空的目录</p><p> 引导块</p><p> 计算机启动运行自举程序，初始化CPU寄存器、设备控制器和内存等，然后启动操作系统</p><p> 组局程序通常保存在ROM中，在ROM中保留很小的自举块，完整的自举程序保存在启动块上</p><p> 拥有启动分区的磁盘称为启动磁盘或系统磁盘</p><p> 坏块</p><p> 无法使用的扇区</p><p> 对于简单的磁盘，可以逻辑格式化时对整个磁盘进行坏块检查，标明哪些是坏扇区</p><p> 处理方式</p><p> 简单磁盘：手动处理，对坏块进行标记，程序不会使用</p><p> 复杂磁盘：控制器维护一个磁盘坏块链表，同时是将一些块作为备用，用于替代坏块</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-16517473449301.png" alt="文件管理"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>第三章:内存管理</title>
    <link href="https://wjjhui.github.io/2022/04/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://wjjhui.github.io/2022/04/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-04-18T11:31:50.000Z</published>
    <updated>2022-05-15T10:43:55.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1内存管理概念"><a href="#3-1内存管理概念" class="headerlink" title="3.1内存管理概念"></a>3.1内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><p>   程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾</p><p>   内存管理的功能</p><p>   1、内存空间的分配与回收：操作系统完成主存储器空间的分配和管理</p><p>   2、地址转换：逻辑地址转换为物理地址</p><p>   3、内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存</p><p>   4、内存的保护：保护各道作业在各自存储空间运行，互不干扰</p><p>   程序的装入和连接</p><p>   创建步骤</p><p>   1、编译：编译程序将用户源码编译成若干目标模块</p><p>   2、链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块</p><p>   3、装入：由装入程序将装入模块装入内存运行</p><p>   程序装入步骤</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E6%AD%A5%E9%AA%A4.jpg" alt="程序装入步骤"></p><p>   链接的类型</p><p>   1、静态链接：程序运行之前，将库函数链接成一个完整的可执行文件</p><p>   2、装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接</p><p>   3、运行时动态链接：对于某些目标模块的链接，程序需要时才会对其链接，便于修改和更新，便于实现对目标模块的共享</p><p>   装入模式</p><p>   1、绝对装入：装入时按照实际的内存地址，将程序和数据装入内存</p><p>   优点：不需要对程序和数据的地址进行修改</p><p>   缺点：只适用于单道程序环境</p><p>   2、可重定位转入（静态重定位）：此时采用的是模块与模块的相对地址，然后将程序和数据装入内存，装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，又称为静态重定位</p><p>   特点：作业装入必须要一次性全部装入，并且运行中作业不能在内存中移动，也不能申请内存空间</p><p>   3、动态运行时装入（动态重定位）：装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，当程序真正执行时才进行转换</p><p>   特点：需要重定位寄存器，可以将程序分配到不连续的存储区中，便于程序段的共享，可以想用户提供更大的地址空间</p><p>   逻辑地址空间与物理地址空间</p><p>   1、逻辑地址空间：即相对地址，链接程序一次按照各个模块的相对地址构成统一的从0号单元开始编址的逻辑空间地址</p><p>   2、物理地址空间：内存中物理单元的集和，是地址转换的最终地址，进程在运行执行指令和访问数据，最后都要通过物理地址从主存中取出（地址重定位：逻辑地址转换成物理地址的过程）</p><p>   内存保护</p><p>   1、CPU中设置上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的数据比较，判断是否越界</p><p>   2、重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）：重定位寄存器中包含最小物理地址值，解地址寄存器包含逻辑地址的最大值</p><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><p>   覆盖</p><p>   1、思想：将程序分为多个段。常用的段常驻内存，不常用的段在需要时调用内存</p><p>   2、将用户空间分为一个固定区和若干覆盖区，活跃的放在固定区，即将访问的段放在覆盖区</p><p>   3、特点：打破了必须将一个进程的全部信息装入主存后才能运行的限制，即访问的段放在覆盖区</p><p>   交换</p><p>   1、思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存和磁盘见动态调度）</p><p>   2、换出：将处于等待状态的程序从内存中转移到辅存</p><p>   3、换入：把准备好竞争CPU运行的程序从辅存转移到内存</p><p>   4、结构：把磁盘空间分为文件区和对换区两部分</p><p>   交换存在的问题</p><p>   1、备份存储，使用快速硬盘，要求存储空间足够大，并且能够对内存映像进行访问</p><p>   2、转移时间和所交换的内存空间成正比</p><p>   3、只有进程空间状态才能将进程换出</p><p>   4、交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来会很快</p><p>   5、交换通常由许多进程运行且内存吃紧时开始启动，系统负荷降低就暂停</p><p>   6、普通的交换使用不多，但交换策略的某些变体在许多系统中仍发挥作用</p><p>   注意：PCB会常驻内存，不会被换出外存</p><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><p>   单一连续分配方式</p><p>   内存分为系统区和用户区，系统区仅操作系统使用，通常在低地址部分，用户区为用户提供</p><p>   优点：无需进行内存保护，不会出现越界异常。实现简单，无外部碎片，采用覆盖技术，不需要额外技术支持</p><p>   缺点：只适用于单用户，单任务的操作系统。存在内部碎片，存储器利用率低</p><p>   固定分区分配</p><p>   种类</p><p>   1、分区大小相等：用一台计算机区控制多个相同对象的场合，缺乏灵活性</p><p>   2、分区大小不等：划分多个较小的分区，适量的中等分区和少量大分区</p><p>   优点：适用于多道程序的存储，无外部碎片</p><p>   缺点</p><p>   1、程序太大，无法放进任何一个分区</p><p>   2、主存利用考虑低，存在内部碎片</p><p>   3、不能实现多进程共享一个主存区</p><p>   动态分区分配</p><p>   在进程装入内存的时候，根据内存的大小动态建立分区</p><p>   优点：分区大小可以根据进程的实际情况进行分配</p><p>   缺点：存在外部碎片，最后导致主存利用率下降，采用紧凑技术可缓解这种缺陷</p><p>   动态分配算法</p><p>   1、首次适应算法</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/1%E3%80%81%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="1、首次适应算法"></p><p>   2、邻近适应算法</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/2%E3%80%81%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="2、邻近适应算法"></p><p>   3、最佳适应算法</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/3%E3%80%81%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="3、最佳适应算法"></p><p>   4、最坏适应算法</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/4%E3%80%81%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png" alt="4、最坏适应算法"></p><p>   非连续分配管理方式</p><p>   允许一个程序分散的装入不相邻的内存分区</p><p>   基本分页存储管理方式</p><p>   设计思想</p><p>   1、将主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位，进程以块为单位进行空间申请</p><p>   2、分页存储和固定分区技术很像，但是其分页相对于分区又很小，分页管理不会产生外部碎片，产生的内部碎片也非常的小</p><p>   分页存储的基本概念</p><p>   页面和页面大小</p><p>   1、进程中的块&#x3D;页</p><p>   2、内存中块&#x3D;框</p><p>   3、进程申请主存空间，为每个页面分配主存中可用页框，页与页框一一对应</p><p>   地址结构：页号（有多少页的编号）+页内偏移（页内存了多少东西）</p><p>   页表</p><p>   1、为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中</p><p>   2、页表项：页号+物理内存中块号</p><p>   基本地址变换机构</p><p>   基础地址变换结构图解</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%9F%BA%E7%A1%80%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3.png" alt="基础地址变换结构图解"></p><p>   计算方式</p><p>   1、页号P&#x3D;A&#x2F;L ，页内偏移量W&#x3D;A%L L：页面大小（即页内偏移量）</p><p>   2、P&gt;&#x3D;M产生越界 P：页号，页表长度：M（从1开始）</p><p>   3、页表中页号P对应的页表项地址B&#x3D;页表始址F+页号*页表项长度</p><p>   4、计算E&#x3D;B*L+W</p><p>   页表项大小的设计应当尽量一页正好装下所有的页表项</p><p>   分页管理存在的问题</p><p>   1、地址变换过程必须足够快，否则访存速率会降低</p><p>   2、页表不能太大，否则会降低内存利用率</p><p>   组成</p><p>   1、设置一个页表寄存器（RTR），存放页表在内存中的起始地址F和页表长度M</p><p>   2、页表的始址和页表长度放在进程控制块（PCB）中</p><p>   具有快表的地址变换机构</p><p>   可优化方向：如果页表放在内存中，取地址访问一次内存，按照地址取出数据访问一次内存，共需要访问两次内存</p><p>   优化：地址变化机构中增加一个具有并性查找能力的高速缓存寄存器（快表），又称相联存储器（TLB）</p><p>   访问一个逻辑地址的访存次数</p><p>   基本地址变换结构：两次访存</p><p>   具有快表的地址变换结构：一次或两次</p><p>   具有快表的地址变换结构图解</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3.png" alt="具有快表的地址变换结构图解"></p><p>   变换过程</p><p>   1、CPU给出逻辑地址后，先查询快表中是否命中</p><p>   2、若快表命中，直接从快表中该页对应的页框与页内偏移量拼接成物理地址</p><p>   3、若快表未命中，再按照正常方式从页表查询响应页表项，并将该页表项存入快表中</p><p>   两级页表</p><p>   1、逻辑地址空间格式&#x3D;一级页号+二级页号+页内偏移</p><p>   2、设计多级页表的时候，一定要保证顶级页表一定只有一个</p><p>   3、建立多级页表的目的在于建立索引，不比浪费主存空间区存储无用的页表项，也不用盲目式的查询页表项</p><p>   基本分段存储管理方式</p><p>   分段</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%88%86%E6%AE%B5.png" alt="分段"></p><p>   出发点</p><p>   分页是从计算机角度考虑设计的，目的是为了内存的利用率，提高计算机性能，分页通过计算机硬件机制实现，对用户完全透明</p><p>   分段是从用户和程序员的角度提出，满足方便编程，信息保护和共享，动态增长及动态链接等多方面的需要</p><p>   分段</p><p>   1、按照用户进程中的自然段划分逻辑空间</p><p>   2、地址结构&#x3D;段号S+段内偏移量W</p><p>   3、页式系统中，页号和页内偏移量对用户提供。段式系统中，段号和段内偏移量必须由用户显示的提供</p><p>   段表</p><p>   每个进程都有一张逻辑空间与内存空间映射的段白，这个段表项对应进程的一段，段表项记录该段在内存中的始址和长度</p><p>   段表内容&#x3D;段号+段长+本段在主存中的地址</p><p>   地址变换结构</p><p>   地址变换结构图解</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%96%B9%E5%BC%8F.png" alt="地址变换方式"></p><p>   1、逻辑地址A中取出段号S和段内偏移量W</p><p>   2、比较段号S和段表长度M 若S&gt;&#x3D;M,则A产生越界中断，否则继续执行</p><p>   3、段号S对应的段表项地址&#x3D;段表始址+段号S*段表项长度，从该段表项中取出段长 C，比较段内偏移量与C的大小判断是否越界</p><p>   4、取出段表中该段的始址B，计算E&#x3D;B+W，用得到的物理地址E区访问内存</p><p>   段的共享与保护</p><p>   1、共享：两个作用的段表中响应表项指向被共享段的同一个物理副本来实现的，纯代码或者可重入代码以及不可修改的数据都可以被共享</p><p>   2、保护机制：存取控制保护和地址越界保护</p><p>   段页式管理方式</p><p>   页式存储有效的提高利用率，分段存储能反映程序的逻辑结构并有利于段的分享，将这两种方式结合一下，这种二者结合方法经常在计算机理论中遇到</p><p>   思想</p><p>   1、作业的地址空间首先被分成若干逻辑段，每段由自己的段号</p><p>   2、每个段分成若干固定的页</p><p>   3、对内存空间的管理仍然和分页存储管理一样</p><p>   地址结构&#x3D;段号S+页号P+页内偏移量W</p><p>   为了实现地址变换，系统为每个进程建立了一张表，每个分段有一个页表。一个进程中段表只能有一个，页表有多个</p><p>   地址变换方式</p><p>   补充</p><p>   1、不能被修改的代码称为纯代码或可重入代码</p><p>   2、分段与分页的区别</p><p>   1）分页对用户不可见，分段对用户可见</p><p>   2）分页的地址空间是一维的，分段的地址空间是二维的</p><p>   3）分页（单级页表），分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</p><p>   4）分段更容易实现信息的共享和保护</p><p>   3、分段和分页的优缺点</p><p>   分页管理</p><p>   1）优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</p><p>   2）缺点：不方便按照逻辑模块实现信息的共享和保护</p><p>   分段管理</p><p>   1）优点：很方便按照逻辑模块实现信息的共享和保护</p><p>   2）缺点：如果段长过长，为其分配很大的连续空间会很不方便</p><p>   段式管理会产生外部碎片</p><h2 id="3-2虚拟内存管理"><a href="#3-2虚拟内存管理" class="headerlink" title="3.2虚拟内存管理"></a>3.2虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><p>   传统存储管理方式的特征</p><p>   1、一次性：作业必须一次性全部装入内存后，才能开始运行</p><p>   2、驻留性：作业装入内存后，一直驻留在内存中，任何部分不会被换出</p><p>   局部性原理</p><p>   时间局部性</p><p>   1、一条指令执行后，短时间内指令可能被再次执行，数据被访问后，不久后数据可能再次被访问</p><p>   2、原因：程序中存在大量的循环操作</p><p>   3、时间局部性通过将最近使用的指令和数据存储在高速缓冲存储器中</p><p>   空间局部性</p><p>   1、一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问</p><p>   2、原因：指令通常顺序存放，顺序执行的，数据一般也是以向量、数组、表等形式存储的</p><p>   3、空间局部性使用较大的高速缓存，将预取机制继承到高速缓存控制逻辑中实现</p><p>   虚拟存储器的定义和特征</p><p>   基于局部性原理，将程序的一部分装入内存，一部分留在外存，需要的时候将外存内容调入内存</p><p>   特征</p><p>   1、多次行：作业在运行时，分多次调入内存运行</p><p>   2、对换性：作业不必一直驻留在内存，允许作业在运行过程中进行换进换出</p><p>   3、虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量</p><p>   虚拟内存技术的实现</p><p>   建立在离散分配的内存管理方式上</p><p>   实现方式：</p><p>   1、请求分页存储管理</p><p>   2、请求分段存储管理</p><p>   3、请求段页式存储管理</p><p>   硬件支持</p><p>   1、一定容量的内存和外存</p><p>   2、页表机制</p><p>   3、中断机制</p><p>   4、地址表换机制</p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p>   系统建立在基本分页系统基础之上，为了支持虚拟存储器功能二增加了请求调页功能和页面置换功能</p><p>   页表机制</p><p>   1、组成：页号、物理块号、状态位P、访问字段A、修改位M、外存地址</p><p>   2、状态位：当前页是否已经调入内存</p><p>   3、访问字段A：记录本页在一段时间内被访问的次数</p><p>   4、修改位M：记录本页是否被修改过</p><p>   5、外存地址：指出该页在外存上的地址</p><p>   缺页中断机构</p><p>   当访问页面不在内存时就会产生缺页中断</p><p>   特点</p><p>   指令执行期间产生中断，而不是指令执行之后产生中断和处理中断</p><p>   一条指令在执行期间，可能产生多次缺页中断</p><p>   地址变换机构</p><p>   检索快表，找到访问页，修改页表项中的访问位，利用页表项中给出的物理块号和页内地址形成物理地址</p><p>   没用找到该页的页表项，区内存中寻找页表，看该页是否已经调入内存，没用调入则产生缺页中断，请求外存把该页调入内存</p><h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><p>   虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的</p><p>   虚拟内存的实际容量&#x3D;min（内存和外存容量之和，CPU寻址范围）</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>   1、最佳置换算法</p><p>   选择永不使用或者最长时间内不再访问的页面进行淘汰，但是现实中是无法预知的</p><p>   优点：缺页率最小、性能最好</p><p>   2、先进先出页面置换算法</p><p>   1、优先淘汰最早进入的页面</p><p>   2、优点：实现简单</p><p>   3、缺点：与进程的实际运行规律不匹配</p><p>   4、Beledy异常：增大分配的物理块数但是故障数不减反增</p><p>   3、最近最久未使用算法</p><p>   1、选择最近最长时间没用被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间</p><p>   2、优点：性能好</p><p>   3、缺点：实现复杂，需要寄存器和栈的硬件支持</p><p>   4、时钟算法</p><p>   1、像一个时钟一样转圈，每个页面设置一个使用位，遇到没有被使用的就会将页面换出，然后将使用位置0，如果遇到使用的就会将使用位置0，然后扫描下一个</p><p>   2、优点：性能接近于最佳置换算法</p><p>   3、缺点：实现复杂，开销大</p><p>   4、改进时钟算法</p><p>   （使用位，修改位），最多扫描四次</p><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p>   驻留集：给一个进程的分配的物理页框的集和就是这个进程的驻留集</p><p>   考虑因素</p><p>   1、分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，可以提高处理机的时间利用率</p><p>   2、一个进程在主存中的页数过少，页错误率就会相对较高</p><p>   3、页数过多，对进程的错误率页不会产生过多的影响</p><p>   分配策略</p><p>   1、固定分配局部置换</p><p>   1）每个进程分配固定物理块数，缺页的时候就进行换页</p><p>   2）难以确定每个进程应该分配的物理块数</p><p>   3）太多导致资源利用率下降，太少导致频繁缺页中断</p><p>   2、可变分配全局置换</p><p>   1、进程分配一定物理块，系统自身保留一定空闲物理块，如果进程缺页，就对该进程分配新的物理块</p><p>   2）优点，最容易实现，动态调整物理块分配</p><p>   3）缺点：如果盲目分配物理块，就会导致多道程序并发能力下降</p><p>   3、可变分配局部置换</p><p>   1）根据进程的缺页情况，对物理块进行动态分配，如果频繁缺页，就对其多配分物理块，如果缺页率特别低么就减少物理块</p><p>   2）优点，保持了系统的多道程序的并发能力</p><p>   3）缺点：增大了开销，实现复杂</p><p>   调入页面的实际</p><p>   预调页策略：将预计不久被访问的页面调入，成功了约为50%</p><p>   请求调页策略：当进程提出缺页的时候，再按照一定策略进行调页</p><p>   从何处调入页</p><p>   1、拥有足够的对换空间：可以全部从对换区调入所需页面，提高调页速度</p><p>   2、缺少足够的对换区间：不会被修改的文件从文件区调入，可能被修改的部分换入对换区，再从对换区调入</p><p>   3、UNIX方式：进程相关文件访问文件区，没有运行的页面从文件调入，曾经运行过但又被换出的页面放在对换区</p><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>   1、刚换出的页面又要换入内存</p><p>   2、原因</p><p>   分配的物理帧数不足（主要元婴）</p><p>   置换算法不当</p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>   某段时间内，进程要访问的页面集和</p><p>   原理</p><p>   1、操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块</p><p>   2、落入工作集的页面需要调入驻留集中，落在工作集外面的页面可以从驻留集中换出</p><p>   3、若还有空闲物理块，可以再调入一个进程到内存以增加多道程序数</p><p>   4、若所有进程的工作集之和超过了可用物理块的总数，操作系统就会暂停一个进程，并将其页面调出，然后分配给其他进程</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-16513308254251.png" alt="内存管理"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>第二章:进程管理</title>
    <link href="https://wjjhui.github.io/2022/04/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://wjjhui.github.io/2022/04/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2022-04-15T12:50:18.000Z</published>
    <updated>2022-05-15T10:42:15.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1进程与线程"><a href="#2-1进程与线程" class="headerlink" title="2.1进程与线程"></a>2.1进程与线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><p>   进程的概念</p><p>   为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性</p><p>   进程控制块（PCB）：为了更好的描述进程的基本情况和运行状态，进而控制和管理进程 [PCB是进程存在的唯一标志]</p><p>   进程的一些典型定义</p><p>   1、进程是程序一次执行过程</p><p>   2、进程是一次程序及其数据在处理机上顺序执行时所发生的活动</p><p>   3）进程是具有独立功能的程序在一个数据集合上运行的过程，是资源分配和调度的独立单位</p><p>   进程的特征</p><p>   1、动态性：动态性是进程是基本特征，引入进程有这创建、活动、暂停、终止等过程，具有生命周期（最基本的特征）</p><p>   2、并发性：多个进程实体同时存在内存中，引入进程的目的就是为了程序与其他程序并发执行</p><p>   3、独立性：进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单元</p><p>   4、异步性：每个进程都配置一个PCB对其进行描述</p><p>   1）：进程描述信息</p><p>   2）：进程控制和管理信息</p><p>   3）：资源分配清单</p><p>   4）：处理机相关信息</p><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p>   状态</p><p>   1、创建态：进程正在被创建，尚未进入就绪态</p><p>   2、就绪态：进程已处于准备运行状态</p><p>   3、运行态：进程在处理机上运行</p><p>   4、阻塞态：又称等待态，进程正在等待某个时间而暂停运行</p><p>   5、结束态：进程正在从系统中消失（包括正常结束和异常终止）</p><p>   相互转换</p><p>   1、就绪态–&gt;运行态：处于就绪态的进程获得处理机进行运行态</p><p>   2、运行态–&gt;就绪态：处于运行态的进程时间片用完后，让出处理机进入就绪态</p><p>   3、运行态–&gt;阻塞态：进程请求除处理机外的其他资源，此时运行态进入阻塞态（系统调用请求操作系统提供服务，这是一种特殊的，由运行用户态程序调用操作系统内核过程的形式）</p><p>   4、阻塞态–&gt;就绪态：进程等待其他资源的获得，如IO资源、或中断结束</p><p>   <img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="进程状态转换图"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>   进程的创建</p><p>   1、分配进程标识号，申请PCB（PCB是有限的）</p><p>   2、为进程分配资源，为程序和数据以及用户栈分配必要的内存空间</p><p>   3、初始化PCB，包括初始化标志信息，初始化处理机状态信息，初始化处理机控制信息，设置进程的优先级</p><p>   4、若进程就绪队列可以接纳新进程，进程就进入就绪态</p><p>   进程的终止</p><p>   结束分类</p><p>   1、正常结束：进程的任务已经完成并且准备推出运行</p><p>   2、异常结束：进程正在进行，出现了某些异常，导致程序无法继续运行（存储区越界、保护错、非法指令、特权指令错、IO故障等）</p><p>   3、外界干预：进程应外界请求终止运行</p><p>   结束过程</p><p>   1、根据被终止进程的标识符，检索PCB，读取进程状态</p><p>   2、若进程处于运行态，终止运行，剥夺处理机</p><p>   3、终止进程下的所有子进程</p><p>   4、该进程拥有的全部资源还给父进程或者操作系统</p><p>   5、将PCB从队列中删除</p><p>   进程的阻塞和唤醒</p><p>   阻塞原语执行过程</p><p>   阻塞是一种自主行为，自我阻塞</p><p>   1、找到要被阻塞进程标识号对应的PCB</p><p>   2、若进程处于运行态，保护其现场，将其状态转换为阻塞态，停止运行</p><p>   3、将PCB插入相应时间的等待队列</p><p>   唤醒原语的执行过程</p><p>   唤醒是被相互有联系的其他进程进行唤醒</p><p>   1、找到等待队列中进程相应的PCB</p><p>   2 、将其从等待队列中移出，置其状态为就绪态</p><p>   3、将PCB插入就绪队列，等待调度程序调度</p><p>   进程切换</p><p>   进程切换是内核态下完成的</p><p>   过程</p><p>   1、保存处理机上下文，包括程序计数器和其他寄存器</p><p>   2、更新PCB信息</p><p>   3、把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列</p><p>   3、选择另一个进程之执行，更新其PCB</p><p>   4、更新内存管理的数据结构</p><p>   5、恢复处理机上下文</p><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>   进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，由一下三部分组成</p><p>   1、进程控制块（PCB）</p><p>   1）进程描述信息</p><p>   进程标识符：标志进程 用户标识符：进程归属的用户，主要为共享和保护服务</p><p>   2）进程控制和管理信息</p><p>   进程当前状态：描述进程状态信息</p><p>   进程优先级：描述进程抢占处理机的优先级</p><p>   代码运行入口地址</p><p>   程序的外存地址</p><p>   进入内存时间</p><p>   处理机占用时间</p><p>   信号量使用</p><p>   3）资源分配清单</p><p>   用以说明有关内存地址空间或者虚拟地址空间状况，所打开的文件的列表和所使用的输入&#x2F;输出设备信息</p><p>   代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标</p><p>   4）处理机相关信息</p><p>   处理机中各寄存器的值</p><p>   2、程序段：能被进程调度程序调度到CPU执行的程序代码段</p><p>   3、数据段：进程对应的程序加工处理的原始数据或者程序执行时产生的中间或最终结果</p><p>   进程的组织方式</p><p>   1）链接方式</p><p>   按照进程状态将PCB分为多个队列 操作系统持有指向各个队列的指针</p><p>   2）索引方式</p><p>   根据进程状态的不同建立几张索引表 操作系统持有指向各个索引表的指针</p><h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3><p>   1、共享存储</p><p>   操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，数据交换则由用户自己安排读&#x2F;写指令完成</p><p>   1）通信进程之间存在一块可以被直接访问的共享空间</p><p>   2）低级方式：基于数据结构共享（只能存放长度为10的数组）</p><p>   3）高级方式：基于存储区共享</p><p>   2、消息传递</p><p>   1）进程间的数据交换是以格式化的消息为单位的，进程通过系统提供的send和receive原语进行数据交换</p><p>   2）直接通信方式：发送进程直接发送消息给接收进程，并把它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息</p><p>   3）间接通信方式：发送进程把消息发送给某个中间实体，接收进程从中间实体中获得消息</p><p>   3、管道通信</p><p>   1）发送进程以字符流形式将大量数据写入管道，接收进程从管道中接收数据</p><p>   当管道写满时，写进程堵塞，直到管道中的数据被读进程取走，即可唤醒写进程 当管道读空时，读进程堵塞，直到管道中的数据被写进程写入，即可唤醒读进程</p><p>   2）功能：互斥、同步、确定对方存在</p><p>   3）限制管道的大小</p><p>   4）管道变空的适合阻塞读进程</p><h3 id="线程的概念和多线程模型"><a href="#线程的概念和多线程模型" class="headerlink" title="线程的概念和多线程模型"></a>线程的概念和多线程模型</h3><p>   线程的基本概念</p><p>   1、减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</p><p>   2、引入线程后，进程只作为系统资源的分配单元，线程作为处理机的分配单元</p><p>   线程与进程的比较</p><p>   1、调度</p><p>   传统中进程是资源和独立调度的基本单位 引入线程后，进程是独立调度的基本单位，线程是资源的基本单位</p><p>   2、拥有资源：进程是资源分配的基本单位</p><p>   3、并发性：引入线程后，进程可以并发执行，多个线程之间也可以并发执行，提高系统的吞吐量</p><p>   4、系统开销：统一进程的线程切换要比进程切换的开销小的多</p><p>   5、地址空间和其他资源：进程的地址空间之间相互独立，统一进程的各线程之间共享进程的资源，某进程的线程对其他进程不可见</p><p>   6、通信方面：进程间通信需要进程同步和互斥手段的辅助，保证数据的一致性 线程间可以直接读&#x2F;写进程程序段来进行通信</p><p>   线程属性</p><p>   1、不拥有系统资源，拥有唯一标识符和线程控制块</p><p>   2、不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统将其创建为不同线程</p><p>   3、同一进程的线程共享该进程拥有的全部资源</p><p>   4、线程是处理机的独立调度单位</p><p>   5、线程也有生命周期，阻塞，就绪，运行等状态</p><p>   6、多CPU计算机中，各个线程可占用不同的CPU</p><p>   7、每个线程都有一个线程ID、线程控制块（TCB）</p><p>   8、切换同进程内的线程，系统开销很小</p><p>   9、切换进程，系统开销很大</p><p>   10、由于共享内存地址空间，统一进程中的线程通信甚至无需系统干预</p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>   用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到</p><p>   内核级线程：线程的管理工作全部由内核完成</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>   1、多对一</p><p>   1）经多个用户级线程映射到一个内核级线程，线程管理在用户空间完成，用户级线程对操作系统不可见</p><p>   2）优点：线程管理是用户控件进行的，效率较高</p><p>   3）缺点：一个线程阻塞全部线程都会阻塞，多个线程不能并行运行在多处理机上</p><p>   <img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="多对一线程模型"></p><p>   一对一</p><p>   1）每个用户级线程映射一个内核级线程上</p><p>   2）优点：并发能力强</p><p>   3）缺点：创建线程开销大，影响应用程序的性能</p><p>   <img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%B8%80%E5%AF%B9%E4%B8%80%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="一对一线程模型"></p><p>   多对多</p><p>n个线程映射到m个内核线程上（n&gt;m）</p><p>   既可以提高并发性，由适当的降低了开销</p><p>   <img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="多对多线程模型"></p><h2 id="2-2处理机调度"><a href="#2-2处理机调度" class="headerlink" title="2.2处理机调度"></a>2.2处理机调度</h2><h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3><p>   调度的基本概念：合理的对进程进行处理机分配</p><p>   调度的层次</p><p>   1、作业调度（高级调度）：从外存中选择作业送入内存，每个作业只调入一次，调出一次</p><p>   2、内存调度（中级调度）：提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存，使其进入挂起态。或者将已经具有运行条件的进程调入内存，修改状态为就绪态</p><p>   3、进程调度（低级调度）：按照某种策略或者方法从就绪队列中选取一个进程，将处理机分配给它（最基本的调度，频率很高）</p><p>   三级调度的关系</p><p>   1、作业调度为进程活动做准备，进程调度使进程正常活动起来，内存调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间</p><p>   2、作业调度次数少，内存调度次数略多，进程调度频率最多</p><p>   3、进程调度是最基本的，不可或缺的</p><h3 id="调度的时机、切换与过程"><a href="#调度的时机、切换与过程" class="headerlink" title="调度的时机、切换与过程"></a>调度的时机、切换与过程</h3><p>   不可切换的情况</p><p>   1、处理中断过程</p><p>   2、进程在操作系统内核程序临界区的时候</p><p>   3、其他需要完全屏蔽中断的原子操作过程</p><p>   可以切换的情况</p><p>   1、发生引起调度条件且当前进程无法继续进行</p><p>   2、中断处理结束或者自陷处理结束</p><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><p>   非剥夺调度方式</p><p>   1、如果想将处理机分配给一个优更高先级的进程，必须要等待当前占用处理机的进程释放处理机后才能将处理机分配给更高优先级进程</p><p>   2、实现简单，开销小，适合大多数批处理系统</p><p>   3、不适用于分时系统和大多数实时系统</p><p>   剥夺调度方式</p><p>   1、如果有更高级进程请求处理，暂停正在执行的进程，将处理机分配给更高级进程</p><p>   2、提高系统吞吐率和响应效率</p><h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3><p>CPU利用率：尽可能保持CPU处于忙碌状态</p><p>   系统吞吐量：单位时间内CPU完成作业的数量，调度算法和方式会对吞吐量造成较大影响</p><p>   周转时间：作业提交到作业完成的时间</p><p>   1、周转时间&#x3D;作业完成时间-作业到达时间</p><p>   2、平均周转时间&#x3D;总周转时间&#x2F;N个作业</p><p>   3、带权周转时间&#x3D;作业周转时间&#x2F;作业作业实际运行时间</p><p>   4、平均带权周转时间&#x3D;总带权周转时间&#x2F;N个作业</p><p>   等待时间：作业等待处理机的时间，衡量一个算法的优劣，只需要简单的考察等待时间</p><p>   响应时间：从用户提交请求到系统首次产生响应所用的时间</p><h3 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h3><p>   暂时调到外存等待的进程状态为挂起状态（挂起态）</p><p>   1、就绪挂起</p><p>   2、阻塞挂起</p><p>   “挂起”和”阻塞”的区别：两种状态都是暂时不能获得CPU的服务，但是挂起态是将进程映像调到外存去了，而阻塞态下进程映像还是在内存中</p><p>   七状态模型</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型"></p><h3 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h3><p>   1、先来先服务（FCFS）</p><p>   1）作业调度 进程调度</p><p>   2）先来的先分配处理机</p><p>   3）优点：算法简单对长作业有利 有利于CPU繁忙型作业（计算型）</p><p>   4）缺点：效率低 不利于短作业 不利于IO繁忙型作业</p><p>   5）不会导致饥饿</p><p>   6）非抢占式的算法</p><p>   2、短作业优先（SJF）</p><p>   1）进程调度</p><p>   2）优先选择预计运行时间最短的进程</p><p>   3）优点：平均等待时间 平均周转时间短</p><p>   4）缺点：长作业不利，造成饥饿现象，没有考虑作业的紧迫性，用户可能可以缩短作业预估时间，使得无法做到短作业优先</p><p>   5）产生”饥饿”现象。如果一直得不到服务，则称为”饿死”</p><p>   6）SJF和SPF（短进程优先算法）是非抢占式的算法，但也有抢占式的版本–最短剩余时间优先算法（SRTN）</p><p>   3、高响应比调度算法（HRRN）</p><p>   1）响应比&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</p><p>   2）等待时间相同情况下，要求服务时间越短响应比越大，有利于短作业进程</p><p>   3）要求服务时间相同，作业响应比由其等待时间决定，等待时间越长响应比越高，实现先来先服务</p><p>   4）对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长，其响应比可以升到很高，从而获得处理</p><p>   5）不会导致饥饿</p><p>   6）非抢占式的算法</p><p>FCFS、SJF、HRRN对比</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/FCFS%E3%80%81SJF%E3%80%81HRRN%E5%AF%B9%E6%AF%94.png" alt="FCFS、SJF、HRRN对比"></p><p>   这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心”响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统</p><p>   4、优先级调度算法</p><p>   1）作业调度，进程调度</p><p>   2）分类</p><p>   剥夺型：立即停止当前运行进程，将处理机分配给更高优先级进程</p><p>   非剥夺型：等待当前进程运行完成，然后将处理机分配给更高优先级进程</p><p>   3）优先级分类</p><p>   静态优先级：进程创建后无法对优先级进行修改</p><p>   动态优先级：可以根据进程运行状态，对进程优先级进行动态调整</p><p>   4）优先级设置原则</p><p>   系统进程&gt;用户进程</p><p>   交互型进程&gt;非交互型进程</p><p>​    I&#x2F;O进程&gt;计算型进程（CPU繁忙型）</p><p>   5）产生”饥饿”现象</p><p>   6）有抢占式的，也有非抢占式的</p><p>   5、时间片轮转算法</p><p>   1）使用分时系统，使用时间片，就绪进程按照到达先后排成队列，依次在时间片内占用处理机，时间片到达就释放处理机</p><p>   2）时间片的选择很重要，过大就变成先来先服务，过小就表成了短作业优先</p><p>   3）时间片影响因素：系统响应时间，就绪队列中的进程数目和系统的处理能力</p><p>   4）不会导致饥饿</p><p>   5）抢占式的算法</p><p>   6、多级反馈队列调度算法</p><p>   实现思想</p><p>   1）设置多个就绪队列，为每个队列设置不同的优先级，优先级依次递减</p><p>   2）每个队列的时间各不相同，时间片依次递增</p><p>   3）每个队列按照先来先服务原则进行进程排队，若规定时间片内没有完成，就将进程放入下一级队列</p><p>   4）只有高级队列为空的时候，低等级队列才能开始调度</p><p>   优点</p><p>   1）终端行作业用户：短作业优先</p><p>   2）短批处理作业用户：周转时间较短</p><p>   3）长批处理作业用户：讲过前面几个队列得到部分执行，不会长期得不到处理</p><p>   产生”饥饿”现象</p><p>   抢占式算法</p><p>   优先级、时间片、多级反馈算法对比</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E6%97%B6%E9%97%B4%E7%89%87%E3%80%81%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="优先级、时间片、多级反馈算法对比"></p><p>   比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）</p><h2 id="2-3进程同步"><a href="#2-3进程同步" class="headerlink" title="2.3进程同步"></a>2.3进程同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   临界资源</p><p>   一次只允许一个进程使用的资源（打印机、特殊变量、数据）</p><p>   临界资源的访问过程</p><p>   1、进入区：检查进程是否可以进入临界区</p><p>   2、临界区：可以访问临界资源的代码</p><p>   3、退出区：将正在访问临界区的标志清除</p><p>   4、剩余区：代码中的其余部分</p><p>   同步：直接制约关系，为了完成某种任务而建立的多个进程，相互合作，所以要相互通信同步 遵循的原则</p><p>   1、空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</p><p>   2、忙则等待：已有进程进入临界区后，其他试图进入临界区的进程必须等待</p><p>   3、有权等待：对于请求访问临界区的进程，在有限时间内进入临界区</p><p>   4、让权等待：进程不能进入临界区的时候，应当立即释放处理机</p><p>   互斥：间接制约关系，当一个进程访问临界资源的时候，其他进程不能访问</p><h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><p>   软件实现方法</p><p>   1、单标志法</p><p>   两个程序交替进入临界区</p><p>   优点：实现简单</p><p>   缺点：可能会违背空闲等待，造成资源无法充分利用</p><p>   单标志法实现</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt="单标志法实现"></p><p>   2、双标志先检查法</p><p>   每个进程访问临界资源前，先检查临界资源是否被访问，如果空闲才能进入</p><p>   优点：不用交替进入，可以连续使用</p><p>   缺点：两个进程可能同时进入临界区，违背忙则等待</p><p>   双标志先检查实现</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E5%AE%9E%E7%8E%B0.png" alt="双标志先检查实现"></p><p>   3、双标志后检查法</p><p>   先设置自己标志，表明自己想进入，检查对方标志，如果对方也要进入就等待，否则就进入</p><p>   优点：不会导致两个进程都进入临界区</p><p>   缺点：双方可能会互相谦让，导致饥饿</p><p>   双标志后检查实现</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E5%AE%9E%E7%8E%B0.png" alt="双标志后检查实现"></p><p>   4、Peterson算法</p><p>   防止两个进程无限期等待，在算法三的基础上增加一个标志位，从而防止饥饿</p><p>   优点：解决了饥饿现象</p><p>   缺点：算法复杂</p><p>Peterson算法实现</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/Peterson%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt="Peterson算法实现"></p><p>   硬件实现方法</p><p>   中断屏蔽法</p><p>   1、对中断进行屏蔽、关中断</p><p>   2、优点：简单、高效</p><p>   3、缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令。只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p><p>TestAndSet指令</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/TestAndSet%E6%8C%87%E4%BB%A4.png" alt="TestAndSet指令"></p><p>Swap指令</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/Swap%E6%8C%87%E4%BB%A4.png" alt="Swap指令"></p><p>   优点：适用于任意数目的进程 简单且容易验证正确性 支持进程内有多个临界区</p><p>   缺点：不能实现让全等待 可能会导致饥饿现象</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>   1、整型信号量</p><p>   不满足让权等待</p><p>   用一个整数变量作为信号量，数值表示资源数</p><p>   整型信号量实现</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/1%E3%80%81%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="1、整型信号量"></p><p>   2、记录型信号量</p><p>wait(S)、signal(S) 也可以记为 P(S)、V(S)，P( S ) —— 申请一个资源S，如果资源不够就阻塞等待。V( S ) —— 释放一个资源S，如果有进程在等待该资源，则唤醒一个进程</p><p>S.value 的初值表示系统中某种资源的数目。</p><p>S.L代表阻塞队列，进程阻塞的个数</p><p>   记录型信号量实现</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/2%E3%80%81%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="2、记录型信号量"></p><p>   3、利用信号量实现互斥</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/3%E3%80%81%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5.png" alt="3、利用信号量实现互斥"></p><p>   4、利用信号量实现同步</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/4%E3%80%81%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.png" alt="4、利用信号量实现同步"></p><p>   5、利用信号量实现前驱关系</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/5%E3%80%81%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB.png" alt="5、利用信号量实现前驱关系"></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>   信号量机制存在的问题：编写程序困难、易出错</p><p>   定义：一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程</p><p>   组成</p><p>   1、局部于管程的共享结构数据说明</p><p>   2、对该数据结构进行操作的一组过程</p><p>   3、对局部于管程的共享数据设置初始值的语句</p><p>   基本特性</p><p>   1、局部于管程数据只能被局部于管程内的过程访问</p><p>   2、一个进程只有通过调用管程内的过程才能进入管程访问共享数据</p><p>   3、每次允许一个进程在管程内执行某个内部过程</p><h2 id="2-4死锁"><a href="#2-4死锁" class="headerlink" title="2.4死锁"></a>2.4死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>   死锁的定义：多个进程因为竞争资源造成的一种僵局，没有外力作用，这些进程都无法向前继续推进</p><p>   死锁产生的原因</p><p>   1、系统资源的竞争</p><p>   2、 进程推进顺序非法</p><p>   3、死锁产生的必要条件</p><p>   1）互斥条件：进程对分配的资源进行排他性控制</p><p>   2）不可剥夺条件：进程获得资源在未使用完之前，不能被其他进程强行夺走</p><p>   3）请求并保持条件：进程已经保持了至少一个资源，提出新的资源请求，而该资源已经被其他进程占有，此时该进程被阻塞，但是自己已经获得的资源保持不放</p><p>   4）循环等待条件：你等我释放，我等你释放</p><p>   对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><p>   1、死锁预防：破坏四个必要条件中一个或多个，防止死锁</p><p>   2、避免死锁：在资源的动态分配中，用某种方法防止系统进入不安全状态，避免死锁</p><p>   3死锁的检测及解除：允许进程死锁，通过检测及时的判断死锁，然后对其进行解除</p><p>   死锁的处理策略对比图</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="死锁的处理策略对比图"></p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>   1、破坏互斥条件：某些资源只能被互斥访问，并且某些情况下必须保护互斥性</p><p>   2、破坏不剥夺条件</p><p>   释放已经占有的资源</p><p>   特点：增加系统开销，实现复杂，降低吞吐量</p><p>   用于状态易于保存和恢复的数据（CPU的寄存器和内存资源）</p><p>   3、破坏请求并保持条件：</p><p>   一次申请完所需要的全部资源</p><p>   特点：实现简单，但是资源严重浪费，可能导致饥饿</p><p>   4、破坏循环等待条件</p><p>   采用顺序资源法，对进程进行顺序推荐</p><p>   特点：进程编号必须稳定，可能会导致资源浪费，并且不利于用户编程</p><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>   系统安全状态：按照某种方式分配资源后，如果会导致死锁就是不安全状态，反之就是安全状态</p><p>   银行家算法：通过计算当前资源的不同分配方式，从而预测系统是否会进入不安全状态</p><p>   系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><p>   资源分配图：圈圈表示进程，框表示一类资源，进程到资源称为请求边，资源到进程称为分配边</p><p>   死锁定理</p><p>   1、在资源分配图中找到分配满足的进程，然后消去其请求边与分配边</p><p>   2、如果最后所有边都能被消去，则不存在死锁，反之存在死锁</p><p>   死锁解除</p><p>   1、资源剥夺法：挂起某些死锁进程，抢占资源，将这些资源分配给其他死锁进程，但是要防止挂起时间过长</p><p>   2、撤销进程法：强制撤销部分甚至全部死锁进程，并且剥夺他们的资源，撤销原则可以根据优先级和撤销进程代价进行</p><p>   3、进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺，要求系统保持进程历史信息，设置还原点</p><h3 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="死锁、饥饿、死循环的区别"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.png" alt="进程管理"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>第一章:操作系统的概述</title>
    <link href="https://wjjhui.github.io/2022/04/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://wjjhui.github.io/2022/04/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/</id>
    <published>2022-04-01T12:50:18.000Z</published>
    <updated>2022-05-15T10:44:14.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1操作系统的基本概念"><a href="#1-1操作系统的基本概念" class="headerlink" title="1.1操作系统的基本概念"></a>1.1操作系统的基本概念</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>   1、控制和管理整个计算机系统的硬件和软件资源</p><p>   2、合理地组织、调度计算机的工作与资源</p><p>   3、为用户和其他软件提供方便接口与环境的程序结合</p><p>   计算机系统的层次结构</p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo@master/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8.png" alt="操作系统的内核"></p><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p>   并发</p><p>   1、两个多个时间在统一时间间隔内发生</p><p>   2、使得系统具有处理和调度多个程序同时执行的能力</p><p>   3、操作系统的并发是通过分时实现</p><p>   注意：并发是在一时间段，并行是指在同一个时刻，并行是指操作系统具有同时执行或操作</p><p>   基本特征：并发、共享、虚拟、异步</p><p>   重要考点</p><p>   1、单核cpu同一时刻只能执行一个程序，各个程序可以并发地执行</p><p>   2、多核cpu同一时刻可以同时执行多个程序，多个程序可以并行地执行</p><p>   共享</p><p>   互斥共享方式</p><p>   1、例如打印机、磁带，同一时刻只能供一个进程对资源访问</p><p>   2、这种资源称作：临界资源或者独占资源</p><p>   同时访问方式</p><p>   1、一段时间内允许多个进程对资源进行访问</p><p>   2、典型代表：磁盘设备，重入码编写的文件</p><p>   虚拟</p><p>   1、一个物理上的实体变为若干逻辑上的对应物，这种技术也成为虚拟技术</p><p>   2、虚拟处理器：采用躲到程序并发的方式，让每个终端用户感觉到有多个处理器（时分复用技术）</p><p>   3、虚拟存储器：将物理存储变为虚拟存储器，逻辑上扩充存储器用量（空分复用技术）</p><p>   4、也可以将一台IO设备虚拟为多台逻辑上的IO设备，并允许每个用户占用一台逻辑上的IO设备</p><p>   异步</p><p>   多道程序走走停停，进程以不可预知的速度向前进</p><h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><p>   1、管理功能</p><p>   1）处理机管理：管理处理器的分配与运行，解决冲突问题，可以理解为对进程的管理 进程管理：进程控制，进程同步，进程通信，死锁处理，处理机调度</p><p>   2）存储器管理：为了提高多道程序运行效率，方便用户使用 内存分配，地址映射，内存保护，共享和内存扩充、</p><p>   3）文件管理：操作系统负责管理文件的系统称为文件系统 文件存储空间的管理，目录管理，文件读写管理和保护</p><p>   4）设备管理：完成用户的IO请求，方便用户使用设备，提高设备的利用率 缓冲管理，设备分配，设备处理，虚拟设备</p><p>   2、接口功能</p><p>   1）命令接口</p><p>   联机控制方式：交互式命令接口，适用于分时或者实时系统，就想人与机器对话一样</p><p>   脱机控制方式：又称批处理系统，提交一组作业，系统进行处理，用户不能干预作业的运行</p><p>   2）程序接口</p><p>   有一组系统调用命令组成（也称作系统调用或者广义指令）</p><p>   例如：图形用户界面（GUI）</p><p>   操作系统用作扩充机器</p><p>   1、操作系统提供了资源管理功能和方便用户使用的各种服务功能，将机器改造为功能更强的机器</p><p>   2、覆盖了软件的机器称为扩充机器，又称为虚拟机</p><p>   封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需对操作系统发出命令即可</p><h2 id="1-2操作系统的发展与分类"><a href="#1-2操作系统的发展与分类" class="headerlink" title="1.2操作系统的发展与分类"></a>1.2操作系统的发展与分类</h2><h3 id="1、手工操作阶段"><a href="#1、手工操作阶段" class="headerlink" title="1、手工操作阶段"></a>1、手工操作阶段</h3><p>   程序的装入，运行，结果的输出都需要人为的干预</p><p>   缺点：资源利用率低，cpu利用不充分</p><h3 id="2、批处理阶段"><a href="#2、批处理阶段" class="headerlink" title="2、批处理阶段"></a>2、批处理阶段</h3><p>   为了解决人机矛盾以及cpu和IO设备之间速度不匹配的矛盾</p><p>   单道批处理系统</p><p>   内存中始终保存一道作业，作业成批执行</p><p>   特点</p><p>   自动性：一批作业自动执行不需要人工干预</p><p>   顺序性：各道作业依次执行</p><p>   单道性：仅有一道程序执行</p><p>   多道批处理系统</p><p>   允许多个程序在cpu中交替运行，程序共享各种硬件和软件资源</p><p>   特点</p><p>   多道：计算机中同时存放多道相互独立的程序</p><p>   宏观上并行：多道程序都会开始运行，但都没有运行完毕</p><p>   微观上串行：多道程序轮流占用cpu，交替执行</p><p>   优点</p><p>   资源利用率高</p><p>   多道程序并发执行，共享计算机资源</p><p>cpu和其他资源更保持”忙碌”状态，系统吞吐量增大</p><p>   缺点</p><p>   设计复杂，要考虑各种资源调度问题</p><p>   响应时间过长，没有人机交互功能</p><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>   将处理器运行时间划分时间片，将时间片分配给不同作业&#x2F;用户从而占用处理机</p><p>   特点</p><p>   1、同时性：允许多个终端用户使用同一台计算机</p><p>   2、交互性：方便进行人机对话，用户采用人机对话方式控制程序运行</p><p>   3、独立性：多个用户彼此之间独立的操作，互不干扰</p><p>   4、及时性：用户请求能在很短时间内获得响应</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>   保证在规定时间内完成某项任务</p><p>   特点</p><pre><code>   1、及时性：规定时间内完成规定任务      2、可靠性：输出的结果正确，系统运行时确保稳定</code></pre><h3 id="分布式计算机系统"><a href="#分布式计算机系统" class="headerlink" title="分布式计算机系统"></a>分布式计算机系统</h3><p>   网络操作系统将多个计算机有机的结合在一起</p><p>   任意两台计算机之间没有主从之分，互相交换信息，并行工作，协同完成</p><h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3><p>   广泛应用于文字处理，电子表格，游戏</p><h2 id="1-3操作系统的运行环境"><a href="#1-3操作系统的运行环境" class="headerlink" title="1.3操作系统的运行环境"></a>1.3操作系统的运行环境</h2><p>程序运行：程序运行的过程其实就是cpu执行一条一条的机器指令的过程</p><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h3><p>cpu的两种性质程序</p><p>   操作系统内核程序</p><p>   用户自编程序</p><p>   内核</p><p>   1、时钟管理：操作系统对用户提供标准时间，根据时钟对进程进行管理，实现进程切换</p><p>   2、中断机制：初衷是为了提高多道程序运行环境中的cpu利用率，保护和恢复中断现场的信息，转移控制权到相关程序</p><p>   原语</p><p>   1、处于系统的最底层，最接近硬件</p><p>   2、运行具有原子性，即只能一气呵成</p><p>   3、系统控制的数据结构及处理</p><p>​     1）进程管理：进程状态管理、进程调度和分派、创建和撤销进程控制</p><p>​     2）存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序</p><p>​     3）设备管理：缓冲区管理、设备分配和回收</p><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><p>   为了进行和心态和用户态两种状态的切换，引入了中断机制</p><p>   1、核心态可以执行用户态无法执行的特权指令</p><p>   2、访管指令是在用户态使用，将用户态转换为核心态，所以访管指令不是特权指令</p><p>   “中断”是让操作系统内核夺回cpu使用权的唯一途径</p><p>   中断（外中断）</p><p>   1、来自于cpu指令之外的事件发生</p><p>   2、I&#x2F;O中断：输入输出已经完成</p><p>   3、时钟中断：固定时间片已到，让处理及处理</p><p>   异常（内中断）</p><p>   1、源自于cpu执行指令内部内部的事件</p><p>   2、非法操作码，除零，地址越界，算数溢出</p><p>   3、陷入指令：用户自行设置，执行陷入后，用户态转换为核心态</p><p>   4、异常不能被屏蔽</p><p>   系统调用</p><p>   1、用户在程序中调用操作系统提供的一些子功能</p><p>   2、设备功能：完成设备的请求或者释放，设备启动等功能</p><p>   3、文件管理：完成文件的读、写、创建以及删除功能</p><p>   4、进程控制：完成进程的创建、撤销、阻塞以及唤醒功能</p><p>   5、进程通信：完成进程之间的消息传递和信号传递功能</p><p>   6、内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</p><h3 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h3><p>cpu中有几个寄存器叫程序状态寄存器（psw） 1为”内核态”，0为”用户态”</p><p>   1、处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p><p>   2、处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p><h3 id="内核态、用户态的切换"><a href="#内核态、用户态的切换" class="headerlink" title="内核态、用户态的切换"></a>内核态、用户态的切换</h3><p>   1、内核态–》用户态：执行一条特权指令——修改psw的标志位为”用户态”，这个动做意味着操作系统将主动让出cpy使用权</p><p>   2、用户态–》内核态：由”中断”引发，硬件自动完成变态过程，出发中断信号意味着操作系统将强行夺回cpu的使用权</p><h2 id="1-4大内核与微内核"><a href="#1-4大内核与微内核" class="headerlink" title="1.4大内核与微内核"></a>1.4大内核与微内核</h2><h3 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h3><p>   1、将操作系统的主要功能模块进行集中，从而用以提高性能的系统服务</p><p>   2、优点：各个管理模块之间共享信息，能够有效利用相互之间的有效特性，所有有着巨大的性能优势</p><p>   3、缺点：层次交互关系复杂，层次接口难以定义没层次之间界限模糊</p><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>   1、背景：随着计算机体系结构的不断发展，操作系统提供的服务越来越多，接口形式越来越复杂</p><p>   2、将内核中最基本的功能保留在内核，将不需要在核心态执行的功能转移到用户执行，降低内核设计的复杂性</p><p>   3、优点：有效的分离内核与服务、服务与服务、使得他们之间的接口更加的清晰，维护的代价大大降低 各部分可以独立的优化和演进</p><p>   4、优点：性能问题，需要频繁的在核心态和用户态之间进行切换</p><h3 id="大内核与微内核"><a href="#大内核与微内核" class="headerlink" title="大内核与微内核"></a>大内核与微内核</h3><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo@master/img/%E5%A4%A7%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8.png" alt="大内核与微内核"></p><p><img src="https://cdn.jsdelivr.net/gh/Wjjhui/picodemo/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0.png" alt="操作系统的概述"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
