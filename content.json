{"meta":{"title":"秃哦鸡","subtitle":"","description":"efficiency comes from diligence","author":"wjjhui","url":"https://wjjhui.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-04-07T12:57:12.150Z","updated":"2022-04-03T05:42:13.817Z","comments":false,"path":"/404.html","permalink":"https://wjjhui.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-03T16:16:36.497Z","updated":"2022-05-03T16:16:36.497Z","comments":false,"path":"categories/index.html","permalink":"https://wjjhui.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-07T12:57:12.153Z","updated":"2022-04-05T06:41:18.679Z","comments":false,"path":"about/index.html","permalink":"https://wjjhui.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-04-07T12:57:12.157Z","updated":"2022-04-03T05:42:13.818Z","comments":false,"path":"books/index.html","permalink":"https://wjjhui.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-11T07:34:16.000Z","updated":"2022-05-04T13:05:59.299Z","comments":true,"path":"links/index.html","permalink":"https://wjjhui.github.io/links/index.html","excerpt":"","text":"申请要求：1、内容持续更新且可以稳定访问 2、网页整洁无繁杂广告推广 3、博客主页被百度或谷歌等搜索引擎收录 4、头像能够快速加载 5、拥有独立域名 友链声明：1、本站会定期清理无法访问的友链，如果更换了链接信息请至评论区留言，谢谢合作！ 2、本站会定期查看双方是否互为友链，如果取消本站友链，本站也会将您的友链移除 申请方式：先将本站的友链添加到您的友链，相关信息如下 然后按照以下格式在本站留言区留言，待博主为您添上友链"},{"title":"分类","date":"2022-05-03T16:15:24.203Z","updated":"2022-05-03T16:15:24.203Z","comments":true,"path":"tags/index.html","permalink":"https://wjjhui.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-07T12:57:12.170Z","updated":"2022-04-03T05:42:13.819Z","comments":false,"path":"repository/index.html","permalink":"https://wjjhui.github.io/repository/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-05T06:39:28.000Z","updated":"2022-04-05T06:39:28.254Z","comments":true,"path":"about/index-1.html","permalink":"https://wjjhui.github.io/about/index-1.html","excerpt":"","text":""}],"posts":[{"title":"深度学习环境配置","slug":"深度学习环境配置","date":"2023-06-08T10:50:18.000Z","updated":"2023-06-08T11:18:10.144Z","comments":true,"path":"2023/06/08/深度学习环境配置/","link":"","permalink":"https://wjjhui.github.io/2023/06/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"学习环境配置入门深度学习，首先要做的事情就是要搭建深度学习的环境。不管你是Windows用户，Mac用户还是Ubuntu用户，只要电脑配置允许，都可以做深度学习，毕竟Windows、Mac和Ubuntu系统都可以进行深度学习环境的搭建。接下来就记录下自己在Windows系统上搭建深度学习环境的过程，方便自己存档也为大家提供一个参考。本次环境配置主要模式是基于Minianaconda+CUDA+cuDNN+PyTorch(GPU版)进行搭建的。 工具Python集成开发环境：MinianacondaCUDA、cuDNN：英伟达提供的针对英伟达显卡的运算平台。用来提升神经网络的运行效率，如果电脑显卡不满足要求也是可以不用安装，使用cpu来进行运算。开发工具：PyCharm深度学习库：PyTorch（也可以使用Google开源的TensorFlow平台，不过一般学术界多用PyTorch平台。） 一、安装Minianacondaminianaconda官网下载 清华大学开源镜像下载 两个网站都可以下载，选择适合自己电脑的版本下载即可。 安装之后会自动配置环境变量，检查是否安装成功即可。 1.查看conda版本 conda --version 2.创建新的虚拟环境 conda create --name dl2 3.激活conda虚拟环境 activate dl2 4.关闭虚拟环境 deactivate 5.查看已创建环境 conda info -e或conda env list 6.删除环境 conda remove --name &lt;env_name&gt; --all 7.复制环境 conda create --name &lt;new_env_name&gt; --clone &lt;old_evn_name&gt; 8.查看当前环境已安装的包 conda list 9.卸载当前环境的包 conda remove &lt;package_name&gt; 二、安装CUDA首先安装NVDIA显卡驱动，NVIDIA官网 安装完NVIDIA以后我们还需要安装CUDA以及cuDNN，这两个是NVIDIA官方给出的便于深度学习计算的补丁 CUDA的安装之前我们先要看看相适配的版本，桌面空白处右键，打开NVIDIA控制面板，依次点击帮助-系统信息，在弹出的界面中选择组件: 在第三行我们可以看出我这台电脑要安装cuda11.6的版本，我们去下载cuda不可以高于这个版本，最好也别过低。 CUDA官网 下载完之后存放CUDA的文件夹会自动消失，后面可以从C盘找到相对应的路径。 三、安装cuDNNcuDNN官网 下载的时候注意版号，一定要让cudnn和cuda的版号完全一样才可以。下载好之后打开cudnn的压缩包，再打开cuda的目录（目录在图里）： 可以看到cudnn有三个文件夹，把这些文件夹中的东西放入C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.6下 至此cuda+cudnn就安装完成了，我们打开anaconda prompt，输入nvcc -V来看看cuda信息： 四：安装PyTorch(GPU版)1.激活conda虚拟环境 activate dl2 安装pytorch：conda install pytorch 此命令会安装基于CPU版本的pytorch 正确安装方法 进入PyTorch官网,选择相关的电脑配置，然后进入虚拟环境运行，加上镜像源 镜像源：-i https://opsx.alibaba.com/mirror-i https://pypi.tuna.tsinghua.edu.cn/simple 检查是否安装成功 python import torch torch.__version__ //注意version前后是两个下划线 torch.cuda.is_available() 此时，深度学习环境配置完成。","categories":[],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://wjjhui.github.io/tags/DeepLearning/"}]},{"title":"机器学习吴恩达","slug":"机器学习吴恩达","date":"2023-06-05T02:25:40.000Z","updated":"2023-06-05T14:08:11.936Z","comments":false,"path":"2023/06/05/机器学习吴恩达/","link":"","permalink":"https://wjjhui.github.io/2023/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE/","excerpt":"","text":"机器学习","categories":[{"name":"机器器学习","slug":"机器器学习","permalink":"https://wjjhui.github.io/categories/%E6%9C%BA%E5%99%A8%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wjjhui.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"第八章:排序","slug":"第八章：排序","date":"2022-07-03T02:25:40.000Z","updated":"2022-07-04T10:10:25.818Z","comments":false,"path":"2022/07/03/第八章：排序/","link":"","permalink":"https://wjjhui.github.io/2022/07/03/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序的基本概念排序:就是重新排列表中的数据，使表中的元素满足按关键字有序的过程 基本类型 插入排序 交换排序 选择排序 归并排序 基数排序 插入排序基本思想：每次将一个待排序的记录按其关键字大小插入到前面已排好的子序列中，直到全部记录插入完成 引申出的算法： 直接插入排序 折半插入排序 希尔排序 直接插入排序将一个待排序的记录用顺序查找的方式找到应当插入的位置，然后插入 空间复杂度：O（1） 时间复杂度：O（n^2） 稳定算法 适用于顺序存储和链式存储 1234567891011//直接插入排序void InsertSort(int A[],int n)&#123; int i,j,temp; for(i=1;i&lt;n;i++) //将个元素插入已排好的序列中 if(A[i]&lt;A[i-1])&#123; //若A[i]小于前面的 temp=A[i]; //将A[i]暂存 for(j=i-1;j&gt;0 &amp;&amp; A[j]&gt;temp;--j)//找到A[i]应当放的位置 A[j+1]=A[j]; //所有大于A[i]的元素后移 A[j+1]=temp; //将temp插入 &#125;&#125; 1234567891011//直接插入排序带哨兵void InsertSort(int A[],int n)&#123; int i,j; for(i=2;i&lt;n;i++) //依次将A[2]-A[n]插入 if(A[i]&lt;A[i-1])&#123; //若A[i]小于前面的 A[0]=A[i]; //将A[i]暂存A[0]作为哨兵 for(j=i-1; A[j]&gt;A[0];--j)//找到A[0]应当放的位置 A[j+1]=A[j]; //所有大于A[0]的元素后移 A[j+1]=A[0]; //将A[0]插入 &#125;&#125; 折半插入排序将一个待排序的记录用折半查找的方式找到应当插入的位置，然后插入 空间复杂度：O（1） 时间复杂度：O（n^2） 稳定算法 适用于顺序存储 1234567891011121314151617void InsertSort(int A[],int n)&#123; int i,j,low,high,mid; for(i=2;i&lt;n;i++)&#123; //依次将A[2]-A[n]插入 A[0]=A[i]; //将A[i]暂存A[0]作为哨兵 low=1,high=i-1; while(low&lt;=high)&#123; mid=(low+gihg)/2; if(A[mid]&gt;A[0]) high=mid-1; //查找左边 else low=mid+1； //查找右边 &#125; for(j=i-1;j&gt;high+1;--j) A[j+1]=A[j]; //统一后移 A[high+1]=A[0]; //插入 &#125; &#125; 希尔排序先将表中元素部分有序，在全局有序。假设增量d，对子表进行直接插入排序，再缩小d进行直接插入排序，直到d为1进行直接插入排序 空间复杂度：O（1） 时间复杂度：O（n^2） 不稳定算法 适用于顺序算法 1234567891011void ShellSort(int A[],int n)&#123; int d,i,j; for(d=n/2;d&gt;=1;d=d/2) //步长变化 for(i=d+1;i&lt;=n;++i) if(A[i]&lt;A[i-d])&#123; //将A[i]插入有序子表 A[0]=A[i]; //暂存A[0] for(j=i-d;j&gt;0 &amp;&amp;A[0]&lt;A[j];j-=d) A[j+d]=A[j];//记录后移，查找插入位置 A[j+d]=A[0]; //插入 &#125;&#125; 交换排序冒泡排序 从后往前（从前往后）两两比较相邻元素的值，若为逆序，则交换他们，直到序列比较完 将最小的元素交换到待排序的第一个位置 进行下一趟冒泡时，前面确定的最小元素不参与比较，每趟冒泡的结果都是把序列中最小的元素放到了序列的最初位置 如果某一趟为发生交换，则算法结束 空间复杂度：O（1） 时间复杂度：O（n^2） 稳定算法 适用于顺序存储和链式存储 1234567891011121314151617181920//交换void swap(int &amp;a.int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;//冒泡排序void BubbleSort(int A[],int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; bool falg=false; //本轮排序是否发生交换 for(int j=n-1;j&gt;i;j--) //一轮冒泡排序 if(A[j-1]&gt;A[j])&#123; //交换 swap(A[j-1],A[j]); flag=true &#125; if(falg==false) return ; //没有发生交换，说明有序 &#125;&#125; 快速排序快速排序是基于比较的内部排序方法中最好的方法 首先选取一个元素作为基准，然后以基准作为分界分为两个部分，左边的小于基准，右边的大于基准 对左右两个子序列递归的进行上述步骤 空间复杂度：O（nlog2(n)） 时间复杂度：O（nlog2(n)） 不稳定算法 适用于顺序存储 1234567891011121314151617181920//用第一个元素将待排序序列划分成左右两个部分int Partition(int A[],int low,int high)&#123; int pivot=A[low]; //第一个元素作为基准 while(low&lt;high)&#123; //用low、high搜索基准的最终位置 while(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high; A[low]=A[high]; //比基准小的元素放左边 while(low&lt;high &amp;&amp; A[low]&gt;=pivot) ++low; A[high]=A[low]; //比基准大的元素放右边 &#125; A[low]=pivot; //基准元素存放最终位置 return low; //返回基准元素的位置&#125;//快速排序void QickSort(int A[],int low,int high)&#123; if(low&lt;high)&#123; int pivotops=Partition(A,low,high); QickSort(A.low,pivotops-1); QickSort(A.pivotops+1,high); &#125;&#125; 快排的优化 1）选取头、中、尾三个位置的元素，取中间值作为基准元素 2）随机选一个元素作为基准元素 选择排序简单选择排序 将表分为两个部分、有序部分和无序部分 每次从无序部分选取最小的元素，然后将其放入有序部分中 空间复杂度：O（1） 时间复杂度：O（n^2） 不稳定算法 适用于顺序存储 12345678void SelectSort(int A[],int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; //一共进行n-1趟 int min=i; //记录最小元素位置 for(int j=n+1;j&lt;n;j++) //在A[i~n-1]选择最小的元素 if(A[j]&lt;A[min]) min=j;//更新最小元素位置 if(min!=i) swap(A[i],A[min])//最小元素放最前面 &#125;&#125; 堆排序大根堆：父节点的值大于孩子结点的值 小根堆：父节点的值小于孩子结点的值 建堆：按照大根堆的规则建立起相应的二叉树，那么根结点一定是最大值 调整堆：当根结点输出后，整颗二叉树可能被破坏，这是要根据相应的建堆规则，自底向上，从左往右，进行父节点与子节点的交换 空间复杂度：O（1） 时间复杂度：O（nlog2（n）） 不稳定算法 1234567891011121314151617181920212223242526272829//建立大根堆void BuildMaxHeap(int A [],int len)&#123; for(int i=len/2;i&gt;0;i--) //从后往前调整所有非终端结点 HeadAdjust(A,i,len);&#125;//将以k为根的子树调整为大根堆void HeadAdjust(int A[],int k,int len)&#123; A[0]=A[k]; //A[0]暂存根节点 for(int i=2*k,i&lt;len;i*=2)&#123; //沿着key较大的子节点向下筛选 if(i&lt;len &amp;&amp; A[i]&lt;A[i+1])//取key较大的子节点的下标 i++; if(A[0]&gt;A[i]) break; else&#123; A[k]=A[i]; //将A[i]调整到双亲结点上 k=i; //修改k值 &#125; &#125; A[k]=A[0]; //被赛选的结点的值放入最终位置&#125;//堆排序的完整逻辑void HeadSort(int A[],int len)&#123; BuildMaxHeap(A,len);//建堆 for(int i=len;i&gt;1;i--)&#123;//调整堆 swap(A[i],A[1]); HeadAdjust(A,1,i-1); &#125; &#125; 归并排序每次选定相应的元素分别合成一个新的有序表（2路归并&#x2F;多路归并） 时间复杂度：O（nlog2（n）） 空间复杂度：O（n） 稳定算法 适用于顺序表 12345678910111213141516int *B=(int *)malloc(n*sizeof(int));//辅助数组B//A[low,mid]和A[mid+1,high]各自有序void Merge(int A[],int low,int mid;int high)&#123; int i,j,k; for(k=low;k&lt;=high;k++) B[k]=A[k]; for(i=low;j=mid+1,k=i;i&lt;mid &amp;&amp; j&lt;high ;k++)&#123; if(B[i]&lt;=B[j]) A[k]=B[i++]; else A[k]=B[j++]; &#125; while(i&lt;=mid) A[k++]=B[i++]; while(j&lt;=mid) A[k++]=B[j++];&#125; 基数排序按关键字位权重递减（递增）逐层划分成若干个更小的子序列，最后将所有子序列依次连接成一个有序的序列 d：将整个关键拆分为d组，r：关键字位可能取得r个值 时间复杂度：O（d（n+1）） 空间复杂度：O（r） 稳定算法 按“个位”进行分配——&gt;收集——&gt;“十位”进行分配——&gt;收集——&gt;”百位“进行分配——&gt;收集","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第七章:查找","slug":"第七章：查找","date":"2022-06-29T10:30:51.000Z","updated":"2022-07-02T03:40:10.673Z","comments":false,"path":"2022/06/29/第七章：查找/","link":"","permalink":"https://wjjhui.github.io/2022/06/29/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序查找又称为线性查找。对顺序表和链表都适用。 一般线性表的顺序查找基本思想 从线性表的一端开始，逐个检查关键字是否满足给定的条件 若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置 若已经查找到表的另一端。但还没有查找到符合给定条件的元素，则返回查找失败的信息 123456789101112typedef struct&#123; int *elem; int TableLen; //表长&#125;SSTable;//顺序查找int Search_Seq(SSTable ST,int key)&#123; int i; for(i=0;i&lt;ST.TableLen &amp;&amp; ST.elem[i]!=key;i++); //查找成功，返回下标，否则返回-1 return i==ST.TableLen?-1:i;&#125; ASL（成功）&#x3D;（n+1）&#x2F;2 ASL（失败）&#x3D;n+1 缺点 当n较大时，平均查找长度较大，效率低 优点 对数据元素的存储没有要求，顺序存储和链式存储都可以 对表中记录的有序性也没有要求，无论记录是否按关键字有序 有序表的顺序查找基本思想 假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key 当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，这时返回查找失败 因为第i个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的关键字 ASL（成功）&#x3D;（n+1）&#x2F;2 ASL（失败）&#x3D;n&#x2F;2+n&#x2F;（n+1） 二分查找又称折半查找，适用于有序的顺序表 基本思想 首先将key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置 若不等，则所需查找的元素只能在中间元素意外的前半部分或后半部分 然后在缩小的范围进行同样的查找，如此重复，直到找到为止 或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息 1234567891011121314151617typedef struct&#123; int *elem; int TableLen;&#125;SSTable;int Binart_Searcg(SSTable L,int key)&#123; int low=0,high=L.TableLen-1,mid; while(low&lt;=high)&#123; mid=(low+high)/2; if(L.elem[mid]==key) return mid; else if(L.elem[i]&gt;key) high=mid-1; else low=mid+1; &#125; return -1;&#125; 树高h&#x3D;log2（n+1） 分块查找又称索引顺序查找，吸取了顺序查找和折半查找各自的优点 基本思想 将查找元素分为若干块 块内的元素可以无序，但块之间有序，第一个块中的最大关键字小于第个块中的所有记录的关键字 再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中第一个元素的地址，索引表按关键字排序 折半查找+顺序查找：ASL&#x3D;L1+L2&#x3D;log2（b+1） + （s+1）&#x2F;2 顺序查找+顺序查找：ASL&#x3D;L1+L2&#x3D;（b+1）&#x2F;2 + （s+1）&#x2F;2 s&#x3D;根号n，则平均查找长度最小 二叉排序树（BST树）又称二叉查找树，左子树结点值 &lt; 跟节点值 &lt; 右节点值 二叉排序树的查找 12345678910BSTNode *BSTSearch(BSTree T,int key)&#123; if(T==NULL) return NULL; if(key==T-&gt;key) return T; else if(key&lt;T-&gt;key) return BSTSreach(T-&gt;lchild,key); else return BSTSreach(T-&gt;rchild,key);&#125; 二叉排序树的插入 二叉排序树的构造 二叉排序树的删除结点z的直接后继（直接前驱代替z） 平衡二叉树（AVL树）简称平衡树，树上任一结点的左子树和右子树的高度之差不超过1 调整最小不平衡子树A LL：A的左孩子右上旋 RR：A的右孩子左上旋 LR：A的左孩子的右孩子 先左后右旋 RL：A的右孩子的左孩子 先右后左旋 平均查找长度&#x2F;查找的时间复杂度：log2（n） 红黑树（RBT) 左根右、根叶黑、不红红、黑路同","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第六章:图","slug":"第六章：图","date":"2022-06-23T15:00:42.000Z","updated":"2022-06-28T08:25:29.465Z","comments":false,"path":"2022/06/23/第六章：图/","link":"","permalink":"https://wjjhui.github.io/2022/06/23/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE/","excerpt":"","text":"图的基本概念图的定义：图G由顶点集V和边集E组成,记为G&#x3D;(V，E ) ,其中V(G)表示图G中顶点的有限非空集:E( G )表示图G中顶点之间的关系(边)集合 注意！：线性表可以是空表，树可以是空树，图不能是空图 简单图：不存在重复边，不存在顶点到自身的边 多重图：若图中某两个结点之间的边数多于一条，有允许顶点通过同一条边和自己关联，则G为多重图 子图：设有两个图G&#x3D;(VE)和G’&#x3D;(VE’),若V是V的子集,且E是E的子集,则称G’是G的子图。若有满足V(G’)&#x3D;V(G)的子图G，则称其为G的生成子图 连通、连通图和连通分量： 在无向图中，若顶点b到顶点w有路径存在，则称v和w是连通的 若图G中任意两个顶点都是连通，即有路径即可，则称图G为连通图 无向图中的极大连通子图称为连通分量 若一个图G有n个顶点且变数小于n-1，则G必为非连通图 强连通图、强连通分量 强连通图：在有向图G中，任意一对顶点之间存在相互通路的路径 强连通分量：有向图中的极大强连通图 无向完全图：无向图中任意两个顶点都存在边（） 有向完全图：有向图中任意两个顶点之间存在方向相反的两条弧&lt;&gt; 图的存储和基本操作邻接矩阵法用一个一维数组存储图顶点中的信息，用一个二位数组存储图中边的信息（即各顶点之间的邻接关系） 存储顶点之间邻接关系的二位数组称为邻接矩阵，在无向图中可以通过矩阵压缩。 优点： 直观，简单，方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一节点的 “度” （从该点出发的边数为“出度”，指向该点的边数为“入度” 无向图：对应行（列）的非0元素的个数 有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度” 缺点： 浪费空间—存储稀疏的时候，有大量无效元素，但是如果稠密的话，就不会有这个问题 浪费时间—统计稀疏图中一共有多少边 空间复杂度为O（n^2） 邻接表法对于稀疏图使用邻接矩阵法要浪费大量的存储空间，邻接表法了结合了顺序存储和链式存储。类似于树的孩子表示法。 对于图G中的每个顶点建立一个链表，链表中的结点表示依附于顶点 边表和头指针和顶点的数据信息采用顺序存储（顶点表） 特点： 若G为无向图，则所需的存储空间为O（|v|+2|E|）,若G为有向图，则所需的存储空间为O（|v|+|E|） 对于稀疏图，采用邻接表法可以大量的节省存储空间 在无向图的邻接表中，给定一顶点，能很容易的找出它的所有邻边 在有向图的邻接表中，求一个给定顶点的出度只需要计算其邻接表中的结点个数，但求其顶点的入度则需要遍历全部的邻接表 图的邻接表表示并不唯一 十字链表法（有向图） 邻接多重表法（无向图） 图的基本操作AdjacentG（G，x，y）：判断图G是否存在边&lt;x，y&gt;或（x，y） Neihbors（G，x）：列出图G中与x邻接的边 InsertVertex（G，x）：在图G中插入顶点x DeleteVertex（G，x）：从图中删除顶点x AddEdge（G，x，y）：若无向边（x，y）或有向边&lt;x，y&gt;不存在，则向图中添加该边 RemoveEdge（G，x，y）：若无向边（x，y）或有向边&lt;x，y&gt;存在，则从图G中删除该边 FirstNeighbor（G，x）：求图G中顶点x的第一个邻接点 NextNeighbor（G，x，y）：求图G中除y之外顶点x的下一个邻接点的定点号 Get_egde_value(G，x，y)：获取图G中边（x，y）或&lt;x，y&gt;对应的权值 Set_egde_value(G，x，y)：设置图G中边（x，y）或&lt;x，y&gt;对应的权值 图的遍历算法广度优先遍历（BFS） 邻接矩阵存储图的时间复杂度为：O（V^2） 邻接表存储图的时间复杂度为：O（V+E） 空间复杂为：O（V） 1234567891011121314151617181920212223242526bool visited[MAX_VERTEX_NUM]; //访问标记数组//对图进行遍历，初始值标记全部为false，遍历过标记为true//对于每个连通分量调用一次BFSvoid BFSTraverse(Graph G)&#123; for(i=0;i&lt;G.vexnum;++i) visited[i]=FALSE; InitQueue(Q); for(i=0;i&lt;G.vexnum;++i) if(!visited[i]) BFS(G,i)&#125;void BFS(Graph G,int v)&#123; //从顶点v出发，广度优先遍历图G visit(v); //访问初始顶点v visited[v]=TRUE; //对v做已访问的标记 Enqueue(Q,v); //顶点v入队列Q while(!isEmpty(Q))&#123; DeQueue(Q,v); //顶点v出队 for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w])&#123; //w为v的尚未访问的邻接顶点 visit(w); //访问顶点w visited[w]=True;//对w标记 EnQueue(Q,w) //顶点w入队 &#125; &#125;&#125; 深度优先遍历（DFS） 邻接矩阵存储图的时间复杂度为：O（V^2） 邻接表存储图的时间复杂度为：O（V+E） 空间复杂为：O（V） 12345678910111213141516171819202122bool visited[MAX_VERTEX_NUM]; //访问标记数组//对图进行遍历，初始值标记全部为false，遍历过标记为true//对于每个连通分量调用一次BFSvoid DFSTraverse(Graph G)&#123; for(i=0;i&lt;G.vexnum;++i) visited[i]=FALSE; InitQueue(Q); for(i=0;i&lt;G.vexnum;++i) if(!visited[i]) DFS(G,i)&#125;void DFS(Graph G,int v)&#123; //从顶点v出发，广度优先遍历图G visit(v); //访问初始顶点v visited[v]=TRUE; //对v做已访问的标记 while(!isEmpty(Q))&#123; DeQueue(Q,v); //顶点v出队 for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w]) DFS(G,w) &#125;&#125; 图的应用最小生成树Prim算法（从顶点出发） 从一个顶点开始构建生成树，每次讲代价最小的新顶点纳入生成树，直到所有顶点都纳入为止 时间复杂度为：O（V^2） Kruskal算法（从边出发） 每次选择一条权值最小的边，使这条边的两头连通（原来已经连通的就不选），直到所有结点都连通 时间复杂度为：O（Elog2E） 最短路径BFS广度优先算法（无权图）12345678910111213141516171819202122bool visited[MAX_VERTEX_NUM]; //访问标记数组//求顶点u到其他顶点的最短路径void BFS_MIN_Distance(Graph G,int u)&#123; for(i=0;i&lt;G.vexnum;++i)&#123; d[i]=+00; //路径前驱 path[i]=-1; &#125; d[u]=0; visited[v]=TRUE; //对v做已访问的标记 Enqueue(Q,v); //顶点v入队列Q while(!isEmpty(Q))&#123; DeQueue(Q,v); //顶点v出队 for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w])&#123; //w为v的尚未访问的邻接顶点 d[w]=d[u]+1; path[w]=u; visited[w]=True;//对w标记 EnQueue(Q,w) //顶点w入队 &#125; &#125;&#125; Dijkstra算法 初始化：集和S初始为{0}，dist[]初始值为与顶点v0的路径长度，path[]初始值为路径上的前驱。 从顶点集S选出路径长度最短的顶点v 修改从v出发到集和上其他顶点可达的路径长度，比当前长度短则修改dist长度并将前驱修改为v 重复2-3操作n-1次，直到多有顶点都包含在S中 注意！:不适用于权值存在负数的情况 Floyd算法求每一对顶点之间的最短路径 使用动态规划思想，将问题的求解分为多个阶段 初始：不允许存在其他顶点中转，最短路径是？ 若允许v0中转，最短路径是？ 若允许v0，v1中转，最短路径是？ …… 若允许v0，v1，v2，v3……vn-1中转，最短路径是？","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第五章:树","slug":"第五章：树","date":"2022-06-21T03:15:37.000Z","updated":"2022-06-27T16:08:00.192Z","comments":false,"path":"2022/06/21/第五章：树/","link":"","permalink":"https://wjjhui.github.io/2022/06/21/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%A0%91/","excerpt":"","text":"树基本术语 结点的度（Degree）：结点的子树个数 树的度：树的所有结点中最大的度数 叶结点（Leaf）：度为0的结点 父结点（Parent）：若一个结点含有子结点，则这个结点称为其结点的父结点 子结点（Child）：若A结点是B节点的父结点，则B节点是A节点的子结点，也称孩子结点 兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点 路径和路径长度：从结点N1到Nk的路径为一个结点序列，结点的个数为路径的长度 祖先结点（Ancestor）：沿树根到某一结点路径上所有结点都是这个结点的祖先结点 子孙结点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙 结点的层次（Level）：规定根结点在1层 树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度 有序树：树中结点的各子树从左到右是有次序的，不能互换 森林：森林是n颗互不相交的树的集和 树的性质 m叉树：每个结点至多有m个子树 度为m的树：至少有一个结点度为m 树的结点数等于所有结点的度+1 n&#x3D;n0+n1+n2+…+1 度为m的树中第i层至多有m^(i-1)个结点 高度为h的m叉树至少有h个结点 高度为h的m叉树至多有(m^i-1)&#x2F;(m-1)个结点 高度为h，度为m的树至少有h+m-1个结点 具有n个结点的m叉树的最小高度为 二叉树特殊的二叉树 二叉树的性质 n&#x3D;n0+n1+n2 , n&#x3D;n1+2n2+1 &#x3D;&#x3D;&gt; n0&#x3D;n2+1 一个二叉树第 i 层 至多有2^(i-1) 个结点 深度为h的二叉树至多有2^h-1个结点 n个结点的完全二叉树的高度为【log2（n+1）】或者【log2（n）】+1 在n个结点的二叉链表中，含有n+1个空链域。 二叉树的存储结构顺序存储12345struct TreeNode&#123; int value; //结点中的数据元素 bool isEmpty; //是否为空&#125;; 在完全二叉树中 i的左孩子为：2i i的右孩子为：2i+1 i的父结点为：【i&#x2F;2】 i所在的层次为：【log2（n+1）】或者【log2（n）】+1 链式存储12345//二叉树的链式存储typedef struct BiTNode&#123; int data; //数据域 struct BiTNode* lchild, * rchild; //左右孩子结点&#125;BiTNode,* BiTree; 二叉树的遍历 先序——根，左子树，右子树 中序——左子树，根，右子树 后序—–左子树，右子树，根 层次遍历—从上到下，从左到右（一层一层的遍历，从左到右） 二叉树的先序&#x2F;后序&#x2F;层序和中序遍历可以唯一确定一颗二叉树 递归遍历二叉树 1234567891011121314151617181920212223242526void PreTraversalRecursion(BiTree t) &#123; // 先序遍历 递归 根 左 右 if (t != NULL) &#123; printf(&quot;%d &quot;, t-&gt;Data); PreTraversalRecursion(t-&gt;Left); PreTraversalRecursion(t-&gt;Right); &#125;&#125;void MiddleTraversalRecursion(BiTree t) &#123; // 中序遍历 递归，左 根 右 if (t != NULL) &#123; MiddleTraversalRecursion(t-&gt;Left); printf(&quot;%d &quot;, t-&gt;Data); MiddleTraversalRecursion(t-&gt;Right); &#125;&#125;void PostTraversalRecursion(BiTree t) &#123; // 后序遍历 递归，左 右 根 if (t != NULL) &#123; PostTraversalRecursion(t-&gt;Left); PostTraversalRecursion(t-&gt;Right); printf(&quot;%d &quot;, t-&gt;Data); &#125;&#125; 层序遍历二叉树 算法思想 初始化一个辅助队列 根结点入队 若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾 重复3直到队列空 123456789101112void LevelOrderTraversal(BiTree T)&#123; LinkQueue Q; InitQueue(Q); //二叉树的链式存储 BiTree p; EnQueue(Q,T); //根结点入队 while(!isEmpty(Q))&#123; //队列不空则循环 DeleteQ(Q,p); //队头结点出队 visit(p) //访问出队结点 if(p-&gt;Left) EnQueue(Q,p-&gt;Left); //左孩子入队 if(t-&gt;Right) EnQueue(Q,p-&gt;Right); //右孩子入队 &#125;&#125; 线索二叉树基本概念 遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列 使得该序列中的每个结点（除第一个和最后一个）都有一个直接前驱和直接后继 利用n+1个空链域作为线索 中序线索化123456789101112131415161718192021222324252627282930313233343536373839404142//线索二叉树结点//*lchild ltag data rtag *rchild//tag为0：表示指针指向其孩子 tag为1：表示指针是线索typedef struct ThreadNode &#123; int data; struct ThreadNode* lchild, * rchild;//左右孩子结点 int ltag, rtag; //左右线索标志&#125;ThreadNode,* ThreadTree;ThreadNode* pre = NULL;//中序遍历二叉树，一边遍历一边线索化void InThread(ThreadTree t) &#123; if (t!= NULL) &#123; InThread(t-&gt;lchild);// 中序左 根 右 visit(t); InThread(t-&gt;rchild); &#125;&#125;void visit(ThreadNode* q) &#123; if (q-&gt;lchild == NULL) &#123; //左子树为空，建立前驱索引 q-&gt;lchild = pre; //q的前驱为pre q-&gt;ltag = 1; &#125; if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) &#123; pre-&gt;rchild = q; //建立前驱结点的后继索引 pre-&gt;ltag = 1; //pre的后继为q &#125; pre = q;&#125;//中序线索化void CreateInThread(ThreadTree T) &#123; pre = NULL; if (T != NULL) &#123; InThread(T); if (pre-&gt;rchild == NULL) //处理最后一个结点 pre-&gt;rtag = 1; &#125;&#125; 中序线索二叉树找中序后继p为根的子树，p节点的后继为右子树最左边的结点 12345678910111213141516171819202122//中序线索二叉树找中序后继// //找到最左边的结点ThreadNode* FirstNode(ThreadNode* p) &#123; while (p-&gt;ltag == 0) p = p-&gt;lchild; return p;&#125;//找到p节点的后继结点ThreadNode* NextNode(ThreadNode* p) &#123; //右子树中最左下结点 if (p-&gt;rtag == 0) return FirstNode(p-&gt;rchild); else return p-&gt;rchild;&#125;//对中序线索二叉树进行中序遍历void Inorder(ThreadNode* T) &#123; for (ThreadNode* p = FirstNode(T); p != NULL; p = NextNode(p)) visit(p);&#125; 中序线索二叉树找中序前驱p为根的子树，p节点的前驱为左子树最右边的结点 12345678910111213141516171819202122//中序线索二叉树找中序前驱// //找到最右边的结点ThreadNode* FirstNode(ThreadNode* p) &#123; while (p-&gt;rtag == 0) p = p-&gt;rchild; return p;&#125;//找到p节点的前驱结点ThreadNode* NextNode(ThreadNode* p) &#123; //右子树中最左下结点 if (p-&gt;ltag == 0) return FirstNode(p-&gt;lchild); else return p-&gt;lchild;&#125;//对中序线索二叉树进行中序遍历void Inorder(ThreadNode* T) &#123; for (ThreadNode* p = FirstNode(T); p != NULL; p = NextNode(p)) visit(p);&#125; 树、森林树的存储结构双亲表示法（顺序存储）采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中位置 优点：利用了每个结点只有唯一双亲的性质，可以很快的到每个结点的双亲结点 缺点：求每个结点的孩子时需要遍历整个结构 孩子表示法（顺序+链式存储）将每个结点的孩子结点都用单链表连接起来形成一个线性结构，此时n个结点就有n个孩子链表 优点：寻找子女的操作非常简单 缺点：寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表 孩子兄弟表示法（链式存储）以二叉链表作为树的存储结构，左指针为孩子、右指针为兄弟 结点值、指向结点第一个孩子结点的指针、指向结点下一个兄弟结点的指针 优点：可以很方便地实现树转换为二叉树的操作，易于查找结点的孩子 缺点：从当前结点查找其双亲结点比较麻烦 树、二叉树、森林的转换树转换为二叉树每个结点左指针指向孩子，右指针指向兄弟 森林转换为二叉树 将森林中的每个颗树转换为相应的二叉树 每棵树的根视为兄弟关系，在每棵树的根之间加一根连线 以第一棵树的根为轴心顺时针转45度 二叉树转换为森林二叉树的根及其左子树为第一棵树的二叉树形式 二叉树根的右子树可视为一个由除了第一棵树外的森林转换后的二叉树 树、森林的遍历先根遍历若树非空，先访问根结点，再依次遍历根结点的每颗子树，遍历子树仍遵循先根后子树的规则 其遍历的序列与这颗树相应的二叉树的先序序列相同 后跟遍历若树非空，先依次遍历根结点的每颗子树，在访问根结点，遍历子树仍遵循先子树后根的规则 其遍历的序列与这棵树相应的二叉树的中序序列相同 先序遍历森林 访问森林中第一颗树的根结点 先序遍历第一棵树中根节点的子树森林 先序遍历除去第一棵树后剩余的树构成的森林 中序遍历森林 中序遍历森林中的第一颗树的根结点的子树森林 访问第一棵树的根结点 中序遍历除去第一棵树之后剩余的树构成的森林 哈夫曼 **带权路径长度(WPL)**： 树中所有叶子结点的带权路径长度之和 特点： 没有度为1的节点 n个叶子节点的哈夫曼树共有2n-1个节点 哈夫曼树任意非叶子的左右子树交换仍然是哈夫曼树 同一组权值，存在不同构的哈夫曼树 哈夫曼树：WPL最小的二叉树 构造哈夫曼树：每次选择两个根结点权值最小的树合并，并将二者权值之和作为新的根结点的权值 12345678910111213141516171819202122232425typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int weight; HuffmanTree Left,Right;&#125;HuffmanTree Huffman(MinHeap H)&#123; //我们所有节点假设权值已经算好在weight中 int i; HuffmanTree T; BuildMinHeap(H);//构建最小堆 for(i=1; i&lt; H-&gt;size; i++)&#123; T=malloc(sizeof(struct TreeNode)); //从最小堆删除节点，作为左节点和右节点 T-&gt;Left = DeleteMin(H); T-&gt;Right = DeleteMin(H); //计算新的权值 T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; //插入最小堆 Insert(H,T); &#125; T = DeleteMin(H); return T;&#125; 哈夫曼编码：将字符频此作为节点权值，构造哈夫曼树。使用不等长编码，利用前缀码perfix code（任何字符的编码都不是另一字符编码的前缀） 类似于扩展操作码指令格式 并查集","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第四章:串","slug":"第四章：串","date":"2022-06-20T11:27:30.000Z","updated":"2022-06-20T11:42:13.820Z","comments":false,"path":"2022/06/20/第四章：串/","link":"","permalink":"https://wjjhui.github.io/2022/06/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2/","excerpt":"","text":"定义字符串简称串，是由零个或多个字符组成的有限序列。 串中任意个连续的字符组成的子序列成为该串的子串，包含子串的串成为主串 子串在主串中的位置以子串的第一个字符在主串中的位置表示 当两个串的长度相等且每个对应位置的字符都相等时，称这个两个串是相等的 由一个或多个空格组成串成为空格串 基本操作StrAssign（T,chars）：赋值操作 StrCopy（&amp;T，S）：复制操作 StrEmpty（S）：判空操作 StrCompare（S,T）:比较操作 StrLength（S）：求串长 SubString（&amp;Sub，S,pos，len）：求子串 Concat（&amp;T,S1,S2）:串连接 Index（S,T）:定位操作 ClearString（S）:清空操作 DestoryString（&amp;S）:销毁操作 实现顺序存储12345//静态数组实现,typedef struct&#123; char ch[MaxSize]; //每个分量存储一个字符 int length; //串的实际长度 &#125;SString; 12345//动态数组实现，typedef struct &#123; char* ch; //按串长分配存储区，ch指向串的基地址 int length; //串的长度&#125;HString; 链式存储123456//链式存储typedef struct &#123; char ch[4]; struct StringNode* next;&#125;StringNode,* StringStr; 操作实现1234567891011//求子串 返回S的第pos个字符起长度为len的子串bool SubString(SString &amp;Sub,SString S,int pos,int len) &#123; if (pos + len - 1 &gt; S.length) //子串范围越界 return false; for (int i = pos,j=1; i &lt; pos + len; i++,j++) &#123; Sub.ch[j] = S.ch[i]; &#125; Sub.length = len; return true;&#125;; 123456789//比较操作 S&gt;T 返回值&gt;0;S=T 返回值=0；S&lt;T 返回值&lt;0 int StrCompare(SString S, SString T) &#123; for (int i = 1; i &lt; S.length &amp;&amp; i &lt; T.length; i++) &#123; if (S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; &#125; return S.length - T.length;&#125; 1234567891011121314//定位操作 主串S中存在与串T相同的子串，返回第一次出现的位置int Index(SString S, SString T) &#123; int i = 1, n = S.length, m = T.length; SString temp; while (i &lt; n - m + 1) &#123; SubString(temp, S, i, m); //找出所有与T串长度相等的子串 if (StrCompare(S, temp) != 0) //所有字串与T相比较 ++i; else return i; &#125; return 0; //不存在与T 相等的子串&#125; 1234567891011121314151617181920//模式匹配算法int Index2(SString S, SString T) &#123; int i = 1, j = 1; while (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123; if (S.ch[i] == T.ch[j])&#123; ++i; //比较后继字符 ++j; &#125; else &#123; i = i - j + 2; //指针后退重新匹配 j = 1; &#125; &#125; if (j &gt; T.length) return i - T.length; else return 0;&#125; 123456789101112131415161718192021//KMP算法 //首先进行预处理，对模式串进行右移得出next数组 //next[]= null 0 1 1 2 2 3 int Index_KMP(SString S, SString T, int next[]) &#123; int i = 1, j = 1; while (i&lt;S.length&amp;&amp;j&lt;T.length) &#123; if (j == 0 || S.ch[i] == T.ch[j]) &#123; ++i; ++j; //比较后继字符 &#125; else j = next[j]; //模式串移动 &#125; if (j &gt; T.length) return i - T.length; else return 0; &#125;//KMP的优化//nextval数组代替next数组","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第三章:栈和队列","slug":"第三章：栈和队列","date":"2022-06-20T02:59:07.000Z","updated":"2022-06-20T06:43:31.363Z","comments":false,"path":"2022/06/20/第三章：栈和队列/","link":"","permalink":"https://wjjhui.github.io/2022/06/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈基本概念只允许在一段进入插入或删除操作的线性表 先进后出 栈的基本操作 InitStack（&amp;S）：初始化 StackEmpty（S）：判空 Pop（&amp;S,&amp;X）：出栈 Push（&amp;S,X）:入栈 GetTop（S,&amp;X）:读取栈顶元素 DestoryStack（&amp;S）：销毁栈 1）栈的顺序结构1234567//定义一个顺序栈//先进后出typedef struct &#123; int data[MaxSize]; //静态数组存放栈中元素 int top; //栈顶指针&#125;SqStack; 1234//初始化栈void InitStack(SqStack&amp; S) &#123; S.top = -1;&#125; 1234567//判断栈空bool StackEmpty(SqStack S) &#123; if (S.top == 1) return true; //栈为空 else return false;&#125; 123456789//元素入栈bool Push(SqStack&amp; S, int x) &#123; if (S.top == MaxSize - 1) //栈满 return false; S.top = S.top + 1; //指针+1 S.data[S.top] = x; //等价于S.data[++S.top]=x return true;&#125; 123456789//元素出栈bool Pop(SqStack&amp; S, int&amp; x) &#123; if (S.top == -1) //栈空 return false; x = S.data[S.top]; //栈顶元素出栈 S.top = S.top - 1; //指针减1 //等价于x=S.data[S.top--] return true;&#125; 1234567//读取栈顶元素bool getTop(SqStack S, int&amp; x) &#123; if (S.top == -1) //栈空 return false; x = S.data[S.top];&#125; 共享栈让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈定向共享空间的中间延伸 当两个栈的栈顶指针都指向栈定元素top0&#x3D;-1，top1&#x3D;MaxSize时 栈空 入栈时++top0，–top1 2）栈的链式结构1234567//定义一个链栈typedef struct LinkNode &#123; int data; //数据域 struct LinkNode* next; //指针域&#125;LNode,*LiStack; //LNode *L 等同于LiStack L 123456//初始化一个链栈 ，带头节点bool InitLStack(LiStack &amp;s) &#123; s=(LNode * )malloc(sizeof(LNode)); s-&gt;next=NULL; return true;&#125; 123456789//判空int isEmpty(LiStack s)&#123; if (s-&gt;next==NULL) &#123; return 1; &#125; return 0;&#125; 12345678//入栈bool Push(LiStack&amp; s, int data) &#123; LNode* temp=(LNode *)malloc(sizeof(LNode)); temp-&gt;data=data; temp-&gt;next=s-&gt;next; s-&gt;next=temp; return true;&#125; 12345678910//出栈bool Pop(LiStack&amp; S, int &amp;x)&#123; if (isEmpty(S)) //栈空 return false; LNode* temp = (LNode*)malloc(sizeof(LNode)); temp = S-&gt;next; S-&gt;next = temp-&gt;next; x = temp-&gt;data; return true;&#125; 123456//读取栈顶元素bool getTop(LiStack S, int&amp; x) &#123; if (isEmpty(S)) //栈空 return false; x = S-&gt;data;&#125; 队列基本概念只允许在一段进行插入另一端进行删除操作 先进先出 队列的基本操作 InitQueue（&amp;Q）：初始化 QueueEmpty（Q）；判空 EnQueue（&amp;Q,X）:入队 DeQueue（&amp;Q,&amp;X）:出队 GetHead（Q,&amp;x）:读取队头元素 1）队列的顺序结构1234567//队列 先进先出//定义一个队列typedef struct &#123; int data[MaxSize]; //数组存放队列元素 int front, rear; //队头和队位指针&#125;SeQueue; 123456//初始化bool InitQueue(SeQueue&amp; Q) &#123; Q.rear = Q.front=0; return true;&#125; 1234567//判断空bool IsEmpty(SeQueue Q) &#123; if(Q.front == Q.rear) return true; else return false;&#125; 123456789//入队bool EnQueue(SeQueue&amp; Q, int x) &#123; if ((Q.rear + 1) % MaxSize==Q.front) //判断队满 return false; Q.data[Q.rear] = x; Q.rear = (Q.rear + 1)%MaxSize ; //循环队列 return true; &#125; 123456789//出队 删除队头元素并用x返回bool DeQueue(SeQueue&amp; Q,int &amp;x) &#123; if (Q.front == Q.rear) //判断队空 return true; x = Q.data[Q.front]; Q.front = (Q.front + 1) % MaxSize; return true;&#125; 1234567//获取队头元素bool Gethead(SeQueue Q, int&amp; x) &#123; if (Q.front == Q.rear) //判断队空 return true; x = Q.data[Q.front]; return true; &#125; 2）队列的链式结构12345678910//定义一个链式队列typedef struct LinkNode &#123; //链式队列节点 int data; //数据域 struct LinkNode* next; //指针域&#125;LinkNode;typedef struct &#123; LinkNode* front, * rear; //队列的队头和队尾指针&#125;LinkQueue; 12345//带头节点void InitQueue(LinkQueue&amp; Q) &#123; Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode)); Q.front-&gt;next = NULL;&#125; 12345678//判空bool IsEmpty(LinkQueue Q) &#123; if (Q.front == Q.rear) return true; else return false;&#125; 12345678//新元素x入队void EnQueue(LinkQueue&amp; Q, int x) &#123; LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode)); //创建一个新节点 s-&gt;data = x; s-&gt;next = NULL; Q.rear-&gt;next = s; //新节点插入到队尾后 Q.rear = s; //修改队尾指针&#125; 123456789101112//出队 并用x带出 出队数据bool DeQueue(LinkQueue&amp; Q, int&amp; x) &#123; if (Q.front == Q.rear) return false; //队空 LinkNode* p = Q.front-&gt;next; //保存队头的后一个指针 x = p-&gt;data; //保存队友的后一个元素数据 Q.front-&gt;next = p-&gt;next; //队头指针向后移 if (Q.rear == p) Q.front == Q.rear; //出队的是最后一个节点 free(p); return true;&#125; 栈的应用括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546//定义一个顺序栈//先进后出typedef struct &#123; char data[MaxSize]; //静态数组存放栈中元素 int top; //栈顶指针&#125;SqStack;//初始化栈void InitStack(SqStack&amp; S) &#123;&#125;//判断栈空bool StackEmpty(SqStack S) &#123;&#125;//元素入栈bool Push(SqStack&amp; S, char x) &#123;&#125;//元素出栈bool Pop(SqStack&amp; S, char&amp; x) &#123;&#125;//读取栈顶元素bool getTop(SqStack S, char&amp; x) &#123;&#125;bool bracketCheck(char str[], int lens) &#123; SqStack S; InitStack(S); for (int i = 0; i &lt; lens; i++) &#123; if (str[i] == &#x27;(&#x27; || str[i] == &#x27;&#123;&#x27; || str[i] == &#x27;[&#x27;) Push(S, str[i]); //左括号入栈 else &#123; if (StackEmpty(S)) return false; //扫描到右括号， 但是栈空 char topElem; Pop(S, topElem); //栈定元素出栈 if (str[i] == &#x27;)&#x27; &amp;&amp; topElem != &#x27;(&#x27;) return false; if (str[i] == &#x27;&#125;&#x27; &amp;&amp; topElem != &#x27;&#123;&#x27;) return false; if (str[i] == &#x27;]&#x27; &amp;&amp; topElem != &#x27;[&#x27;) return false; &#125; &#125; if (StackEmpty(S)) return true;&#125; 逆波兰式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct node//压栈和出栈都在栈顶进行(这里的栈顶指前一段)&#123; char val;//数据 struct node* next;//指针&#125;pnode;typedef struct seqstack&#123; int size;//记录栈的大小 pnode* top;//指向栈顶元素&#125;phead;phead* initstack()//创建栈&#123; phead* istack=(phead*)malloc(sizeof(phead));//为头节点分配空间 if(istack!=NULL)//健壮性判断 &#123; istack-&gt;top=NULL; istack-&gt;size=0; &#125; return istack;&#125;int isempty(phead* istack)//判断栈为空&#123; if(istack-&gt;top==NULL) &#123; return 1;//栈为空 &#125; return 0;//栈不为空&#125;pnode* seqstack_top(phead* istack)//获取栈顶元素的数据节点&#123; if(istack-&gt;size!=0)//栈不为空 &#123; return istack-&gt;top;//返回的是栈顶的数据节点而不是栈顶的元素 &#125; return NULL;&#125;pnode* seqstack_pop(phead* istack)//弹出栈顶元素&#123; if(isempty(istack)==0)//栈不为空 &#123; pnode* account=istack-&gt;top;//记录栈顶的数据节点 istack-&gt;top=istack-&gt;top-&gt;next;//指向栈顶下一个元素 istack-&gt;size--;//记录栈的大小 return account;//返回弹出的数据节点 &#125; return NULL;&#125;void seqstack_push(phead* istack,char x)//压栈(入栈)&#123; pnode* temp;//进行压栈的数据节点 temp=(pnode*)malloc(sizeof(pnode)); temp-&gt;val=x;//填充数据域 temp-&gt;next=istack-&gt;top;//连接栈顶的数据节点 istack-&gt;top=temp;//充当栈顶 istack-&gt;size++;//记录栈大小的变化 return;&#125; //下面是中缀表达式转后缀表达式的函数 char buffer[256]=&#123;0&#125;;//即对数组中每个数据都初始化为&#x27;\\0&#x27;(\\0的ascill码是0) //buffer为结果串 void char_put(char ch)//用来将字符放入放入结果串 &#123; static int index=0;//static定义静态变量,放函数中表示index只初始化一次,只保留index的改变 buffer[index++]=ch; &#125; int priority(char ch)//用来比较优先级 &#123; int ret=0; switch(ch) &#123; case &#x27;+&#x27;://case穿透,即上一个case没有break语句时会继续向下执行 case &#x27;-&#x27;: ret=1; break; case &#x27;*&#x27;: case &#x27;/&#x27;: ret=2; break; default://这里直接break也可以 break; &#125; return ret; &#125; int is_number(char ch)//是不是数字 &#123; return(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;);//数字返回1，否则返回0 &#125; int is_operator(char ch)//是不是运算符 &#123; return(ch==&#x27;+&#x27;||ch==&#x27;-&#x27;||ch==&#x27;*&#x27;||ch==&#x27;/&#x27;); &#125; int is_left(char ch)//是不是左括号 &#123; return(ch==&#x27;(&#x27;); &#125; int is_right(char ch)//是不是右括号 &#123; return(ch==&#x27;)&#x27;); &#125; int transform(char str[])//使用const保护数据,函数用来将中缀转换成后缀 &#123; phead* istack=initstack();//创建一个栈 int i=0; while(str[i]!=&#x27;\\0&#x27;)//遍历整个字符串 &#123; //判断是不是数字 if(is_number(str[i])==1) &#123; if(is_number(str[i+1])==1)//后面1也是数字,则直接放 &#123; char_put(str[i]);//数字直接放入结果串(即输出) &#125; else//后面不是数字,添加一个空格作为分隔符 &#123; char_put(str[i]); char_put(&#x27; &#x27;); &#125; &#125; else if(is_operator((str[i]))==1) &#123; if(str[i+1]==&#x27;0&#x27;&amp;&amp;str[i]==&#x27;/&#x27;) &#123; printf(&quot;ILLEGAL&quot;); return 0; &#125; if(isempty(istack)==0)//栈不为空 &#123; while((isempty(istack)==0)&amp;&amp;(priority(str[i])&lt;=(priority(seqstack_top(istack)-&gt;val))))//栈不为空并且新运算符优先级不高于栈顶 &#123; char_put(seqstack_pop(istack)-&gt;val);//满足条件的栈顶就弹出直到不满足条件 char_put(&#x27; &#x27;); &#125; &#125; seqstack_push(istack,str[i]);//再将该运算符入栈 &#125; else if(is_left(str[i]))//左括号直接入栈 &#123; seqstack_push(istack,str[i]); &#125; else if(is_right(str[i]))//判断是不是右括号 &#123; while(is_left(seqstack_top(istack)-&gt;val)!=1)//栈顶不是左括号的情况 &#123; char_put(seqstack_pop(istack)-&gt;val);//弹出并存储到结果串 if(isempty(istack)==1)//栈为空仍未找到左括号 &#123; printf(&quot;没有匹配到左括号\\n&quot;); return -1; &#125; &#125; //此时匹配到了左括号 seqstack_pop(istack); //弹出左括号,这里并不用保存,即两个括号相抵消 &#125; else &#123; printf(&quot;有不能识别的字符\\n&quot;); return -1; &#125; i++; &#125; //遍历完了已经 if(str[i]==&#x27;\\0&#x27;)//成功遍历到字符串末尾 &#123; while(isempty(istack)==0)//弹出全部栈中元素 &#123; if(seqstack_top(istack)-&gt;val==&#x27;(&#x27;)//栈顶元素为左括号 &#123; printf(&quot;有没有匹配到的&#x27;(&#x27;,缺少&#x27;)&#x27;\\n&quot;); return -1; &#125; char_put(seqstack_pop(istack)-&gt;val);//将栈中元素放入最终串 &#125; &#125; else &#123; printf(&quot;遍历没有完成！\\n&quot;); &#125; return 1; &#125;int main()&#123; char str[1024]=&#123;0&#125;;//将数组每个元素赋值为&#x27;\\0&#x27; printf(&quot;请输入四则运算表达式:\\n&quot;); scanf(&quot;%s&quot;,str); int number=transform(str); if(number==-1) &#123; printf(&quot;表达式转换错误:\\n&quot;); &#125; else if(number==1) &#123; printf(&quot;转化后的表达式: %s\\n&quot;,buffer); &#125; else &#123; return 0; &#125;&#125; 矩阵的压缩存储对称矩阵 三角矩阵 三对角矩阵","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第二章:顺序表","slug":"第二章：顺序表","date":"2022-06-18T06:53:51.000Z","updated":"2022-06-20T02:59:08.327Z","comments":false,"path":"2022/06/18/第二章：顺序表/","link":"","permalink":"https://wjjhui.github.io/2022/06/18/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"1、线性表的定义和操作定义线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表。 特点：1、元素个数有限 2、表中的元素具有逻辑上的顺序性，表中元素有先后次序 3、表中元素都是数据元素，每个元素都是单个元素 4、每个元素占有相同大小的存储空间 注意！线性表是一种逻辑结构，表示元素之间一对一的相邻关系 顺序表和链表是指存储结构 线性表的基本操作InitList（&amp;L）；初始化 length（L）:求表长 locateElem（L,e）：按值查找 getElem（L,I）：按位查找 listInsert（&amp;L，e）：插入操作 liseDelete（&amp;L，&amp;e）：删除操作 printList（L）：输出操作 empty（L）：判空操作 destory（&amp;L）:销毁操作 2、线性表的顺序表示1）定义用一组地址连续的存储单元依次存放线性表中的数据元素 静态分配：数组的大小和空间已经固定，一旦空间占满，再加入新的数据会产生溢出，程序就会崩溃。 动态分配：存储出租的空间是再程序执行过程中通过动态分配语句分配的。 特点1、随机访问，即通过首地址和元素序号可在时间O（1）内找到指定的元素 2、存储密度高，每个节点只存储数据元素 3、逻辑上相邻的元素物理上也相邻，当执行插入和删除操作时，需要移动大量元素 2）静态分配123456//顺序表的静态分配typedef struct &#123; int data[MaxSize]; //用静态的数组存放数据元素 int length; //顺序表的当前长度 &#125;SqList; 123456//初始化顺序表void InitList(SqList &amp;L) &#123; for (int i = 0; i &lt; MaxSize; i++) L.data[i] = 0; L.length = 0;&#125; 123456789101112131415//插入位置为i，元素值为ebool ListInsert(SqList&amp; L, int i, int e) &#123;if (i&lt;1||i&gt;L.length+1) //判断插入元素下边是否越界 return false;if (L.length &gt; MaxSize)//判断顺序表元素是否满 return false;for (int j = L.length; j &gt;= i; j--) &#123; //将第i各元素及之后的元素后移 L.data[j] = L.data[j - 1];&#125;L.data[i - 1] = e;//在位置i插入eL.length++;//长度加1printf(&quot;插入成功！\\n&quot;);return true;&#125; 1234567891011//删除第i个元素 并返回删除的元素值bool ListDelete(SqList&amp; L, int i, int &amp;e) &#123; //&amp;e引用型参数 将删除的元素返回 if (i&lt;1 || i&gt;L.length + 1) //判断插入元素下边是否越界 return false; e = L.data[i-1];//下标=个数-1 for (int j = i; j &lt;L.length; j++) &#123; L.data[j-1] = L.data[j]; &#125; L.length--; //长度减1 return true;&#125; 1234//按位查找int VolueGetElem(SqList L, int i) &#123; return L.data[i - 1];&#125; 12345678//按值查找int LocateGetElem(SqList L, int e) &#123; for (int i = 0; i &lt; L.length; i++) &#123; if (L.data[i] == e) return i + 1; &#125; return -1;&#125; 12345//输出操作void disp(SqList&amp; L) &#123; for (int i = 0; i &lt; L.length; i++) printf(&quot;%d:data:%d,length:%d\\n&quot;, i, L.data[i], L.length);&#125; 3）动态分配1234567//顺序表的动态分配typedef struct &#123; int* data;//指示动态分配数组的指针 int MaxSize;//顺序表的最大容量 int length;//顺序表的当前容量&#125;SqList; 12345678//初始化void InitList(SqList&amp; L) &#123; //malloc申请一片连续的空间 L.data = (int*)malloc(InitSize * sizeof(int)); L.length = 0; L.MaxSize = InitSize;&#125; 1234567891011//增加表的长度void IncreaseSize(SqList&amp; L, int len) &#123; int* p = L.data; L.data = (int*)malloc((L.MaxSize + len) * sizeof(int)); for (int i = 0; i &lt; L.length; i++) &#123; L.data[i] = p[i]; &#125; L.MaxSize = L.MaxSize + len; //free释放旧的内存空间 free(p);&#125; 3、线性表的链式表示1）定义线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素，对每个链表节点，除了存放数据元素本身外，还需要存放下一个指向后继的指针。 优点：解决顺序表需要大量连续地址的缺点 缺点：存储密度低，差找元素需要从头开始遍历 2）单链表12345//定义单链表的结构体typedef struct LNode &#123; //定义单表表的节点类型 int data; //每个节点存放一个数据元素 struct LNode *next; //指针指向下一个节点&#125;LNode,*LinkList; 12345//初始化一个空的单链表 不带头节点bool InitList1(LinkList&amp; L) &#123; L = NULL; return true;&#125; 12345678//初始化一个空的单链表 带头节点bool InitList2(LinkList&amp; L) &#123; L = (LNode*)malloc(sizeof(LNode)); //分配一个头节点 if (L == NULL) return false; //内存不住，分配失败 L-&gt;next == NULL; //头节点之后暂无节点 return true;&#125; 12345678910111213141516171819202122//在第i个位置插入元素ebool ListInsert(LinkList &amp;L, int i, int e) &#123; if (i &lt; 1) return false; //判断插入下标 LNode *p;//定义一个指针p 指向当前扫描到的节点 int j = 0;//定义一个数值j，当前指向的是第几个节点 p = L; //L指向头节点，头节点是第0个节点 while (p != NULL &amp;&amp; j &lt; i - 1) &#123;//循环找到第i-1个节点 p = p-&gt;next; j++; &#125; if (p == NULL) return false; //第i个位置的节点指针不存在，即i值越界 LNode *s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; printf(&quot;插入成功第%d个节点的值为%d\\n&quot;,i,e); return true;//插入成功&#125; 1234567891011//后插操作：在p节点后插入元素e//LNode *P=LinkListbool InsertNextNode(LNode* p, int e) &#123; if (p == NULL) return false; LNode* s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return true;&#125; 123456789101112//前插入操作，在p节点之前插入元素ebool InsertProNode(LNode* p, int e) &#123; if (p == NULL) return false; LNode* s = (LNode*)malloc(sizeof(LNode)); s-&gt;next = p-&gt;next; p-&gt;next = s; s-&gt;data = p-&gt;data; p-&gt;data = e; return true;&#125; 12345678910111213141516171819202122//按位序删除第i个节点，并返回其值ebool ListDelete(LinkList&amp; L, int i, int e)&#123; if (i &lt; 1) return false; LNode* p;//定义一个指针p 指向当前扫描到的节点 int j = 0;//定义一个数值j，当前指向的是第几个节点 p = L; //L指向头节点，头节点是第0个节点 while (p != NULL &amp;&amp; j &lt; i - 1) &#123;//循环找到第i-1个节点 p = p-&gt;next; j++; &#125; if (p == NULL) //i下标越界 return false; if (p-&gt;next == NULL) //i-1个节点后无节点 return false; LNode *q = p-&gt;next; //暂存删除的节点 e = q-&gt;data; p-&gt;next = q-&gt;next; free(q); return true;&#125; 123456789101112//指定节点删除 类似前插操作bool DleleteNode(LNode* p) &#123; if (p == NULL) return false; LNode* q = p-&gt;next; //暂存删除的节点 //如果删除的节点是最后一个节点呢？，无后继节点则出现bug p-&gt;data = p-&gt;next-&gt;data; //和后继节点交换数据域 p-&gt;next = q-&gt;next; //将q节点断开 free(q); return true;&#125; 12345678910111213//按位查找 找到第i个节点的值LNode* LocateGetElem(LinkList L,int i) &#123; if (i &lt; 0) return NULL; LNode* p;//定义一个指针p 指向当前扫描到的节点 int j = 0;//定义一个数值j，当前指向的是第几个节点 p = L; //L指向头节点，头节点是第0个节点 while (p != NULL &amp;&amp; j &lt; i ) &#123;//循环找到第i个节点 p = p-&gt;next; j++; &#125;; return p;&#125; 123456789//按值查找 找到值为e的节点LNode* ValueGetELem(LinkList L, int e) &#123; LNode* p = L-&gt;next; while (p!=NULL&amp;&amp;p-&gt;data!=e) &#123; p = p-&gt;next; &#125; return p; //找到返回节点 未找到返回NULL&#125; 1234567891011//求链表的长度int LengthList(LinkList L) &#123; int len = 0; L = L-&gt;next; while (L!=NULL) &#123; len++; L = L-&gt;next; &#125; return len;&#125; 12345678910111213141516171819202122//尾插法 建立单链表//step1：初始化一个单链表，带头节点//step2：每次取一个数据元素，插入到表尾LinkList TailInsert(LinkList &amp;L) &#123; int x=0,y=1; L = (LNode*)malloc(sizeof(LNode));//创建头节点 LNode* s, * r = L; printf_s(&quot;请输入第%d个节点的值&quot;,y); scanf_s(&quot;%d&quot;, &amp;x); while (x!=9999) //输入9999结束 &#123; s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s; y++; printf(&quot;输入第%d个节点的值&quot;, y); scanf_s(&quot;%d&quot;, &amp;x); &#125; r-&gt;next = NULL; return L;&#125; 12345678910111213141516171819202122//头插法LinkList HeadInsert(LinkList &amp;L) &#123; int x = 0, y = 1; LNode* s; L = (LNode*)malloc(sizeof(LNode)); //创建头节点 L-&gt;next = NULL;//初始化为空 printf_s(&quot;请输入倒数第%d个节点的值&quot;, y); scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) //输入9999结束 &#123; s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; y++; printf(&quot;输入第%d个节点的值&quot;, y); scanf_s(&quot;%d&quot;, &amp;x); &#125; return L;&#125; 1234567891011//遍历单链表void disp(LinkList &amp;L) &#123; int i = 1; L = L-&gt;next; while(L != NULL) &#123; printf(&quot;第%d个值为：%d\\n&quot;, i, L-&gt;data); L = L-&gt;next; i++; &#125;&#125; 3）双链表12345//定义双链表的结构体typedef struct DNode &#123; //定义单表表的节点类型 int data; //每个节点存放一个数据元素 struct DNode *next,*prior; //前驱和后继节点&#125;DNode, * DLinkList; 123456789//初始化双链表bool InitDlinkList(DLinkList&amp; L) &#123; L = (DNode *)malloc(sizeof(DNode)); //分配头节点 if (L == NULL) return false; L-&gt;prior = NULL; L-&gt;next = NULL; return true;&#125; 123456789101112//p节点之后插入s节点bool InsertNextDNode(DNode* p, DNode* s) &#123; if (p == NULL || s == NULL) return false; s-&gt;next = p-&gt;next; if(p-&gt;next!=NULL) //判断是否是最后一个元素 p-&gt;next-&gt;prior = s; s-&gt;prior = p; p-&gt;next = s; return true;&#125; 12345678910111213//删除p系欸但那的后继节点bool DeleteNextDNode(DNode* p) &#123; if (p == NULL) return false; DNode* q = p-&gt;next; //找到p节点的后继节点 赋值给q if (q == NULL) //p节点无后继节点 return false; if(q-&gt;next!=NULL) //q节点不是最后一个节点 p-&gt;next = q-&gt;next; free(q); return true;&#125; 1234567891011//销毁双链表void DestoryList(DLinkList&amp; L) &#123; while (L-&gt;next= NULL) &#123; DeleteNextDNode(L); //删除后继节点 &#125; free(L); //释放L L = NULL; //头指针指向null&#125; 1234567891011121314//双链表的遍历void disp(DLinkList L)&#123; //后向遍历 while (L != NULL) &#123; L = L-&gt;next; &#125; //前向遍历 while (L!=NULL) &#123; L = L-&gt;prior; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"第七章:I/O系统","slug":"第七章：IO系统","date":"2022-05-27T10:46:33.000Z","updated":"2022-06-18T06:55:32.924Z","comments":false,"path":"2022/05/27/第七章：IO系统/","link":"","permalink":"https://wjjhui.github.io/2022/05/27/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9AIO%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"7.1 I&#x2F;O系统的基本概念输入输出系统外部设备：包括输入&#x2F;输出设备以及通过输入&#x2F;输出结课才能访问的外存储设备 接口：在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件 输入设备：用于向计算机系统输入命令和文本、数据等信息的部件 输出设备：用于将计算机系统中的信息输出到计算机外部进行显示的部件 外存设备：除计算机内存及CPU缓存等外的存储器 I&#x2F;O软件：驱动程序、用户程序、管理程序、升级补丁。通常采用I&#x2F;O指令和通道指令实现CPU与I&#x2F;O设备的交互 I&#x2F;O硬件：包括外部设备、设备控制器和接口、I&#x2F;O总线等 I&#x2F;O控制方式程序查询方式：CPU通过程序查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备进行主机交换信息 程序中断方式：只在I&#x2F;O设备准备就绪并向CPU发出中断请求时才予响应 DMA方式：主存和I&#x2F;O设备之间有一条直接数据通路，当主存和I&#x2F;O设备交换信息时无须调用中断服务程序 通道方式：在系统中设有通道控制部件，每个通道挂接若干外设，主机在执行I&#x2F;O指令时，只需要启动有关通道。通道执行通道程序完成I&#x2F;O设备 7.2 外部设备输出设备键盘：1）查出按下的是哪个键位，2）将该键翻译成能被主机接收的键码，3）将编码发给主机 鼠标：鼠标在平面上移动，底部传感器将移动距离与方向检测出来，从而控制光标的移动 输出设备显示器屏幕大小：对角长度 分辨率：所能显示的像素个数，宽与高的乘积 灰度级：黑白显示器中所显示的像素点的亮暗差别，彩色显示器的中颜色不同。如RGB 刷新：光点只能褒词极短的时间就会消失，必须在其消失前重新扫描一遍 刷新频率：单位时间内扫描整个屏幕内容的次数，刷新频率大于30HZ时人眼无法分辨除刷新。 显示存储器（VRAM）：也称为出阿信存储器，将一帧的图像存储在刷新存储器中，从而提高刷新图像的信号 打印机针式打印机#原理：主机发出打印命令，经过接口、检测和控制电路、间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带打印内容。 #优点：擅长多层复习打印，实现各种票据和蜡纸等打印，工作原理简单，造假低廉，耗材便宜 #缺点：打印分辨率和打印速度不够高 喷墨式打印机#原理：带点的喷墨雾点经过电极偏转后，直接在之上形成所需要的字形 #优点：打印噪声小，实现高质量彩色打印，打印速度比针式打印机快 #缺点：防水性、打印成本高、需要专用打印纸 激光打印机#原理：计算机输出二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，经过显影、转印和定影，在纸上得到所需的字符或图像 #优点：打印质量高，速度快，噪音小，处理能力强 #缺点：耗材多、价格贵、不能复写打印多份、对纸张要求高 磁表面存储器优点：纯储容量大，价格低，非破坏性读出，记录信息可以长久保存 缺点：存取速度慢、机械机构复杂、对工作环境要求高 磁盘存储器 组成 #磁头：用于读&#x2F;写盘片上的记录面信息，一个记录面对应一个磁头 #柱面数：表示硬盘每个盘片上有多少磁盘 #扇区数：表示每条磁道有多少哥扇区 #磁盘驱动器：核心部件是磁头组件和盘片组件 #磁盘控制器：硬盘存储器和主机的接口 磁盘地址 #柱面号、盘面号、扇区号 硬盘工作过程 #寻址、读盘、写盘 #第一步是取控制字、第二部是执行控制字 #读写操作是串行的，不能既读又写 7.3 I&#x2F;O接口I&#x2F;O接口功能1）实现主机和外设之间的通信联络控制 2）进行地址译码和设备选择 3）实现数据的缓冲，相处CPU和外设之间的速度差异 4）信号格式转换：实现消除主机与外设之间的电平、数据格式等差异 5）传送控制命令和状态信息：协调外设的运作状态 I&#x2F;O接口的基本结构内部接口：内部接口与系统总线相连。数据传输方式只能是并行传输 外部接口：外部接口通过接口电缆和外设相连。外部接口可能串行结构，所以I&#x2F;O接口要有串&#x2F;并转换功能 I&#x2F;O接口类型数据传输方式并行接口：一个字节或一个字的所有位同时传送 串行接口：一位一位的传输 控制方式程序查询接口 程序中断接口 DMA接口 按照功能分类可编程接口 不可编程接口 I&#x2F;O端口及其编址统一编址将I&#x2F;O端口当作存储器单元进行地址分配 优点：不需要设置专门输入输出指令，CPU访问存储器更灵活，端口编址空间较大 缺点：端口占用存储器地址，数据输入输出的适合，执行速度较慢 独立编址I&#x2F;O地址与存储器地址无关 优点：程序编址清晰，便于理解 缺点：需要设置专门的输入&#x2F;输出指令，增加了控制的复杂性 7.4 I&#x2F;O方式程序查询方式原理：信息交换完全交给主机执行程序实现，主机对设备的状态进行询问吗，然后根据结构决定下一步是传输数据还是等待。 优点：设计简单且设备量小 缺点：CPU需要花费大量时间进行查询和等待，一段时间内只能和一台外设交互信息，效率低 程序中断方式中断请求内&#x2F;外中断#内中断：内中断是指在处理器和内存内部产生的中断，包括程序运算引起的各种错误。如地址非法、校验错等 #外中断：外中断是指来处理器和内存外的部件引起的中断，包括I&#x2F;O设备发出的I&#x2F;O中断等 硬件中断&#x2F;软件中断#硬件中断：通过外部的硬件产生的中断，硬件中断属于外中断 #软件中断：通过某条指令产生的中断，这种中断是可以编程实现，软件中断是内终端 非屏蔽和可屏蔽中断#非屏蔽中断：非屏蔽中断是一种硬件中断，不受中断位IF的影响，即使处在关中断的情况下也会被响应 #可屏蔽中断：可屏蔽中断也是一种硬件中断，收中断位IF的影响，关中断时不可被响应 中断判优通过中断判优逻辑确定响应那个中断源的请求 硬件实现：硬件实现是通过硬件排队器实现的，它既可以设置在CPU中，也可以分散在中断源中 软件实现：软件实现是通过查询程序实现的 一般逻辑 #硬件故障中断属于最高级 #非屏蔽中断优于可屏蔽中断 DMA请求优于I&#x2F;O设备传输 #高速设备优于低速设备 #输入设备优于输出设备 #实时设备优于普通设备 CPU响应中断条件中断源有中断请求 CPU允许中断及开中断 一条执行完毕，且没有更紧迫的任务 中断响应过程1）关中断 2）保存断电 3）引出中断服务程序 4）保存现场和屏蔽字 5）开中断 6）执行中断服务程序 7）关中断 8）恢复现场和屏蔽字 9）开中断、中断返回 DMA方式概述1）DMA方式是一种完全由硬件进行成组的信息传送的控制方式，DMA方式在外设与内存之间开辟一条”直接数据通路” 2）适用于磁盘机，磁带机等高速设备 3）硬件开销大 特点1）它使主存与CPU的固定联系脱钩，主存既可以被CPU访问又可以被DMA控制器访问 2）在数据块传送时，主存地址的确定，传送数据的计数等都由硬件电路直接实现 3）主存中要开启专用缓冲区，及时供给和接受外设的数据 4）DMA传送速度快，CPU和外设并行工作，提高了工作效率 5）DMA在传送开始前要通过程序进行预处理，结束后要通过程序中断方式进行后处理 组成1）主存地址计数器：存放要交换数据的主存地址 2）传送长度计数器：记录要传送数据的长度，计数溢出时，数据传送完毕，自动发出中断请求信号 3）数据缓冲寄存器：暂存每次传送的数据 4）DMA请求触发器：I.O发出控制信号，使得DMA请求触发置位 5）”控制&#x2F;状态”逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步 6）中断机构：当一个数据块传送完毕后触发中断机构，向CPU提出中断请求 传送方式1）停止CPU访问主存：CPU放弃对地址线、数据线和有关控制线的使用权，DMA接口获得总线控制权 2）DMA与CPU交替访存:适用于CPU的工作周期比主存存取周期长的情况，CPU与DMA接口交替获得总线控制权 3）周期挪用：在交替访问的基础上，当DMA接口空闲时，CPU获得总线控制权 传送过程1）预处理：由CPU完成一些必要的工作（寄存器置初值、设置传送方向、启动改设备） 2）数据传送：DMA的数据传输可以以单字节或数据块为基本单位，完全由DMA控制 3）后处理：DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理 DMA方式和中断方式的区别1）中断方式是程序的切换，需要保护和恢复现场 ，DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源 2）中断请求的响应只能发生在每条指令执行完毕时，DMA请求的响应可以发生在每个机器周期结束时 3）中断传送过程需要CPU的干预，DMA传送过程由DMA完全控制 4）DMA请求的优先级高于中断请求 5）中断方式具有对异常事件的处理能力 6）DMA方式靠硬件传送","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"第六章:总线","slug":"第六章：总线","date":"2022-05-23T14:16:08.000Z","updated":"2022-05-23T14:24:27.141Z","comments":false,"path":"2022/05/23/第六章：总线/","link":"","permalink":"https://wjjhui.github.io/2022/05/23/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%80%BB%E7%BA%BF/","excerpt":"","text":"6.1 总线的概述6.1.1 总线的基本概念总线的定义总线是一组能为多个部件分时共享的公共信息传送线路 分时：同一时刻只允许有一个部件向总线发送信息 共享：总线上可以挂接多个部件，各个部件互相交换的信息可以通过这组线路分时共享 总线设备主设备：总线的主设备是指获得总线控制权的设备 从设备：总线的从设备是指被主设备访问的设备 总线的特性机械特性：尺寸，形状 电器特性：传输方向和有效的电平范围 功能特性：每根传输的功能 时间特性：信号和时序的关系 总线的猝发传输一个总线周期内存储地址连续的多个数据字的总线传输方式 6.1.2 总线的分类片内总线芯片内部的总线，是CPU芯片内部寄存器和寄存器之间，寄存器于ALU之间的公共连接线 数据总线1、传输个功能部件之间的数据信息 2、双向传输总线 3、位数于机器字长、存储字长有关 地址总线1、数据总线上的源数据或目的数据所在的主存单元或I&#x2F;O端口的地址 2、单向传输总线 3、地址总线的位数于主存地址空间的大小有关 控制总线传输控制信息，CPU送出的控制命令和主存返回CPU的反馈信号 6.1.3 系统总线的结构单总线结构1、将CPU、主存、I&#x2F;O设备都挂载到一组总线上 2、优点：结构简单。成本低，容易接入新设备 3、缺点：带宽低，负载重，多个部件只能争用唯一饿总线，并且不支持并传送操作 双总线结构1、一条主存总线，用于CPU，主存和通道之间传送数据，另一条是I&#x2F;O总线用于在多个外部设备和通道之间传输数据 2、优点：将低速I&#x2F;O设备从单总线上分离出来，实现了存储总线和I&#x2F;O总线分离 3、缺点：需要增加通道等硬件设备 三总线结构1、计算机系统个部件之间采用三条独立总线来构成信息通路（主存总线，I&#x2F;O总线，DMA总线） 2、优点：提高了I&#x2F;O设备的性能，使其更快的响应命令，提高系统的吞吐量 3、缺点：系统工作效率较低 6.1.4 总线的性能指标1、总线的传输周期：一次总线操作所需要的时间，总线传输周期由若干个总线时钟周期构成 2、总线时钟周期：即机器的时钟周期 3、总线的工作频率：总线周期的倒数 4、总线的时钟频率：时钟周期的倒数 5、总线带宽：&#x3D; 总线工作频率 × 总线宽度 （bit&#x2F;s）&#x3D; 总线工作频率 × (总线宽度&#x2F;8) （B&#x2F;s） 6、总线复用：一种信号线在不同时间传输不同的信息，节约了空间和成本 7、信号线数：地址总线，数据总线，控制总线 6.2总线仲裁6.2.1 集中仲裁方式链式查询方式1、一根总线请求线，一根总线忙线，一根总线允许线 2、优点：优先级固定，结构简单，扩充容易 3、缺点：对于电路故障敏感，优先级不变 计数器定时查询方式1、使用计数器控制总线优先权 2、优点：设备优先级相等，优先次序可以改变 3、缺点：增加了控制线数- 若设备有n个，则需log2n +2条控制线 独立请求方式1、每个设备均有请求线于总线允许线 6.2.2 分布总裁方式不需要中央仲裁器，每个潜在主模块，都有自己的仲裁号和仲裁器，然后进行仲裁号比较，获胜者仲裁号保留在仲裁总线上 6.3总线操作与定时总线传输的五个阶段1、请求阶段：主设备发出总线传输请求，并且获得总线控制权 2、仲裁阶段：总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者 3、寻址阶段：主设备通过总线给出要访问的从设备地址及有关命令，启动从模块 4、传输结构：主模块和从模块进行数据交换，可单向或双向进行数据传送 5、释放阶段：主模块的有关信息均从系统总线上撤除，让出总线控制权 同步定时方式1、系统采用统一的时钟信号来协调发送和接收方的传送定时关系 2、优点：传送速度块，拥有较高的传输速率，总线控制逻辑简单 3、缺点：主设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差 异步定时方式1、没有统一的时钟，完全按照传送双方相互制约的握手信号实现定时控制 2、优点：总线周期长度可变，可以保证两个速度相差较大部件或设备的信息传输 3、缺点：控制相对复杂，并且速度相对较慢 6.4总线标准常见总线标准系统总线：ISA、EISA 局部总线：VESA、PCI、PCI-Express、AGP 设备总线：RS-232C、USB","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"第四章:指令系统","slug":"第四章：指令系统","date":"2022-05-16T13:24:52.000Z","updated":"2022-05-23T14:31:05.694Z","comments":false,"path":"2022/05/16/第四章：指令系统/","link":"","permalink":"https://wjjhui.github.io/2022/05/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"4.1指令格式4.1.1 指令的基本格式 （操作码+地址码）结构操作码：指出指令中应该执行什么性质的操作和具有何种功能 地址码：给出被操作的信息的地址 长度单字长指令：长度等于机器字长 双字长指令：长度等于两倍机器字长 半字长指令：长度等于半个机器字长 分类零地址指令OP 1）不需要操作数的指令，如空指令、停机指令、关中断指令 2）仅使用在堆栈计算机中 一地址指令OP A1 1）只有目的操作数的单操作数指令，按照A1地址读取操作数后进行OP操作，结果存回原地址 2）隐含约定目的地址的双操作数指令 二地址指令OP A1 A2 1）算术和逻辑运算指令 2）两个操作数，目的操作数和源操作数，结果返回到目的操作数 三地址指令OP A1 A2 A3 1）算术和逻辑运算指令 2）目的操作数、源操作数、结果操作数 四地址指令OP A1 A2 A3 A4 1）算术和逻辑运算指令 2）目的操作数、源操作数、结果操作数、下地址 4.1.2 定长操作码指令格式优点：定长操作码对于简化计算机硬件设计，提高指令移码和识别速度很有利 缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限 4.1.3 扩展操作码指令格式实现：全部指令的操作码字段位数不固定，分散在指令字的不同位置上 优点：丰富了指令的种类 缺点：增加了 指令译码和分析难度，控制器设计变的复杂 4.2指令的寻址方式4.2.1 指令寻址1）顺序寻址：通过PC+”1”自动形成下一条指令的地址，单字长指令+1，双字长指令+2 2）跳跃寻址：本条指令给出下一条指令的地址 4.2.2数据寻址1）隐含寻址不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址 。 优点：有利于缩短指令字长 缺点：需增加存储操作数或隐含地址的硬件 2）立即寻址形式地址A就是操作数本身，又称为立即数，一般采用补码形式。 #表示立即寻址特征。 优点：指令执行阶段不访问主存，指令执行时间最短 缺点：A的位数限制了立即数的范围。数据范围为−2^n～(2^n) − 1 3）直接寻址指令字中的形式地址A就是操作数的真实地址EA，即EA&#x3D;A 优点：：简单，指令执行阶段仅访问一次主存， 不需专门计算操作数的地址。 缺点：A的位数决定了该指令操作数的寻址范围。 操作数的地址不易修改。 4）间接寻址指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址 所在的存储单元的地址，也就是操作数地址的地址，即EA&#x3D;(A) 。 优点：可扩大寻址范围，方便编址程序 缺点：指令在执行阶段要多次访存 5）寄存器寻址在指令字中直接给出操作数所在的寄存器编号，即EA &#x3D;Ri，其操作数在由Ri所 指的寄存器内。 优点：指令在执行阶段不访问主存，只访问寄存器， 指令字短且执行速度快，支持向量&#x2F;矩阵运算。 缺点：寄存器价格昂贵，计算机中寄存器个数有限 。 6）寄存器间接寻址寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址， 即EA&#x3D;(Ri) 。 特点：与一般间接寻址相比速度更快，但指令的执 行阶段需要访问主存(因为操作数在主存中)。 7）相对寻址把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址， 即EA&#x3D;(PC)+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示 。 在PC+1的基础上进行一定的位移 8）基址寻址将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A， 而形成操作数的有效地址，即EA&#x3D;(BR)+A。 优点：便于程序”浮动”，方便实现多道程序并发运行 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。 9）变址寻址有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和， 即EA&#x3D; (IX)+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。 优点：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便 可很容易形成数组中任一数据的地址，特别适合编制循环程序。 变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变 （IX作为偏移量），形式地址A不变（作为基地址） 10）堆栈寻址操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。 堆栈是存储器（或专用寄存器组）中一块特定的按”后进先出（LIFO）” 原则管理的存储区，该存储区中被读&#x2F;写单元的地址是用一个特定的寄存 器给出的，该寄存器称为堆栈指针（SP） 4.3 CISC和RISC 注意！！1、各常见指令寻址方式的特点和使用情况​ 1）立即寻址操作数获取便捷，通常用于给寄存去赋初值 ​ 2）直接寻址相对于立即寻址，缩短了指令长度 ​ 3）间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回 ​ 4）寄存器寻址的指令字较短，指令执行速度较快 ​ 5）寄存器间接寻址扩大了寻址范围 ​ 6）基址寻址扩大了操作寻址范围，使用于多道程序设计，常用于为程序设计或数据分配存储空间 ​ 7）变址寻址主要用于处理数组问题，适合编制循环程序 ​ 8）相对寻址用于控制程序的执行顺序、转移等 ​ 9）基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址是动态的，基址寄存器的内容由操作系统控制固定不变的；在变址寻址中，程序员操作的是变址寄存器是动态的，偏移地址是固定不变的 2、一个操作数在内存中可能占多个单元，怎么在指令中给出操作数的地址​ 现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数可能是8位、16位、32位、64位。因此可能占用1个、2个、4个、8个内存单元。一个操作数可能有多个内存地址对应 ​ 大端方式：指令中给出的地址是操作数最高有效字节所在的地址 ​ 小端方式：指令中给出的地址是操作数最低有效字节所在的地址","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"第三章:存储系统","slug":"第三章：存储系统","date":"2022-05-15T13:24:52.000Z","updated":"2022-05-15T12:51:35.629Z","comments":false,"path":"2022/05/15/第三章：存储系统/","link":"","permalink":"https://wjjhui.github.io/2022/05/15/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"虚拟存储器和Cache相同点1、目的都是为了提高系统性能 2、数据分为小信息块 3、都存在地址映射，替换算法，更新策略 4、按照局部性原理，讲活跃的数据放到高速部件中 不同点1、Cache解决系统速度问题，虚拟存储器解决主存容量问题 2、Cache全部由硬件实现，是硬件存储器。虚拟存储器由OS和硬件共同实现，是逻辑上的存储器 3、Cache对程序员透明，虚拟存储器对应用程序员透明，对系统程序员不透明 4、虚拟存储器不命中对系统性能影响更大 5、CPU只能与Cache和主存直接交互，虚拟存储系统只能先将数据从硬盘调入主存，不能与CPU直接通信 3.1存储器的层次结构3.1.1存储器的分类层次分类多级存储器结构 主存 存放计算机运行时的程序与数据 可以被CPU直接访问，也可以与Cache和赋存进行交换数据 容量小、速度块、价格高 辅存 存储当前暂时不用的程序和数据，以及一些永久保留数据 不可以与CPU直接交换数据 容量大、速度慢、价格低 高速缓冲存储器 位于主存与辅存之间，缓解CPU与主存之间的速度差距问题 CPU可以直接访问 容量小、速度与CPU想匹配，价格高 存储介质分类磁表面存储器：磁盘、磁带 磁芯存储器半导体存储器 光存储器：光盘 存取方式分类随机存储器（RAM） 随机存取：读写方便、使用灵活 用途：主存、高速缓冲存储器 类型：静态SRAM（触发器原理），动态DRAM（电容原理） 只读存储器（ROM） 只能读出不能写入 用途：与随机存储器构成主存，存储固定不变的程序 ROM也派生出可以反复重写的类型 信息可保存性易失性存储器 RAM,断电后信息丢失 非易失性存储器 ROM，断电后信息保持 3.1.2存储器的性能指标计算机追求目标：大容量、低成本、高速度 存储容量&#x3D;存储字数*字长 单位成本&#x3D;总成本&#x2F;容量 3.2主存储器3.2.1 半导体存储芯片1、存储矩阵：大量相同点的为存储单元阵列构成 2、译码驱动：地址信号翻译成对应存储单元的选通信号 3、读写电路：完成读写操作 4、读&#x2F;写控制线：决定芯片读&#x2F;写 5、片选线：确定那个芯片被选中 6、地址线：单项输入、位数与存储字的个数有关 7、数据线：双向的，位数与读出或写入的数据位有关 8、存储器的读写周期 RAM读周期：存储芯片进行两次连续读操作时，必须间隔一定的时间，读周期总是大于等于读出时间 RAM写周期：数据总线上的信息能够可靠的写入存储器 3.2.1 SRAM1、使用双稳态触发器记忆信息 2、非破坏性读出，易失性存储器 3、存取速度块、集成度低、功耗大、成本高、常用于高速缓冲存储器 4、同时送行列地址 3.2.3 SDAM1、利用电容存储信息 2、破坏性读出，易失性存储器 3、存取速度慢、集成度高、功耗低、容量大、成本低、常用来组成主存 4、分两次送行列地址 5、刷新方法 刷新的单位是行 集中刷新：在一个周期利用一段固定的时间进行刷新操作，存在死区 分散刷新：把每行的刷新分散到各个工作周期中，存取周期变长 异步刷新：刷新周期除以行数得到t，没隔t时间就刷新一次 3.2.4 ROM特点1、随机存取、非易失性存储器 2、结构简单，位密度比可读写存储器高 ROM类型掩膜式只读存储器MROM 一次性可编程只读存储器PROM 紫外线擦除只读存储器EPROM 点擦除只读存储器EEPROM 3.3主存储器和CPU的连接连接原理主存储器与CPU连接（数据总线、地址总线、控制总线） 主存容量的扩充位扩展 字扩展 字位扩展 存储器与CPU的连接选择合理的存储芯片RAM：为用户编程设置的 ROM：存放系统程序 地址线的选择CPU地址线地位与存储芯片的地址线连接 CPU地址线高为用于扩充芯片使用 数据线的连接CPU数据线与存储芯片线数相等时直接连接 CPU数据线与存储芯片数不等时：必须对存储芯片进行扩充 读&#x2F;写命令线的连接可能是一根也可能是两根 片选线的选择 片选线的作用在于选择那一片存储芯片被选中 3.4双端口RAM和多模块存储器目的：为了提高CPU访问存储器的速度采用双端口存储器、多模块存储器双端口RAM一个存储器有左、右两个独立端口、分别具有两组相互独立的地址线、数据线、读写控制线 冲突 1、对同一个地址单元，两个端口同时写入数据 2、对于同一个地址单元，一个端口写、一个端口读 无冲突 1、对同一个地址单元，两个端口同时读 2、对于同一个地址单元，两个端口不同时写 多模块存储器目的：为了提高访问速度 单体多字存储器按照地址顺序读出数据，存储单元存储m个字，总线宽度也为m个字，一次性并行读出m个字 有点：增大了存储器带宽，提高单体存储器工作速度 多体并行存储器多个模块构成，每个模块有这相同的容量和存取速度，各模块即可并行工作又可以交叉工作 高为交叉地址：本质上仍然是顺序存储器 低位交叉编址：可以提高存储器的带宽 3.5高速缓冲存储器程序访问的局部性原理时间局部性：将要使用的信息，可能是现在正在使用的信息 空间局部性：将来要使用的信息，可能正在使用信息的存储空间的附近 Cache工作原理通常使用SRAM制作 存储主存中最为活跃的信息副本，按照某种策略将这些活跃的信息写入Cache中 CPU发出读请求，Cache命中直接对Cache进行操作，Cache未命中则访问主存操作并将访问数据送入Cache中 Cache工作原理 Cache与主存的映射方式直接映射主存数据块只能装入Cache中的唯一位置 地址结构 ：主存字快标记 Cache行号 字块内地址 Cache行号&#x3D;主存块号 mod Cache总行数 全相联映射主存数据块可以放在Cache中的任何位置 地址结构：主存块号 块内地址 组相联映射将Cache分成Q大小相等的组，主存的数据块可以装入一组内的任何位置 地址结构：标记 Cache组号 块内地址 Cache组号&#x3D;主存块号 mod Cache组数 Cache中的替换算法随机算法：随机替换Cache块优点：实现简单 缺点：没有依据局部性原理，命中率低 先进先出算法（FIFO）：最早调入的行进行替换优点：容易实现 缺点：没有依据局部性原理 近期最少使用算法（LRU）：根据局部性原理，选这近期内最久没有访问的存储行优点：平均命中率高 缺点：需要设计计数器比较存储行 最不经常使用算法：一段时间内访问次数最少的存储行换出Cache写策略写命中全写法：对Cache命中后，数据同时写入Cache和主存 写回法：对Cache命中后时，只修改Cache内容，当Cache交换时才修改主存内容 写不命中写分配法：加载主存中的块到Cache中，然后更新Cache块 非写分配法：只写入主存，不进行调块 多级Cache：可以有效避免频繁写时造成的写缓冲和溢出3.6虚拟存储器基本概念1、将主存或者辅存的地址空间统一编址 2、实地址对应的是主存地址空间 3、使用虚拟地址需要辅助硬件找出虚地址和实地址之间的关系，并对其对应存储单元装入状态进行判断 4、实际情况：需要使用的先送入主存，暂时不用的放在磁盘中 页式虚拟存储器以页为基本单位的虚拟存储器称为页式虚拟存储器 计算过程 虚拟地址&#x3D;虚页号+页内地址 虚页号+页表起始地址&#x3D;页表地址 实页号+页内地址&#x3D;实地址 地址变换过程 段式虚拟存储器按照程序的逻辑结构划分 计算过程 虚地址&#x3D;段号+段内地址 段号+段表起始地址&#x3D;段表地址 实地址&#x3D;段表所得数据+段内地址 地址变换过程 段页式存储器先将程序按逻辑分段，再将每段分为固定大小页 段长必须是页的整数倍 虚地址&#x3D;段号+段内页号+页内地址 快表TLB根据局部性原理，将一些经常访问的页放入高速缓冲器中构成快表，可以极大的提高查询的效率 采用相联存储器的构成，可以按照内容查询 访问顺序：TLB–&gt;页表–&gt;Cache–&gt;主存 命中情况Cache命中，page必然命中，TLB不一定命中 Cache不命中，无法判断TLB和page命中情况 page不命中，Cache和主存不会命中，此时要执行调页策略 3.7注意！！1、存取时间Ta和存储周期Tm​ 存取时间Ta是执行一次读操作或写操作的时间，分为读出时间和写入时间。读出时间是从主存接收到有效地址开始到数据稳定为止的时间；写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间 ​ 存取周期Tm 是指存储器进行连续两次独立地读或写操作所需的最小时间间隔。所以Tm&gt;Ta 2、Cache行的大小和命中率之间的关系​ 行的长度较大，可以充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个 ​ 1）行长太大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块 ​ 2）行长太大，Cache项数变少，因而命中的可能性变小 3、发生取指令Cache缺失的处理过程​ 1）程序计数器恢复当前指令的指 ​ 2）对主存进行读的操作 ​ 3）将读入的指令写入Cache中，更改有效位和标记位 ​ 4）重新执行当前指令","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"第二章:运算方法与运算器","slug":"第二章：运算方法与运算器","date":"2022-05-11T13:24:52.000Z","updated":"2022-05-15T10:43:50.459Z","comments":false,"path":"2022/05/11/第二章：运算方法与运算器/","link":"","permalink":"https://wjjhui.github.io/2022/05/11/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8/","excerpt":"","text":"2.1定点数的表示有符号与无符号无符号数：整个机器字长的全部二进制均为数值位 有符号数：最高位的0&#x2F;1表示正&#x2F;负 机器数定点表示定点小数：定点小数是纯小数，约定小数点位置在符号位之后 定点整数：定点整数是纯整数，小数点位置在有效数值部分的最低位后 机器数表示方法原码表示：最高位位符号位，其余的为数值位 反码表示：符号位不变，数值位取反。 补码表示：符号位不变，数值位取反+1，实现加法器做减法 移码表示：符号位取反，数值位不变，用于真值比较大小 2.2定点数的运算移位运算算数移位 1、正数：移位补0 2、负数 #原码：补0 #反码：补1 #补码：左移补0，右移补1 符号位不参与 逻辑移位 将操作数看作无符号数 左移或右移都补0 循环移位 带进位标志位的循环移位 不带进位标志位的循环移位 原码加减加法准则 符号相同：绝对值相加，符号不变 符号不同，绝对值大的间去绝对值小的 减法准则 减去一个数&#x3D;加上这个数的负数 补码加法[A+B]补 &#x3D; [A]补 + [B]补 [A-B]补 &#x3D; [A]补 + [-B]补 溢出判断溢出判断：01为正溢出，10为负溢出 1、一位符号位：参加运算的两个符号数相同，但结果符号发生变化，即发生了溢出 2、双符号位：01正溢出，10负溢出 3、单符号位与数据进位：符号位与最高位进位相同，则无溢出 原码一位乘法符号位：两个符号位异或 累加次数：n 右移补0 符号位不参与运算 原码一位乘法图解 补码一位乘法累加次数：n+1 负数右移补1 符号位参与运算 补码一位乘法图解 原码除法恢复余数符号位不参与运算 左移补0 每次减法之后判断余数是否为负数，若为负数则恢复 若最终余数为负数，则需要恢复余数 原码除法：恢复余数法（手算） 不恢复余数（加减交替法）符号位不参与运算 左移补0 余数符号位为1商0，符号位为0则商1 原码除法：加减交替法 补码除法（加减交替法）符号位参与运算，采用双符号位 除数与余数同号商1，异号商0 商末位恒置1 补码除法：加减交替法 2.3浮点数的表示表示格式1、阶码：整数，阶符与阶码的位数共同反映浮点数的表示范围与小数点的实际位置 2、数符：表示浮点数的符号 3、尾数：尾数的位数表示浮点数的精度 规格化浮点数左规：尾数算术左移一位，阶码减1 右规：尾数算术右移一位，阶码加1，可能出现溢出 原码规格化正数：0.1xxxx 负数：1.1xxx 尾数最高一位不为0，基数4最高两位不为0，基数5最高三位不为0 补码规格化正数：0.1xxx 负数：1.0xxx IEEE754阶码&#x3D;真值+偏置值 2.4浮点数的加减运算运算步骤1、对阶：小阶向大阶对齐，尾数右移，阶码+1 2、尾数求和：按照定点数加减规则运算 3、规格化：最高数值位与符号位不同即为规格化形式 4、舍入： 0舍1入法 恒置1法 5、溢出判断： 只有右规，仍然溢出，此时才是真正溢出 上溢出：进入中断处理 下溢出：按机器零处理 6、强制类型转换 char–&gt; 在前面补0 int&lt;—-&gt;unsigned 彼此都可能因为溢出丢失数据 int&lt;—&gt;float 边界对齐现代计算机通常是字节编址，即每个字节对应1个地址 通常也支持按字、半字、字节寻址","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"第一章:计算机系统的概述","slug":"第一章：计算机系统的概述","date":"2022-05-01T12:50:18.000Z","updated":"2022-05-15T10:44:23.841Z","comments":false,"path":"2022/05/01/第一章：计算机系统的概述/","link":"","permalink":"https://wjjhui.github.io/2022/05/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1.1计算机发展历程计算机的硬件发展第一代：电子管时代 第二代：晶体管时代 第三代：中小规模集成电路时代 第四代：超大规模集成电路时代 元件的更新变化 摩尔定律：18个月晶体管翻一番 半导体存储器不断发展 微处理器不断地发展 计算机软件发展面向机器：机器语言和汇编语言 高级语言：FORTRAN-&gt;PASCAL-&gt;C++-&gt;… 计算机的分类和发展方向电子计算机 电子模拟计算机 电子数字计算机 数字计算机 专用计算机 通用计算机 1.2计算机体系结构计算机系统的构成硬件和软件 功能实现：硬件和软件再逻辑上是等效的，硬件实现效率高但成本高 计算机的硬件的基本组成早期 冯·诺依曼 组成：运算器、存储器、控制器、输入设备、输出设备 指令与数据共存与存储器，按地址访问 指令与数据以二进制代码构成 指令组成：操作码与地址吗 指令顺序存放，顺序执行 运算器为中心，输入输出设备通过运算器与存储器传送数据 “存储程序”：讲指令以二进制代码的形式事先输入计算机的主存储器，然后再执行 现代计算机体系结构 存储器为中心 I&#x2F;O操作尽可能的绕开CPU，实现I&#x2F;O设备与存储器直接完成，从而提高运行效率 计算机软件的分类以功能分类 系统软件 应用软件 语言分类 机器语言 汇编语言 高级语言 计算机工作过程具体步骤 1、程序、数据装入主存 2、从程序起始地址开始运行 3、程序首地址取出指令-&gt;指令译码-&gt;完成功能并计算下一条指令地址 4、新得到的指令地址读出下一条指令，直到程序结束 信息流程 取指令：PC–&gt;MAR–&gt;M–&gt;MDR–&gt;R 分析指令:OP(IR)–&gt;CU 执行指令:AD(IR)–&gt;MAR–&gt;M–&gt;MDR–&gt;ACC 计算机系统得多级层次结构1、虚拟机器（高级语言机器） 2、虚拟机器（汇编语言机器） 3、虚拟机器（操作系统机器） 4、—-软硬件交互界面—- 5、传统机器（使用机器语言的机器） 6、微程序机器（微指令系统） 各硬件主存 存储体：存储元、存储单元、存储字、存储字长、地址 MAR：地址寄存器，用于指明要读&#x2F;写哪个存储单元 MDR：数据寄存器，存放操作数，用于暂存要读&#x2F;写的数据 运算器 ACC：累加计数器，存放操作数、运算的结果 MQ：乘商寄存器，进行乘，除法时的寄存器 X：通用寄存器，存放操作数 ALU：算术逻辑运算单元，用电路实现各种式算法运算、逻辑运算 控制器 PC：程序计数器，存放下一条指令的地址 IR：指令寄存器，存放当前执行的指令 CU：控制单元，分析指令，给出控制信号 工作过程 初始：指令、数据存入主存，PC指向第一条指令 从主存中取出指令放入IR、PC自动加1，CU分析指令、CU指挥其他部件执行指令 1.3计算机性能指标 机器字长计算机进行一次整数运算课处理的二进制位数 1、受到CPU寄存器位、加法器影响 2、一般情况下机器字长等于内部寄存器大小 3、字长越长，表示范围越大，精度越高 数据通路带宽数据总线一次性所能传送信息的位数 主存容量主存储器的最大容量，MAR位数反应了存储单元的个数，反映了最大寻址范围 运算速度吞吐量 单位时间内处理请求的数量 取决于主存的存取周期 响应时间 用于发送请求，然后系统对请求做出响应并且获得所得结果的等待时间 CPU时钟周期节拍脉冲或者是T周期，1&#x2F;主频 CPU的最小时间单位，每个动做至少需要一个时钟周期 主频 机器内部主时钟的频率，衡量机器速度的重要参数 CPI执行一条指令所需要的时钟周期数 CPU执行时间运行一个程序所花时间 影响因素：主频、指令条数、每条指令的执行周期 计算能力 MIPS：每秒执行多少条百万指令 MFLOPS：每秒执行多少百万次浮点运算 GFLOPS：每秒执行多少十亿次浮点运算 TFLOPS：每秒执行多少万亿浮点运算 1.3注意问题1、翻译程序、解释程序、汇编程序、编译程序的区别和联系翻译程序程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无需重新翻译。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直到所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并不会生成目标程序 汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序 2、字、字长、机器字长、指令字长、存储字长的区别和联系通常说的“某16位或32位机器”中，16、32指的是字长，也就是机器字长。所谓字长，通常是指CPU内部用于整数运算得数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度。 指令字长：一个指令字中包含的二进制代码的位数 存储字长：一个存储单元存储的二进制代码的长度 它们都必须是字节的整数倍","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"第五章:IO管理","slug":"第五章：IO管理","date":"2022-04-30T12:28:49.000Z","updated":"2022-05-15T10:44:11.516Z","comments":false,"path":"2022/04/30/第五章：IO管理/","link":"","permalink":"https://wjjhui.github.io/2022/04/30/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AIO%E7%AE%A1%E7%90%86/","excerpt":"","text":"5.1 IO管理概述I&#x2F;O设备人机交互的外部设备 用于计算机用户之间交互设备（打印机，鼠标，键盘） 交换速度相对较慢，以字节为单位进行数据交换 存储设备 用于存储程序和数据的设备（磁盘、磁带、光盘） 交换速度较快，以多字节组成的块为基本单位交换 网络通信设备 用于远程设备通信的设备（网络接口、调制解调器） 速度介于前两类之间 传输速率分类 低速设备：每秒进位几个字节到数百字节 中速设备：传输速率为每秒在数千字节至数万字节 高速设备：传输速率在数百字节到千兆字节的一类设备 信息交换单位分类 块设备：信息存取总是以数据块为基本单位，存储信息的设备为块设备，传输速率高，可寻址，可以任意读写某块 字符设备：用于数据输入输出的设备为字符设备，传输的基本单位是字符，传输速率低，不可寻址 I&#x2F;O控制方式程序直接控制方式 计算机从外部设备读取数据到存储器，每次读一个字的数据，对读入的每个字，CPU都要对外设状态进行循坏检查，知道确定该字已经在I&#x2F;O设备控制器的数据寄存器中 读写单位：字 优点：容易实现，操作简单 缺陷：CPU高速性和IO设备的低速性的矛盾，CPU和IO设备只能串行工作 中断驱动方式 允许IO设备主动打断CPU的运行并请求器，进而解放CPU，使其向IO控制器发送读命令后可以继续做其他有用的工作 读写单位：字 优点：比程序直接控制方式有效 缺点：数据的传输必须要经过CPU，仍然后消耗CPU的时间 DMA方式 在IO设备和内存之间开辟直接的数据交换通路，彻底解放CPU 特点 读写单位：数据块 设备直接送入内存 只有当一个或多个数据块开始和结束的时候，CPU才会进行干预 寄存器 命令&#x2F;状态寄存器（CR）：用于接收CPU发送的IO命令和有关控制信息或者设备状态 内存地址寄存器（MAR）：数据直接在设备与内存之间交互 数据寄存器（DR）：用于暂存从设备到内存或者从内存到设备的数据 数据计数器（DC）：存放本次要传送的字节数 通道控制方式 设置一个专门负责输入&#x2F;输出的处理机，实现对一组数块的读写以及相关控制和管理为单位干预 读写单位：一组块 优点：有效的提高了系统资源利用率 缺点：实现较为复杂 DMA 和通道的区别DMA需要CPU来控制传输的数据块的大小，传输的内存位置，而通道方式中这些信息是有通道控制的 DMA控制器对应一台设备与内存传递数据，通道可以控制多台设备与内存的数据交换 I&#x2F;O系统的的层次结构层次划分 用户层IO软件：实现与用户交互的接口，用户可以直接调用在用户层提供与IO操作有关的函数，对设备进行操作 设备独立性软件： 用于实现用户程序与设备驱动的统一接口、设备命令、设备保护及设备分配与释放，同时为设备管理与数据传送提供必要的存储空间 设备独立性也称为设备无关性，使得应用程序独立于具体使用的物理设备 使用逻辑设备的好处：增加设备分配的灵活性，易于实现IO重定向 主要功能：执行所有设备的公有操作，向用户层提供统一接口 设备驱动程序：与硬件直接相关，负责实现系统对设备发出的操作命令，驱动IO设备工作的驱动程序 中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回被中断的进程 硬件设备：IO设备通常包括一个机械部件和电子部件 层次划分图解 设备控制的功能 接收和识别CPU或通道发来的命令 实现数据交换 发现和记录设备及自身的状态信息，供CPU处理使用 设备地址识别 设备控制器的组成 设备控制器与CPU的接口 信号线 数据线 地址线 控制线 设备控制器与设备的接口，每个接口存在数据、控制和状态三种类型的信号 IO控制逻辑，用于实现对设备的控制。通过一组控制线与CPU进行交互，对从CPU收到的IO命令进行译码 注意！！！ 1、一个I&#x2F;O控制器可能对应多个设备 2、数据寄存器、控制寄存器、状态寄存器可能有多个，且这些寄存器都要有相应的地址，才能方便CPU操作 3、有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像IO 4、一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址 5.2 IO核心子系统IO子系统概述主要提供IO调度，缓冲与高速缓存，设备分配与回收、假脱机、设备保护或差错处理 IO调度概念通过IO调度改善系统性能，使得进程之间公平共享设备访问，减少IO完成所需要的的平均等待时间 使用主存或者磁盘上的存储空间的计数，如缓冲、高速缓存、假脱机等来改善计算机效率 高速缓存与缓冲区磁盘高速缓存 使用磁盘高速缓存技术可以提高磁盘的IO速度，对高速缓存复制的访问要比原始数据访问更高效 磁盘高速缓存，逻辑上属于磁盘，物理上属于驻留在内存中的盘块 在内存中的两种形式 在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定 把未利用的内存空间为作为一个缓冲池，供请求分页系统和磁盘IO时共享 缓冲区 引入缓冲区的目的 1、缓和CPU与IO之间的速度差异矛盾 2、减少对CPU的中断频率，放宽对CPU中断响应时间的限制 3、解决基本数据单元大小不匹配的问题 4、提高CPU和IO设备之间的并行性 实现方法 采用硬件缓冲器（成本高），除了关键位置，一般不使用硬件缓冲器 采用缓冲区（位于内存） 分类 c：CPU对数据的处理时间 t：数据写入缓冲区的时间 m：缓冲区数据传入用户区的时间 单缓冲 设备和处理之间设置缓冲区，设备和处理机交换数据的时候，先把被交换的数据写入缓冲区，然后需要数据的设备或处理机从缓冲区中取走数据 使用时间max（c,t）+m 双缓冲 设置两个缓冲区，当缓冲区1满时，向缓冲区2注入数据，只有缓冲区满才能取出数据 提高了处理和输入设备的并性操作程度 ####### max（c+m，t） 循环缓冲：包含多个大小相等的缓冲区，每个缓冲区有一个链接指针指向下一个缓冲区，最后一个缓冲区指向第一个缓冲区，多个缓冲区构成一个环形 缓冲池： 缓冲区分为三个队列，空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列 四种缓冲区：收容输入数据的工作缓冲区，提取输入数据的缓冲队列，装满输出数据的缓冲队列 注意！！！：管道通信中的管道起始就是缓冲区，要实现数据的双向传输必须设置两个管道 高速缓冲与缓冲区对比 相同点： 都介入高速设备和低速设备之间 不同： 存放数据 高速缓存：存放的是低速设备上的某些数据的复制数据 缓冲区：存放的是低速设备传递给高速设备的数据，这些数据在低速设备上不一定有备份，这些数据再从缓冲区传送到高速设备 目的 高速缓存：高速缓存存放的高速设备经常要访问的数据，如过高速缓存中数据不在，高速设备就要访问低速设备 高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会去直接访问低速设备 设备分配与回收概述：根据用户IO请求分配设备，原则：充分发挥设备的使用效率，避免进程死锁 设备类型分类 独占式使用设备：设备只能互斥使用 分时共享使用设备：通过分时共享来提高设备的利用率 SPOOLin假脱机：使用空间换时间，对IO设备进行批处理 设备分配的数据结构 1、系统设备表（SDT）:记录已经连接到系统中所有物理设备的情况 2、设备访问控制表（DCT）：一个设备控制表表示一个设备，控制表中是设备的各项属性 3、控制器控制表（COCT）：COCT与DCT一一对应关系，DCT需要一个表项来表示控制器，即一个指向控制器控制表的指针 4、通道控制表（CHCT）:CHCT提供服务的哪几个设备控制 设备分配的策略 分配原则：充分发挥设备效率，避免进程死锁 分配方式 静态 系统一次性的把设备分配给响应作业，知道作业结束 优点：没有死锁问题 缺点：降低了设备使用率 动态 进程执行过程中根据执行需要进行分配 优点：提高了设备利用率 缺点：分配算法不当可能导致死锁 设备分配算法 先请求先分配 优先级高者优先 独占设备一般使用静态分配，共享设备一般使用动态分配 IO调度设备分类 独占设备：一个时段只能分配给一个进程 共享设备：可同时分配给多个进程使用，各进程往往是宏观上同时共享使用设备，而微观上交替使用 虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用 设备分配的安全性 安全设备分配 进程发出IO请求后便进入阻塞态，知道IO结束才被唤醒 优点：设备分配安全 缺点：CPU和IO设备串行工作 不安全分配方式 进程发出IO请求后继续运行，需要时发出第二个，第三个请求 优点：进程推进迅速 确定点可能产生死锁 逻辑设备名到物理设备名的映射 目的 1、提高设备分配的灵活零和利用率 2、实现IO重定向 3、引入设备独立性 实现方法：引入逻辑设备表（LUT），用来将逻辑设备名映射为物理设备名 建立方式 整个系统设置一张LUT，所有设备分配情况读记录在这张表上 每个用户建立一张LUT，分步记录设备的分配情况 SPOOLing技术目的：缓解CPU和IO速度差异矛盾 要实现SPOOLLing技术，必须要有多道程序技术的支持 输入井和输出井 输入并用来收容IO设备的数据 输出井用来模拟输出时的磁盘 输入缓冲区和输出缓冲区 输入缓冲区：暂存由输入设备送来的数据 输出缓冲区：暂存从输出井送来的设备 输入进程和输出进程 输入进程：模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲送到输入井，当CPU需要数据，直接将输入井的数据送入内存 输出进程：模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，在将输出井的数据经过输出缓冲区送到输出设备 特点 1、提高了速度 2、独占设备变成了共享设备 3、实现了虚拟设备功能 通俗一点就是，如果设备被占用就先将数据暂存一下，等到设备空闲了就把这些数据输送到设备中","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第四章:文件管理","slug":"第四章：文件管理","date":"2022-04-25T11:31:50.000Z","updated":"2022-05-15T10:44:06.047Z","comments":false,"path":"2022/04/25/第四章：文件管理/","link":"","permalink":"https://wjjhui.github.io/2022/04/25/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"4.1文件系统基础文件的相关概念 相关定义 1、文件是以计算机硬盘为载体的存储在计算机上的集和，文件可以是文本文档、图片、程序等 2、系统运行时，计算机以进程为基本单位进行资源的调度和分配 3、在用户输入输出时，以文件为基本单位 4、操作系统的文件系统：用于实现文件的权限访问，修改，查询和保存等功能 5、文件结构 数据项：数据项是文件系统中最低级的数据组织形式 记录：一组数据项的集和，用户描述一个对象在某方面的属性 文件：创建者所定义的一组相关信息的集和 文件的属性 1、名称：文件名称唯一，以容易读取的形式保存 2、标识符：文件的唯一标签，通常为数字，是对人不可读的一种内部名称 3、类型：被支持的不同类型的文件系统所使用 4、位置：指向设备和设备上文件的指针 5、大小：文件当前的大小，包含文件允许的最大值 6、保护：对文件进行保护的访问控制信息 7、时间、日期和用户标识：文件的创建、修改和上次访问的相关信息，用于保护和跟踪文件的使用 文件的基本操作 1、创建文件：1）文件系统为文件找到空间 2）目录为文件创建条目，该条目记录文件名称，在文件系统中的位置以及其他可能的信息 2、写文件：执行系统调用：指明文件名和写入内容，查找文件位置，为该文件维护一个写位置的指针，当发生写操作的时候更新写指针 3、读文件：执行系统调用：指明文件名和文件位置，搜素目录项，系统维护一个读指针，发生读操作就对该指针进行更新 4、文件重定位：按照某种条件搜索目录，将当前文件设置定值，并且不会读、写文件 5、删除文件：搜索目录，找到文件的目录项，使其变为空项，然后回收目标文件占用的存储空间 6、截断文件：允许文件的所有属性不变，并删除文件内容，即将其长度设为0并释放空间 文件的打开和关闭 open请求 首次使用文件，会调用open请求指明文件的属性（包括其物理位置）从外存复制到内存打开文件表的一个表目中，并将该表目的编号返回给用户 操作open会根据文件名搜索目录，并将目录条目复制到打开文件 文件关联信息 1、文件的指针：系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对于打开文件的某个进程说是唯一的，因此必须与磁盘文件属性分开保存 2、文件打开计数：文件关闭，必须重用其打开表条目，否则表内空间会不够用，计数器为0关闭文件，删除该条目 3、文件磁盘位置：该信息存储在内存存放，以免每个操作都要从磁盘中读取 4、访问权限：每个进程打开文件都需要一个访问模式，该信息保存在进程打开的文件表中，以便操作系统能够允许或拒绝之后的I&#x2F;O请求 文件的逻辑结构 无结构文件 1、最简单的文件组织形式 2、将数据按照顺序组织记录并积累、保存、是有序相关信息项的集和 3、由于其没有结构，所有只能采用穷举搜索 4、管理简单，方便用于对其操作 5、基本信息单位操作不多的文件适合采用字符流的无结构方式 有结构文件 顺序文件 1、文件的记录是一个接一个排列，记录通常是定长的，可以顺序存储或者链表存储 2、批量处理时，顺序文件的效率是所有逻辑文件中效率最高的 3、但是增删改查操作比较困难 索引文件 定长记录文件 按照公式A&#x3D;i*L可以直接得到文件地址 变长记录文件 查找i-1条记录后，才能查找第i条记录 通过建立索引表后可以有效提高查找速度 索引顺序文件 1、顺序和索引两种组织形式的结合 2、索引文件将顺序文件中所有记录分成若干段，为顺序文件建立起一张索引表，在索引表中为每组中第一条记录建立一个索引项，其中含有该记录的关键字和指向该记录的指针 3、索引顺序文件提高了查找效率，但是索引表也占用了存储空间 直接文件或散列文件 1、给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址 2、这种映射结构不同于顺序文件或者索引文件，没有顺序的特性 目录结构 包含有关文件的信息，如属性、位置和所有权等 文件控制块和索引节点 文件控制块FCB 用来存放控制文件需要的各种信息的数据结构，实现”按名存取” 包含信息 1、基本信息：文件名、文件的物理位置、逻辑结构、物理结构等 2、存取控制信息：文件存取权限 3、使用信息：文件建立时间，修改时间 索引节点 检索目录文件时，不需要将文件调入内存，只是查找其目录项，文件的描述信息单独形成索引节点的数据结构 磁盘索引节点 1、文件主标识符：拥有该文件的个人或小组的标识符 2、文件类型：普通文件、目录文件、特别文件 3、文件存取权限：各类用户对该文件的存取权限 4、文件物理地址：每个索引节点中含有13个地址项，直接或者间接的方式给出数据文件所在盘块的编号 5、文件长度：字节为单位 6、文件链接计数：本文件系统中所有指向该文件的文件名的指针计数 7、文件存取时间：文件最近被进程存取，修改以及索引节点最近被修改的时间 文件打开后内存索引节点增加的内容 1、索引节点编号：用于标识内存索引节点 2、状态：表明i节点是否被上锁或者被修改 3、访问计数：每当有几个进程要访问i节点时，计数加1，访问结束为-1 4、逻辑设备号：文件所属文件系统的逻辑设备号 5、链接指针：设置分别指向空闲连接和散列队列的指针 目录结构 1、搜索：用户使用一个文件时，需要搜索目录，找到该文件对应的目录项 2、创建文件：创建一个新文件时，需要在目录中增加一个目录项 3、删除文件：删除一个文件时，需要在目录中删除相应的目录项 4、显示目录：用户可以请求显示目录的内容，显示该用户目录中的所有文件及属性 5、修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项 目录结构分类 单级目录结构 整个文件系统只建立一张目录表，每个文件占一个目录项 优点：实现了按名存取 缺点：查找速度慢，文件不允许重名，不便于文件共享，不适用于多用于的操作 二级目录结构 将文件分为主目录和用户目录，主目录记录用户名及相应的用户文件目录所在的存储位置，用户目录项记录该用户文件的FCB信息 优点：解决了用户文件重名问题，在一定程度上保证了文件的安全 缺点：缺乏灵活性，不能对文件进行分类 多级目录结构 将二级目录结构的层次关系加以推广，就形成了多级目录结构，即树形目录结构 进程对个文件的访问都是相对于当前目录进行的 优点：有效的对文件进行分类，文件结构层次清晰，能够有效的进行文件管理和保护 缺点：按照路径名访问中间节点，增加了磁盘访问次数，降低了查询速度 无环图目录结构 在树形目录结构基础上增加了一些指向同一节点的有向边，使整个目录称为一个有向无环图 优点：有利于实现文件共享 文件共享 基于索引节点的共享方式（硬链接） 文件目录中只设置文件名及指向相应索引节点的指针，在索引节点中还要一个链接计数count，用于表示本链接到本索引节点上的用户目录项的数目 硬链接是多个指针指向一个索引节点，保证只要还要一个指针指向索引节点，索引节点就不能删除 优点：硬链接的查找速度比软链接快 利用符号链实现文件共享（软连接） B用户共享A用户的文件时，系统创建一个link类型的文件，然后将link文件写入用户B的目录中，但是新文件中只包含有被链接的文件的路径名 软连接就是把达到共享文件的路径记录下来，当要访问时，根据路径寻找文件 优点：网络共享只需要提供该文件所在及其的网络地址及该机器中的文件路径 缺点：由于是根据文件路径名找到文件，因此会增加时间开销并且增加了启动磁盘的频率，同时符号链的索引节点也会耗费一定的硬盘空间 文件保护 为了防止文件共享导致文件被破坏或者未经允许修改文件，文件系统必须控制对用户的存取，解决对文件的读、写、执行等许可问题 实现方式 1、口令保护：用户请求方式需要提供相应的口令 优点：时间和空间开销不多 缺点：口令直接俄存储在系统内部不安全 2、加密保护：用户对文件进行加密，用户访问时需要密钥解密 优点：保密性强，节省了存储空间 缺点：加密和解密需要花费一定的时间 3、访问控制：根据用户身份进行控制 优点：可以使用复杂的访问方法 缺点：长度无法预计且可能导致复杂空间管理 4.2文件系统的实现文件层次结构 1、用户调用接口：文件系统为用户提供与文件及目录有关的调用 2、文件目录系统：管理文件目录，管理活跃文件目录表，管理读写状态信息表，管理用户进程打开的文件表，管理与组织存储设备上的文件目录结构，调用下一级存取控制模块 3、存取控制验证：实现文件保护，将用户的访问请求与FCB指示的访问权限控制进行比较，以确认访问的合法性 4、逻辑文件系统关于文件信息缓冲区：逻辑文件系统与文件系统信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号 5、物理文件系统：把逻辑记录所在的相对块号转换成实际的物理地址 6、辅助分配模块：管理辅存空间，负责分配辅存空闲空间和回收辅存空间 7、设备管理程序模块：分配设备，分配设备读写用缓冲区，磁盘调度，启动设备，处理设备中断，释放设备读写缓冲区，释放设备 文件层次结构实例 目录实现 线性列表 使用存储文件名和数据块指针的线性表 优点：实现简单 缺点：耗费时间 哈希表 根据文件名得到一个值，然后返回一个指向线性列表中元素的指针 优点：查找迅速，插入和删除简单 缺点：要避免重铸，哈希表长度固定以及哈希函数对表长有依赖性 文件实现 文件的分配方式 连续分配 每个文件在磁盘上占有一组连续的块，磁盘地址定义了磁盘上的一个线性排序 访存1次 优点：实现简单，存取速度块，使得访问磁盘需要的寻道数和寻道时间最小 缺点：文件长度不宜动态的增加，会产生外部碎片 链接分配 采用离散分配方式，提高了磁盘空间利用率，消除了外部碎片 访存n次 隐式链接 磁盘块分布在磁盘的任何地方，除最后一个盘块，其他盘块都有指向下一个盘块的指针 优点：不会有碎片问题，外存利用率高 缺点：不能直接访问，稳定性存在问题 显示链接 把用于链接文件各物理块的指针，从每个物理块的末尾提取出来，显示的存放在内存的一张连接表中，整个磁盘设置一张 优点：显著的提升检索速度，减少了磁盘访问次数 缺点，文件分配表需要占用一定的存储空间 索引分配 索引分配解决了连接分配不能直接访问的问题 m级要访问m+1次 优化机制 链接方案：一个索引块通常为一个磁盘块，为了处理大文件，可以将多个索引链接起来 多层索引：第一层索引块指向第二层索引块，第二层索引块指向文件快 混合索引：系统即采用直接地址又采用单级索引分配方式或者两级索引分配方式 文件存储空间管理 文件存储在一个文件卷中，文件卷可以是物理盘中的一部分，也可以是整个物理盘 文件存储设备分成许多大小相同的物理块，以块为单位交换信息 空闲块管理 空闲表法：属于连续分配方式，系统为空闲区建立一张空闲盘块表，每个空闲区第一个盘块号，该区的空闲盘块数等信息 空闲链表法：将所有的空闲盘区拉成一条空闲链，根据构成链所有的基本元素不同，可以分为空闲盘块链和空闲盘区链 位示图法 采用二进制的以为来表示一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应 成组链接法 UNIX使用，结合了空闲表和空闲链表法客服了表太大的缺点 把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区则保存另以顺序空闲扇区的地址 4.3磁盘组织与管理磁盘结构 表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头的导体线圈从磁盘读取数据 磁盘盘面上的数据存储在一组同心圆中，称为磁道 一个盘面有上千个磁道，磁道又划分为几百个扇区，每个扇区固定存储大小，一份扇区称为一个盘块 磁盘地址用柱面号-盘面号-扇区号表示 磁盘分类 1、固定头磁盘：磁头相对于盘片的径方向固定 2、活动头磁盘：每个磁道一个磁头，磁头可以移动 3、固定盘磁盘：磁头臂可以来回伸缩定位磁道，磁盘永久固定在磁盘驱动器内 4、可换盘磁盘：可以移动和替换 磁盘调度算法 读写时间组成 1、寻找时间：活动头磁盘在读写信息前，将磁头移动到指定磁盘所需要的时间 2、延迟时间：磁头定位到某一磁道扇区所需要的时间 3、传输时间：从磁盘读出或向磁盘写入数据经过的时间 磁盘调度算法 1、先来先服务算法(FCFS) 按照进程请求访问磁盘的先后顺序进行调度 优点：公平、实现简单 缺点：适用于少量进程访问，如果进程过多算法更倾向于随机调度 2、最短寻找时间优先算法(SSTF) 选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道 优点：性能强于先来先服务算法 缺点：容易产生饥饿现象 3、扫描算法(SCAN) 在磁头当前移动方向上选择与当前磁头所在的磁道距离最近的请求作为下一次服务对象 优点：寻道性能好，可以避免饥饿现象 缺点：对扫描过的区域不公平，访问局部性方面不如FCFS和SSTF好 4、循环扫描算法（C-SCAN) 磁头单向移动，回饭时直接回到起始段，而不服务任何请求 5、LOOK与C-LOOK算法 在SCAN的基础上改良而来，回到第一个请求处而不是回到起始段 对盘面交替编号 原因：磁头在读&#x2F;写一个物理块后，需要经过短暂的处理时间才能开始处理下一块 磁盘的管理 磁盘初始化 低级格式化：磁盘分扇区，为每个扇区采用特别的数据结构（头、数据区域、尾部组成），头部含有一些磁盘控制器所使用的信息 进一步格式化处理：磁盘分区，对物理分区进行逻辑格式化，包括空闲和已分配的空间及一个初始为空的目录 引导块 计算机启动运行自举程序，初始化CPU寄存器、设备控制器和内存等，然后启动操作系统 组局程序通常保存在ROM中，在ROM中保留很小的自举块，完整的自举程序保存在启动块上 拥有启动分区的磁盘称为启动磁盘或系统磁盘 坏块 无法使用的扇区 对于简单的磁盘，可以逻辑格式化时对整个磁盘进行坏块检查，标明哪些是坏扇区 处理方式 简单磁盘：手动处理，对坏块进行标记，程序不会使用 复杂磁盘：控制器维护一个磁盘坏块链表，同时是将一些块作为备用，用于替代坏块","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第三章:内存管理","slug":"第三章：内存管理","date":"2022-04-18T11:31:50.000Z","updated":"2022-05-15T10:43:55.799Z","comments":false,"path":"2022/04/18/第三章：内存管理/","link":"","permalink":"https://wjjhui.github.io/2022/04/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"3.1内存管理概念内存管理的基本原理和要求 程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾 内存管理的功能 1、内存空间的分配与回收：操作系统完成主存储器空间的分配和管理 2、地址转换：逻辑地址转换为物理地址 3、内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存 4、内存的保护：保护各道作业在各自存储空间运行，互不干扰 程序的装入和连接 创建步骤 1、编译：编译程序将用户源码编译成若干目标模块 2、链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块 3、装入：由装入程序将装入模块装入内存运行 程序装入步骤 链接的类型 1、静态链接：程序运行之前，将库函数链接成一个完整的可执行文件 2、装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接 3、运行时动态链接：对于某些目标模块的链接，程序需要时才会对其链接，便于修改和更新，便于实现对目标模块的共享 装入模式 1、绝对装入：装入时按照实际的内存地址，将程序和数据装入内存 优点：不需要对程序和数据的地址进行修改 缺点：只适用于单道程序环境 2、可重定位转入（静态重定位）：此时采用的是模块与模块的相对地址，然后将程序和数据装入内存，装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，又称为静态重定位 特点：作业装入必须要一次性全部装入，并且运行中作业不能在内存中移动，也不能申请内存空间 3、动态运行时装入（动态重定位）：装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，当程序真正执行时才进行转换 特点：需要重定位寄存器，可以将程序分配到不连续的存储区中，便于程序段的共享，可以想用户提供更大的地址空间 逻辑地址空间与物理地址空间 1、逻辑地址空间：即相对地址，链接程序一次按照各个模块的相对地址构成统一的从0号单元开始编址的逻辑空间地址 2、物理地址空间：内存中物理单元的集和，是地址转换的最终地址，进程在运行执行指令和访问数据，最后都要通过物理地址从主存中取出（地址重定位：逻辑地址转换成物理地址的过程） 内存保护 1、CPU中设置上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的数据比较，判断是否越界 2、重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）：重定位寄存器中包含最小物理地址值，解地址寄存器包含逻辑地址的最大值 覆盖与交换 覆盖 1、思想：将程序分为多个段。常用的段常驻内存，不常用的段在需要时调用内存 2、将用户空间分为一个固定区和若干覆盖区，活跃的放在固定区，即将访问的段放在覆盖区 3、特点：打破了必须将一个进程的全部信息装入主存后才能运行的限制，即访问的段放在覆盖区 交换 1、思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存和磁盘见动态调度） 2、换出：将处于等待状态的程序从内存中转移到辅存 3、换入：把准备好竞争CPU运行的程序从辅存转移到内存 4、结构：把磁盘空间分为文件区和对换区两部分 交换存在的问题 1、备份存储，使用快速硬盘，要求存储空间足够大，并且能够对内存映像进行访问 2、转移时间和所交换的内存空间成正比 3、只有进程空间状态才能将进程换出 4、交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来会很快 5、交换通常由许多进程运行且内存吃紧时开始启动，系统负荷降低就暂停 6、普通的交换使用不多，但交换策略的某些变体在许多系统中仍发挥作用 注意：PCB会常驻内存，不会被换出外存 连续分配管理方式 单一连续分配方式 内存分为系统区和用户区，系统区仅操作系统使用，通常在低地址部分，用户区为用户提供 优点：无需进行内存保护，不会出现越界异常。实现简单，无外部碎片，采用覆盖技术，不需要额外技术支持 缺点：只适用于单用户，单任务的操作系统。存在内部碎片，存储器利用率低 固定分区分配 种类 1、分区大小相等：用一台计算机区控制多个相同对象的场合，缺乏灵活性 2、分区大小不等：划分多个较小的分区，适量的中等分区和少量大分区 优点：适用于多道程序的存储，无外部碎片 缺点 1、程序太大，无法放进任何一个分区 2、主存利用考虑低，存在内部碎片 3、不能实现多进程共享一个主存区 动态分区分配 在进程装入内存的时候，根据内存的大小动态建立分区 优点：分区大小可以根据进程的实际情况进行分配 缺点：存在外部碎片，最后导致主存利用率下降，采用紧凑技术可缓解这种缺陷 动态分配算法 1、首次适应算法 2、邻近适应算法 3、最佳适应算法 4、最坏适应算法 非连续分配管理方式 允许一个程序分散的装入不相邻的内存分区 基本分页存储管理方式 设计思想 1、将主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位，进程以块为单位进行空间申请 2、分页存储和固定分区技术很像，但是其分页相对于分区又很小，分页管理不会产生外部碎片，产生的内部碎片也非常的小 分页存储的基本概念 页面和页面大小 1、进程中的块&#x3D;页 2、内存中块&#x3D;框 3、进程申请主存空间，为每个页面分配主存中可用页框，页与页框一一对应 地址结构：页号（有多少页的编号）+页内偏移（页内存了多少东西） 页表 1、为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中 2、页表项：页号+物理内存中块号 基本地址变换机构 基础地址变换结构图解 计算方式 1、页号P&#x3D;A&#x2F;L ，页内偏移量W&#x3D;A%L L：页面大小（即页内偏移量） 2、P&gt;&#x3D;M产生越界 P：页号，页表长度：M（从1开始） 3、页表中页号P对应的页表项地址B&#x3D;页表始址F+页号*页表项长度 4、计算E&#x3D;B*L+W 页表项大小的设计应当尽量一页正好装下所有的页表项 分页管理存在的问题 1、地址变换过程必须足够快，否则访存速率会降低 2、页表不能太大，否则会降低内存利用率 组成 1、设置一个页表寄存器（RTR），存放页表在内存中的起始地址F和页表长度M 2、页表的始址和页表长度放在进程控制块（PCB）中 具有快表的地址变换机构 可优化方向：如果页表放在内存中，取地址访问一次内存，按照地址取出数据访问一次内存，共需要访问两次内存 优化：地址变化机构中增加一个具有并性查找能力的高速缓存寄存器（快表），又称相联存储器（TLB） 访问一个逻辑地址的访存次数 基本地址变换结构：两次访存 具有快表的地址变换结构：一次或两次 具有快表的地址变换结构图解 变换过程 1、CPU给出逻辑地址后，先查询快表中是否命中 2、若快表命中，直接从快表中该页对应的页框与页内偏移量拼接成物理地址 3、若快表未命中，再按照正常方式从页表查询响应页表项，并将该页表项存入快表中 两级页表 1、逻辑地址空间格式&#x3D;一级页号+二级页号+页内偏移 2、设计多级页表的时候，一定要保证顶级页表一定只有一个 3、建立多级页表的目的在于建立索引，不比浪费主存空间区存储无用的页表项，也不用盲目式的查询页表项 基本分段存储管理方式 分段 出发点 分页是从计算机角度考虑设计的，目的是为了内存的利用率，提高计算机性能，分页通过计算机硬件机制实现，对用户完全透明 分段是从用户和程序员的角度提出，满足方便编程，信息保护和共享，动态增长及动态链接等多方面的需要 分段 1、按照用户进程中的自然段划分逻辑空间 2、地址结构&#x3D;段号S+段内偏移量W 3、页式系统中，页号和页内偏移量对用户提供。段式系统中，段号和段内偏移量必须由用户显示的提供 段表 每个进程都有一张逻辑空间与内存空间映射的段白，这个段表项对应进程的一段，段表项记录该段在内存中的始址和长度 段表内容&#x3D;段号+段长+本段在主存中的地址 地址变换结构 地址变换结构图解 1、逻辑地址A中取出段号S和段内偏移量W 2、比较段号S和段表长度M 若S&gt;&#x3D;M,则A产生越界中断，否则继续执行 3、段号S对应的段表项地址&#x3D;段表始址+段号S*段表项长度，从该段表项中取出段长 C，比较段内偏移量与C的大小判断是否越界 4、取出段表中该段的始址B，计算E&#x3D;B+W，用得到的物理地址E区访问内存 段的共享与保护 1、共享：两个作用的段表中响应表项指向被共享段的同一个物理副本来实现的，纯代码或者可重入代码以及不可修改的数据都可以被共享 2、保护机制：存取控制保护和地址越界保护 段页式管理方式 页式存储有效的提高利用率，分段存储能反映程序的逻辑结构并有利于段的分享，将这两种方式结合一下，这种二者结合方法经常在计算机理论中遇到 思想 1、作业的地址空间首先被分成若干逻辑段，每段由自己的段号 2、每个段分成若干固定的页 3、对内存空间的管理仍然和分页存储管理一样 地址结构&#x3D;段号S+页号P+页内偏移量W 为了实现地址变换，系统为每个进程建立了一张表，每个分段有一个页表。一个进程中段表只能有一个，页表有多个 地址变换方式 补充 1、不能被修改的代码称为纯代码或可重入代码 2、分段与分页的区别 1）分页对用户不可见，分段对用户可见 2）分页的地址空间是一维的，分段的地址空间是二维的 3）分页（单级页表），分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构 4）分段更容易实现信息的共享和保护 3、分段和分页的优缺点 分页管理 1）优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 2）缺点：不方便按照逻辑模块实现信息的共享和保护 分段管理 1）优点：很方便按照逻辑模块实现信息的共享和保护 2）缺点：如果段长过长，为其分配很大的连续空间会很不方便 段式管理会产生外部碎片 3.2虚拟内存管理虚拟内存的基本概念 传统存储管理方式的特征 1、一次性：作业必须一次性全部装入内存后，才能开始运行 2、驻留性：作业装入内存后，一直驻留在内存中，任何部分不会被换出 局部性原理 时间局部性 1、一条指令执行后，短时间内指令可能被再次执行，数据被访问后，不久后数据可能再次被访问 2、原因：程序中存在大量的循环操作 3、时间局部性通过将最近使用的指令和数据存储在高速缓冲存储器中 空间局部性 1、一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问 2、原因：指令通常顺序存放，顺序执行的，数据一般也是以向量、数组、表等形式存储的 3、空间局部性使用较大的高速缓存，将预取机制继承到高速缓存控制逻辑中实现 虚拟存储器的定义和特征 基于局部性原理，将程序的一部分装入内存，一部分留在外存，需要的时候将外存内容调入内存 特征 1、多次行：作业在运行时，分多次调入内存运行 2、对换性：作业不必一直驻留在内存，允许作业在运行过程中进行换进换出 3、虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量 虚拟内存技术的实现 建立在离散分配的内存管理方式上 实现方式： 1、请求分页存储管理 2、请求分段存储管理 3、请求段页式存储管理 硬件支持 1、一定容量的内存和外存 2、页表机制 3、中断机制 4、地址表换机制 请求分页管理方式 系统建立在基本分页系统基础之上，为了支持虚拟存储器功能二增加了请求调页功能和页面置换功能 页表机制 1、组成：页号、物理块号、状态位P、访问字段A、修改位M、外存地址 2、状态位：当前页是否已经调入内存 3、访问字段A：记录本页在一段时间内被访问的次数 4、修改位M：记录本页是否被修改过 5、外存地址：指出该页在外存上的地址 缺页中断机构 当访问页面不在内存时就会产生缺页中断 特点 指令执行期间产生中断，而不是指令执行之后产生中断和处理中断 一条指令在执行期间，可能产生多次缺页中断 地址变换机构 检索快表，找到访问页，修改页表项中的访问位，利用页表项中给出的物理块号和页内地址形成物理地址 没用找到该页的页表项，区内存中寻找页表，看该页是否已经调入内存，没用调入则产生缺页中断，请求外存把该页调入内存 注意！！！ 虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 虚拟内存的实际容量&#x3D;min（内存和外存容量之和，CPU寻址范围） 页面置换算法 1、最佳置换算法 选择永不使用或者最长时间内不再访问的页面进行淘汰，但是现实中是无法预知的 优点：缺页率最小、性能最好 2、先进先出页面置换算法 1、优先淘汰最早进入的页面 2、优点：实现简单 3、缺点：与进程的实际运行规律不匹配 4、Beledy异常：增大分配的物理块数但是故障数不减反增 3、最近最久未使用算法 1、选择最近最长时间没用被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间 2、优点：性能好 3、缺点：实现复杂，需要寄存器和栈的硬件支持 4、时钟算法 1、像一个时钟一样转圈，每个页面设置一个使用位，遇到没有被使用的就会将页面换出，然后将使用位置0，如果遇到使用的就会将使用位置0，然后扫描下一个 2、优点：性能接近于最佳置换算法 3、缺点：实现复杂，开销大 4、改进时钟算法 （使用位，修改位），最多扫描四次 页面分配策略 驻留集：给一个进程的分配的物理页框的集和就是这个进程的驻留集 考虑因素 1、分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，可以提高处理机的时间利用率 2、一个进程在主存中的页数过少，页错误率就会相对较高 3、页数过多，对进程的错误率页不会产生过多的影响 分配策略 1、固定分配局部置换 1）每个进程分配固定物理块数，缺页的时候就进行换页 2）难以确定每个进程应该分配的物理块数 3）太多导致资源利用率下降，太少导致频繁缺页中断 2、可变分配全局置换 1、进程分配一定物理块，系统自身保留一定空闲物理块，如果进程缺页，就对该进程分配新的物理块 2）优点，最容易实现，动态调整物理块分配 3）缺点：如果盲目分配物理块，就会导致多道程序并发能力下降 3、可变分配局部置换 1）根据进程的缺页情况，对物理块进行动态分配，如果频繁缺页，就对其多配分物理块，如果缺页率特别低么就减少物理块 2）优点，保持了系统的多道程序的并发能力 3）缺点：增大了开销，实现复杂 调入页面的实际 预调页策略：将预计不久被访问的页面调入，成功了约为50% 请求调页策略：当进程提出缺页的时候，再按照一定策略进行调页 从何处调入页 1、拥有足够的对换空间：可以全部从对换区调入所需页面，提高调页速度 2、缺少足够的对换区间：不会被修改的文件从文件区调入，可能被修改的部分换入对换区，再从对换区调入 3、UNIX方式：进程相关文件访问文件区，没有运行的页面从文件调入，曾经运行过但又被换出的页面放在对换区 抖动 1、刚换出的页面又要换入内存 2、原因 分配的物理帧数不足（主要元婴） 置换算法不当 工作集 某段时间内，进程要访问的页面集和 原理 1、操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块 2、落入工作集的页面需要调入驻留集中，落在工作集外面的页面可以从驻留集中换出 3、若还有空闲物理块，可以再调入一个进程到内存以增加多道程序数 4、若所有进程的工作集之和超过了可用物理块的总数，操作系统就会暂停一个进程，并将其页面调出，然后分配给其他进程","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第二章:进程管理","slug":"第二章：进程管理","date":"2022-04-15T12:50:18.000Z","updated":"2022-05-15T10:42:15.463Z","comments":false,"path":"2022/04/15/第二章：进程管理/","link":"","permalink":"https://wjjhui.github.io/2022/04/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"2.1进程与线程进程的概念和特征 进程的概念 为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性 进程控制块（PCB）：为了更好的描述进程的基本情况和运行状态，进而控制和管理进程 [PCB是进程存在的唯一标志] 进程的一些典型定义 1、进程是程序一次执行过程 2、进程是一次程序及其数据在处理机上顺序执行时所发生的活动 3）进程是具有独立功能的程序在一个数据集合上运行的过程，是资源分配和调度的独立单位 进程的特征 1、动态性：动态性是进程是基本特征，引入进程有这创建、活动、暂停、终止等过程，具有生命周期（最基本的特征） 2、并发性：多个进程实体同时存在内存中，引入进程的目的就是为了程序与其他程序并发执行 3、独立性：进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单元 4、异步性：每个进程都配置一个PCB对其进行描述 1）：进程描述信息 2）：进程控制和管理信息 3）：资源分配清单 4）：处理机相关信息 进程的状态与转换 状态 1、创建态：进程正在被创建，尚未进入就绪态 2、就绪态：进程已处于准备运行状态 3、运行态：进程在处理机上运行 4、阻塞态：又称等待态，进程正在等待某个时间而暂停运行 5、结束态：进程正在从系统中消失（包括正常结束和异常终止） 相互转换 1、就绪态–&gt;运行态：处于就绪态的进程获得处理机进行运行态 2、运行态–&gt;就绪态：处于运行态的进程时间片用完后，让出处理机进入就绪态 3、运行态–&gt;阻塞态：进程请求除处理机外的其他资源，此时运行态进入阻塞态（系统调用请求操作系统提供服务，这是一种特殊的，由运行用户态程序调用操作系统内核过程的形式） 4、阻塞态–&gt;就绪态：进程等待其他资源的获得，如IO资源、或中断结束 进程控制 进程的创建 1、分配进程标识号，申请PCB（PCB是有限的） 2、为进程分配资源，为程序和数据以及用户栈分配必要的内存空间 3、初始化PCB，包括初始化标志信息，初始化处理机状态信息，初始化处理机控制信息，设置进程的优先级 4、若进程就绪队列可以接纳新进程，进程就进入就绪态 进程的终止 结束分类 1、正常结束：进程的任务已经完成并且准备推出运行 2、异常结束：进程正在进行，出现了某些异常，导致程序无法继续运行（存储区越界、保护错、非法指令、特权指令错、IO故障等） 3、外界干预：进程应外界请求终止运行 结束过程 1、根据被终止进程的标识符，检索PCB，读取进程状态 2、若进程处于运行态，终止运行，剥夺处理机 3、终止进程下的所有子进程 4、该进程拥有的全部资源还给父进程或者操作系统 5、将PCB从队列中删除 进程的阻塞和唤醒 阻塞原语执行过程 阻塞是一种自主行为，自我阻塞 1、找到要被阻塞进程标识号对应的PCB 2、若进程处于运行态，保护其现场，将其状态转换为阻塞态，停止运行 3、将PCB插入相应时间的等待队列 唤醒原语的执行过程 唤醒是被相互有联系的其他进程进行唤醒 1、找到等待队列中进程相应的PCB 2 、将其从等待队列中移出，置其状态为就绪态 3、将PCB插入就绪队列，等待调度程序调度 进程切换 进程切换是内核态下完成的 过程 1、保存处理机上下文，包括程序计数器和其他寄存器 2、更新PCB信息 3、把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列 3、选择另一个进程之执行，更新其PCB 4、更新内存管理的数据结构 5、恢复处理机上下文 进程的组织 进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，由一下三部分组成 1、进程控制块（PCB） 1）进程描述信息 进程标识符：标志进程 用户标识符：进程归属的用户，主要为共享和保护服务 2）进程控制和管理信息 进程当前状态：描述进程状态信息 进程优先级：描述进程抢占处理机的优先级 代码运行入口地址 程序的外存地址 进入内存时间 处理机占用时间 信号量使用 3）资源分配清单 用以说明有关内存地址空间或者虚拟地址空间状况，所打开的文件的列表和所使用的输入&#x2F;输出设备信息 代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标 4）处理机相关信息 处理机中各寄存器的值 2、程序段：能被进程调度程序调度到CPU执行的程序代码段 3、数据段：进程对应的程序加工处理的原始数据或者程序执行时产生的中间或最终结果 进程的组织方式 1）链接方式 按照进程状态将PCB分为多个队列 操作系统持有指向各个队列的指针 2）索引方式 根据进程状态的不同建立几张索引表 操作系统持有指向各个索引表的指针 进程的通信 1、共享存储 操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，数据交换则由用户自己安排读&#x2F;写指令完成 1）通信进程之间存在一块可以被直接访问的共享空间 2）低级方式：基于数据结构共享（只能存放长度为10的数组） 3）高级方式：基于存储区共享 2、消息传递 1）进程间的数据交换是以格式化的消息为单位的，进程通过系统提供的send和receive原语进行数据交换 2）直接通信方式：发送进程直接发送消息给接收进程，并把它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息 3）间接通信方式：发送进程把消息发送给某个中间实体，接收进程从中间实体中获得消息 3、管道通信 1）发送进程以字符流形式将大量数据写入管道，接收进程从管道中接收数据 当管道写满时，写进程堵塞，直到管道中的数据被读进程取走，即可唤醒写进程 当管道读空时，读进程堵塞，直到管道中的数据被写进程写入，即可唤醒读进程 2）功能：互斥、同步、确定对方存在 3）限制管道的大小 4）管道变空的适合阻塞读进程 线程的概念和多线程模型 线程的基本概念 1、减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能 2、引入线程后，进程只作为系统资源的分配单元，线程作为处理机的分配单元 线程与进程的比较 1、调度 传统中进程是资源和独立调度的基本单位 引入线程后，进程是独立调度的基本单位，线程是资源的基本单位 2、拥有资源：进程是资源分配的基本单位 3、并发性：引入线程后，进程可以并发执行，多个线程之间也可以并发执行，提高系统的吞吐量 4、系统开销：统一进程的线程切换要比进程切换的开销小的多 5、地址空间和其他资源：进程的地址空间之间相互独立，统一进程的各线程之间共享进程的资源，某进程的线程对其他进程不可见 6、通信方面：进程间通信需要进程同步和互斥手段的辅助，保证数据的一致性 线程间可以直接读&#x2F;写进程程序段来进行通信 线程属性 1、不拥有系统资源，拥有唯一标识符和线程控制块 2、不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统将其创建为不同线程 3、同一进程的线程共享该进程拥有的全部资源 4、线程是处理机的独立调度单位 5、线程也有生命周期，阻塞，就绪，运行等状态 6、多CPU计算机中，各个线程可占用不同的CPU 7、每个线程都有一个线程ID、线程控制块（TCB） 8、切换同进程内的线程，系统开销很小 9、切换进程，系统开销很大 10、由于共享内存地址空间，统一进程中的线程通信甚至无需系统干预 线程的实现方式 用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到 内核级线程：线程的管理工作全部由内核完成 多线程模型 1、多对一 1）经多个用户级线程映射到一个内核级线程，线程管理在用户空间完成，用户级线程对操作系统不可见 2）优点：线程管理是用户控件进行的，效率较高 3）缺点：一个线程阻塞全部线程都会阻塞，多个线程不能并行运行在多处理机上 一对一 1）每个用户级线程映射一个内核级线程上 2）优点：并发能力强 3）缺点：创建线程开销大，影响应用程序的性能 多对多 n个线程映射到m个内核线程上（n&gt;m） 既可以提高并发性，由适当的降低了开销 2.2处理机调度调度的概念 调度的基本概念：合理的对进程进行处理机分配 调度的层次 1、作业调度（高级调度）：从外存中选择作业送入内存，每个作业只调入一次，调出一次 2、内存调度（中级调度）：提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存，使其进入挂起态。或者将已经具有运行条件的进程调入内存，修改状态为就绪态 3、进程调度（低级调度）：按照某种策略或者方法从就绪队列中选取一个进程，将处理机分配给它（最基本的调度，频率很高） 三级调度的关系 1、作业调度为进程活动做准备，进程调度使进程正常活动起来，内存调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间 2、作业调度次数少，内存调度次数略多，进程调度频率最多 3、进程调度是最基本的，不可或缺的 调度的时机、切换与过程 不可切换的情况 1、处理中断过程 2、进程在操作系统内核程序临界区的时候 3、其他需要完全屏蔽中断的原子操作过程 可以切换的情况 1、发生引起调度条件且当前进程无法继续进行 2、中断处理结束或者自陷处理结束 进程调度方式 非剥夺调度方式 1、如果想将处理机分配给一个优更高先级的进程，必须要等待当前占用处理机的进程释放处理机后才能将处理机分配给更高优先级进程 2、实现简单，开销小，适合大多数批处理系统 3、不适用于分时系统和大多数实时系统 剥夺调度方式 1、如果有更高级进程请求处理，暂停正在执行的进程，将处理机分配给更高级进程 2、提高系统吞吐率和响应效率 调度的基本准则CPU利用率：尽可能保持CPU处于忙碌状态 系统吞吐量：单位时间内CPU完成作业的数量，调度算法和方式会对吞吐量造成较大影响 周转时间：作业提交到作业完成的时间 1、周转时间&#x3D;作业完成时间-作业到达时间 2、平均周转时间&#x3D;总周转时间&#x2F;N个作业 3、带权周转时间&#x3D;作业周转时间&#x2F;作业作业实际运行时间 4、平均带权周转时间&#x3D;总带权周转时间&#x2F;N个作业 等待时间：作业等待处理机的时间，衡量一个算法的优劣，只需要简单的考察等待时间 响应时间：从用户提交请求到系统首次产生响应所用的时间 进程的挂起态与七状态模型 暂时调到外存等待的进程状态为挂起状态（挂起态） 1、就绪挂起 2、阻塞挂起 “挂起”和”阻塞”的区别：两种状态都是暂时不能获得CPU的服务，但是挂起态是将进程映像调到外存去了，而阻塞态下进程映像还是在内存中 七状态模型 典型调度算法 1、先来先服务（FCFS） 1）作业调度 进程调度 2）先来的先分配处理机 3）优点：算法简单对长作业有利 有利于CPU繁忙型作业（计算型） 4）缺点：效率低 不利于短作业 不利于IO繁忙型作业 5）不会导致饥饿 6）非抢占式的算法 2、短作业优先（SJF） 1）进程调度 2）优先选择预计运行时间最短的进程 3）优点：平均等待时间 平均周转时间短 4）缺点：长作业不利，造成饥饿现象，没有考虑作业的紧迫性，用户可能可以缩短作业预估时间，使得无法做到短作业优先 5）产生”饥饿”现象。如果一直得不到服务，则称为”饿死” 6）SJF和SPF（短进程优先算法）是非抢占式的算法，但也有抢占式的版本–最短剩余时间优先算法（SRTN） 3、高响应比调度算法（HRRN） 1）响应比&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间 2）等待时间相同情况下，要求服务时间越短响应比越大，有利于短作业进程 3）要求服务时间相同，作业响应比由其等待时间决定，等待时间越长响应比越高，实现先来先服务 4）对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长，其响应比可以升到很高，从而获得处理 5）不会导致饥饿 6）非抢占式的算法 FCFS、SJF、HRRN对比 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心”响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统 4、优先级调度算法 1）作业调度，进程调度 2）分类 剥夺型：立即停止当前运行进程，将处理机分配给更高优先级进程 非剥夺型：等待当前进程运行完成，然后将处理机分配给更高优先级进程 3）优先级分类 静态优先级：进程创建后无法对优先级进行修改 动态优先级：可以根据进程运行状态，对进程优先级进行动态调整 4）优先级设置原则 系统进程&gt;用户进程 交互型进程&gt;非交互型进程 ​ I&#x2F;O进程&gt;计算型进程（CPU繁忙型） 5）产生”饥饿”现象 6）有抢占式的，也有非抢占式的 5、时间片轮转算法 1）使用分时系统，使用时间片，就绪进程按照到达先后排成队列，依次在时间片内占用处理机，时间片到达就释放处理机 2）时间片的选择很重要，过大就变成先来先服务，过小就表成了短作业优先 3）时间片影响因素：系统响应时间，就绪队列中的进程数目和系统的处理能力 4）不会导致饥饿 5）抢占式的算法 6、多级反馈队列调度算法 实现思想 1）设置多个就绪队列，为每个队列设置不同的优先级，优先级依次递减 2）每个队列的时间各不相同，时间片依次递增 3）每个队列按照先来先服务原则进行进程排队，若规定时间片内没有完成，就将进程放入下一级队列 4）只有高级队列为空的时候，低等级队列才能开始调度 优点 1）终端行作业用户：短作业优先 2）短批处理作业用户：周转时间较短 3）长批处理作业用户：讲过前面几个队列得到部分执行，不会长期得不到处理 产生”饥饿”现象 抢占式算法 优先级、时间片、多级反馈算法对比 比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法） 2.3进程同步基本概念 临界资源 一次只允许一个进程使用的资源（打印机、特殊变量、数据） 临界资源的访问过程 1、进入区：检查进程是否可以进入临界区 2、临界区：可以访问临界资源的代码 3、退出区：将正在访问临界区的标志清除 4、剩余区：代码中的其余部分 同步：直接制约关系，为了完成某种任务而建立的多个进程，相互合作，所以要相互通信同步 遵循的原则 1、空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 2、忙则等待：已有进程进入临界区后，其他试图进入临界区的进程必须等待 3、有权等待：对于请求访问临界区的进程，在有限时间内进入临界区 4、让权等待：进程不能进入临界区的时候，应当立即释放处理机 互斥：间接制约关系，当一个进程访问临界资源的时候，其他进程不能访问 实现临界区互斥的基本方法 软件实现方法 1、单标志法 两个程序交替进入临界区 优点：实现简单 缺点：可能会违背空闲等待，造成资源无法充分利用 单标志法实现 2、双标志先检查法 每个进程访问临界资源前，先检查临界资源是否被访问，如果空闲才能进入 优点：不用交替进入，可以连续使用 缺点：两个进程可能同时进入临界区，违背忙则等待 双标志先检查实现 3、双标志后检查法 先设置自己标志，表明自己想进入，检查对方标志，如果对方也要进入就等待，否则就进入 优点：不会导致两个进程都进入临界区 缺点：双方可能会互相谦让，导致饥饿 双标志后检查实现 4、Peterson算法 防止两个进程无限期等待，在算法三的基础上增加一个标志位，从而防止饥饿 优点：解决了饥饿现象 缺点：算法复杂 Peterson算法实现 硬件实现方法 中断屏蔽法 1、对中断进行屏蔽、关中断 2、优点：简单、高效 3、缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令。只能运行在内核态，这组指令如果能让用户随意使用会很危险） TestAndSet指令 Swap指令 优点：适用于任意数目的进程 简单且容易验证正确性 支持进程内有多个临界区 缺点：不能实现让全等待 可能会导致饥饿现象 信号量 1、整型信号量 不满足让权等待 用一个整数变量作为信号量，数值表示资源数 整型信号量实现 2、记录型信号量 wait(S)、signal(S) 也可以记为 P(S)、V(S)，P( S ) —— 申请一个资源S，如果资源不够就阻塞等待。V( S ) —— 释放一个资源S，如果有进程在等待该资源，则唤醒一个进程 S.value 的初值表示系统中某种资源的数目。 S.L代表阻塞队列，进程阻塞的个数 记录型信号量实现 3、利用信号量实现互斥 4、利用信号量实现同步 5、利用信号量实现前驱关系 管程 信号量机制存在的问题：编写程序困难、易出错 定义：一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程 组成 1、局部于管程的共享结构数据说明 2、对该数据结构进行操作的一组过程 3、对局部于管程的共享数据设置初始值的语句 基本特性 1、局部于管程数据只能被局部于管程内的过程访问 2、一个进程只有通过调用管程内的过程才能进入管程访问共享数据 3、每次允许一个进程在管程内执行某个内部过程 2.4死锁死锁的概念 死锁的定义：多个进程因为竞争资源造成的一种僵局，没有外力作用，这些进程都无法向前继续推进 死锁产生的原因 1、系统资源的竞争 2、 进程推进顺序非法 3、死锁产生的必要条件 1）互斥条件：进程对分配的资源进行排他性控制 2）不可剥夺条件：进程获得资源在未使用完之前，不能被其他进程强行夺走 3）请求并保持条件：进程已经保持了至少一个资源，提出新的资源请求，而该资源已经被其他进程占有，此时该进程被阻塞，但是自己已经获得的资源保持不放 4）循环等待条件：你等我释放，我等你释放 对不可剥夺资源的不合理分配，可能导致死锁。 死锁的处理策略 1、死锁预防：破坏四个必要条件中一个或多个，防止死锁 2、避免死锁：在资源的动态分配中，用某种方法防止系统进入不安全状态，避免死锁 3死锁的检测及解除：允许进程死锁，通过检测及时的判断死锁，然后对其进行解除 死锁的处理策略对比图 死锁预防 1、破坏互斥条件：某些资源只能被互斥访问，并且某些情况下必须保护互斥性 2、破坏不剥夺条件 释放已经占有的资源 特点：增加系统开销，实现复杂，降低吞吐量 用于状态易于保存和恢复的数据（CPU的寄存器和内存资源） 3、破坏请求并保持条件： 一次申请完所需要的全部资源 特点：实现简单，但是资源严重浪费，可能导致饥饿 4、破坏循环等待条件 采用顺序资源法，对进程进行顺序推荐 特点：进程编号必须稳定，可能会导致资源浪费，并且不利于用户编程 死锁避免 系统安全状态：按照某种方式分配资源后，如果会导致死锁就是不安全状态，反之就是安全状态 银行家算法：通过计算当前资源的不同分配方式，从而预测系统是否会进入不安全状态 系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。 死锁的检测和解除 资源分配图：圈圈表示进程，框表示一类资源，进程到资源称为请求边，资源到进程称为分配边 死锁定理 1、在资源分配图中找到分配满足的进程，然后消去其请求边与分配边 2、如果最后所有边都能被消去，则不存在死锁，反之存在死锁 死锁解除 1、资源剥夺法：挂起某些死锁进程，抢占资源，将这些资源分配给其他死锁进程，但是要防止挂起时间过长 2、撤销进程法：强制撤销部分甚至全部死锁进程，并且剥夺他们的资源，撤销原则可以根据优先级和撤销进程代价进行 3、进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺，要求系统保持进程历史信息，设置还原点 死锁、饥饿、死循环的区别","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第一章:操作系统的概述","slug":"第一章：操作系统的概述","date":"2022-04-01T12:50:18.000Z","updated":"2022-05-15T10:44:14.981Z","comments":false,"path":"2022/04/01/第一章：操作系统的概述/","link":"","permalink":"https://wjjhui.github.io/2022/04/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1.1操作系统的基本概念操作系统的概念 1、控制和管理整个计算机系统的硬件和软件资源 2、合理地组织、调度计算机的工作与资源 3、为用户和其他软件提供方便接口与环境的程序结合 计算机系统的层次结构 操作系统的特征 并发 1、两个多个时间在统一时间间隔内发生 2、使得系统具有处理和调度多个程序同时执行的能力 3、操作系统的并发是通过分时实现 注意：并发是在一时间段，并行是指在同一个时刻，并行是指操作系统具有同时执行或操作 基本特征：并发、共享、虚拟、异步 重要考点 1、单核cpu同一时刻只能执行一个程序，各个程序可以并发地执行 2、多核cpu同一时刻可以同时执行多个程序，多个程序可以并行地执行 共享 互斥共享方式 1、例如打印机、磁带，同一时刻只能供一个进程对资源访问 2、这种资源称作：临界资源或者独占资源 同时访问方式 1、一段时间内允许多个进程对资源进行访问 2、典型代表：磁盘设备，重入码编写的文件 虚拟 1、一个物理上的实体变为若干逻辑上的对应物，这种技术也成为虚拟技术 2、虚拟处理器：采用躲到程序并发的方式，让每个终端用户感觉到有多个处理器（时分复用技术） 3、虚拟存储器：将物理存储变为虚拟存储器，逻辑上扩充存储器用量（空分复用技术） 4、也可以将一台IO设备虚拟为多台逻辑上的IO设备，并允许每个用户占用一台逻辑上的IO设备 异步 多道程序走走停停，进程以不可预知的速度向前进 操作系统的目标和功能 1、管理功能 1）处理机管理：管理处理器的分配与运行，解决冲突问题，可以理解为对进程的管理 进程管理：进程控制，进程同步，进程通信，死锁处理，处理机调度 2）存储器管理：为了提高多道程序运行效率，方便用户使用 内存分配，地址映射，内存保护，共享和内存扩充、 3）文件管理：操作系统负责管理文件的系统称为文件系统 文件存储空间的管理，目录管理，文件读写管理和保护 4）设备管理：完成用户的IO请求，方便用户使用设备，提高设备的利用率 缓冲管理，设备分配，设备处理，虚拟设备 2、接口功能 1）命令接口 联机控制方式：交互式命令接口，适用于分时或者实时系统，就想人与机器对话一样 脱机控制方式：又称批处理系统，提交一组作业，系统进行处理，用户不能干预作业的运行 2）程序接口 有一组系统调用命令组成（也称作系统调用或者广义指令） 例如：图形用户界面（GUI） 操作系统用作扩充机器 1、操作系统提供了资源管理功能和方便用户使用的各种服务功能，将机器改造为功能更强的机器 2、覆盖了软件的机器称为扩充机器，又称为虚拟机 封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需对操作系统发出命令即可 1.2操作系统的发展与分类1、手工操作阶段 程序的装入，运行，结果的输出都需要人为的干预 缺点：资源利用率低，cpu利用不充分 2、批处理阶段 为了解决人机矛盾以及cpu和IO设备之间速度不匹配的矛盾 单道批处理系统 内存中始终保存一道作业，作业成批执行 特点 自动性：一批作业自动执行不需要人工干预 顺序性：各道作业依次执行 单道性：仅有一道程序执行 多道批处理系统 允许多个程序在cpu中交替运行，程序共享各种硬件和软件资源 特点 多道：计算机中同时存放多道相互独立的程序 宏观上并行：多道程序都会开始运行，但都没有运行完毕 微观上串行：多道程序轮流占用cpu，交替执行 优点 资源利用率高 多道程序并发执行，共享计算机资源 cpu和其他资源更保持”忙碌”状态，系统吞吐量增大 缺点 设计复杂，要考虑各种资源调度问题 响应时间过长，没有人机交互功能 分时操作系统 将处理器运行时间划分时间片，将时间片分配给不同作业&#x2F;用户从而占用处理机 特点 1、同时性：允许多个终端用户使用同一台计算机 2、交互性：方便进行人机对话，用户采用人机对话方式控制程序运行 3、独立性：多个用户彼此之间独立的操作，互不干扰 4、及时性：用户请求能在很短时间内获得响应 实时操作系统 保证在规定时间内完成某项任务 特点 1、及时性：规定时间内完成规定任务 2、可靠性：输出的结果正确，系统运行时确保稳定 分布式计算机系统 网络操作系统将多个计算机有机的结合在一起 任意两台计算机之间没有主从之分，互相交换信息，并行工作，协同完成 个人计算机操作系统 广泛应用于文字处理，电子表格，游戏 1.3操作系统的运行环境程序运行：程序运行的过程其实就是cpu执行一条一条的机器指令的过程 操作系统的运行机制cpu的两种性质程序 操作系统内核程序 用户自编程序 内核 1、时钟管理：操作系统对用户提供标准时间，根据时钟对进程进行管理，实现进程切换 2、中断机制：初衷是为了提高多道程序运行环境中的cpu利用率，保护和恢复中断现场的信息，转移控制权到相关程序 原语 1、处于系统的最底层，最接近硬件 2、运行具有原子性，即只能一气呵成 3、系统控制的数据结构及处理 ​ 1）进程管理：进程状态管理、进程调度和分派、创建和撤销进程控制 ​ 2）存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序 ​ 3）设备管理：缓冲区管理、设备分配和回收 中断与异常 为了进行和心态和用户态两种状态的切换，引入了中断机制 1、核心态可以执行用户态无法执行的特权指令 2、访管指令是在用户态使用，将用户态转换为核心态，所以访管指令不是特权指令 “中断”是让操作系统内核夺回cpu使用权的唯一途径 中断（外中断） 1、来自于cpu指令之外的事件发生 2、I&#x2F;O中断：输入输出已经完成 3、时钟中断：固定时间片已到，让处理及处理 异常（内中断） 1、源自于cpu执行指令内部内部的事件 2、非法操作码，除零，地址越界，算数溢出 3、陷入指令：用户自行设置，执行陷入后，用户态转换为核心态 4、异常不能被屏蔽 系统调用 1、用户在程序中调用操作系统提供的一些子功能 2、设备功能：完成设备的请求或者释放，设备启动等功能 3、文件管理：完成文件的读、写、创建以及删除功能 4、进程控制：完成进程的创建、撤销、阻塞以及唤醒功能 5、进程通信：完成进程之间的消息传递和信号传递功能 6、内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能 用户态与内核态cpu中有几个寄存器叫程序状态寄存器（psw） 1为”内核态”，0为”用户态” 1、处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令 2、处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令 内核态、用户态的切换 1、内核态–》用户态：执行一条特权指令——修改psw的标志位为”用户态”，这个动做意味着操作系统将主动让出cpy使用权 2、用户态–》内核态：由”中断”引发，硬件自动完成变态过程，出发中断信号意味着操作系统将强行夺回cpu的使用权 1.4大内核与微内核大内核 1、将操作系统的主要功能模块进行集中，从而用以提高性能的系统服务 2、优点：各个管理模块之间共享信息，能够有效利用相互之间的有效特性，所有有着巨大的性能优势 3、缺点：层次交互关系复杂，层次接口难以定义没层次之间界限模糊 微内核 1、背景：随着计算机体系结构的不断发展，操作系统提供的服务越来越多，接口形式越来越复杂 2、将内核中最基本的功能保留在内核，将不需要在核心态执行的功能转移到用户执行，降低内核设计的复杂性 3、优点：有效的分离内核与服务、服务与服务、使得他们之间的接口更加的清晰，维护的代价大大降低 各部分可以独立的优化和演进 4、优点：性能问题，需要频繁的在核心态和用户态之间进行切换 大内核与微内核","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第六章:应用层","slug":"第六章：应用层","date":"2022-03-29T14:06:20.000Z","updated":"2022-05-15T10:43:52.923Z","comments":false,"path":"2022/03/29/第六章：应用层/","link":"","permalink":"https://wjjhui.github.io/2022/03/29/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"6.1网络应用模型客户&#x2F;服务器模型在客户&#x2F;服务器模型（c&#x2F;s）中，服务器总是打开，接收许多客户机的请求 工作流程 1、服务器处于被请求的状态 2、客户机发出服务请求，并等待接收结果 3、服务器收到请求后，分析请求，进行必要的请求，得到结果并发送给客户机 P2P模型任意一对计算机都可以直接互相通信，每台计算机即作为服务器又作为客户机 优点 ​ 1、减轻了服务器的计算压力，消除了对某个服务器的完全依赖，提高了系统效率和资源利用率 ​ 2、多个客户机之间可以直接共享文档 ​ 3、可扩展性好，传统服务器有响应和带宽的限制，只能接收一定的数量 ​ 4、网络健壮性好，单个节点的失效不会影响其他节点 缺点 ​ 1、占用较多的内存，影响整机的速度 ​ 2、P2P下载会对硬盘造成较大的损伤 ​ 3、使网路变得非常拥塞 6.2域名服务系统（DNS）概述1、域名系统是因特网使用的命名系统，用来将主机名转换为便于机器处理的IP地址 2、DNS系统采用 客户&#x2F;服务器模型 3、协议运行在UDP之上，使用53号端口 4、控制连接在整个会话期间一直保持打开状态（21号端口） 层次域名空间 域名服务器 域名解析过程 6.3文件传输协议（FTP）概述1、FTP提供了交互的访问，允许客户指明文件的类型与格式，并允许文件具有权限 2、屏蔽了各计算机系统的细节，因而适合于异构网络中的任意计算机之间传送文件 3、FTP采用客户&#x2F;服务器的工作方式，使用TCP传输服务 FTP的功能1、提供不同种类主机系统之间的文件传输能力 2、以用户权限管理的方式提供用户对远程FTP服务器的文件管理能力 3、以匿名FTP的方式提供公用文件共享的能力 FTP进程组成1、主进程：负责接收新的请求 2、 若干从属进程：处理单个请求 FTP工作原理 6.4电子邮件系统电子邮件系统的的组成结构1、用户代理：用户与电子邮件系统的接口 2、邮件服务器 ​ 组成电子邮件的系统的核心 ​ 发送和接收邮件 ​ 向用户汇回报发送情况 3、邮件发送协议和读取协议 ​ SMTP:邮件发送协议 ​ POP3：邮件读取协议 电子邮件的收发过程 电子邮件与MIME电子邮件格式 ​ 1、to是必需的关键字，后面是填入一个或多个收件人的电子邮件地址 ​ 2、Subject是可选关键字，是邮件的主题，反映了邮件的主要内容 ​ 3、Fr+om是必填的关键字，但它通常是由邮件系统自动填入 典型的邮件传送 SMTP与MIME ​ 1、SMTP不能传送可执行文件和其他二进制对象 ​ 2、SMTP仅限于传送7为ASCII码，不能传送其他国家的文字 ​ 3、SMTP会拒绝超过一定长度的邮件 SMTP和POP3简单邮件传输协议（SMTP） 概述 ​ 1、一种提供可靠且有效的电子邮件传输的协议，它控制两个互相通信的SMTP进程交换信息 ​ 2、使用客户&#x2F;服务器模型 ​ 3、发送邮件SMTP进程是SMTP客户，而负责接收邮件的SMTP进程是SMTP服务器 ​ 4、TCP连接 端口为25 POP3 概述 ​ 1、邮局协议（POP3）是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第三个版本 ​ 2、当用户读取邮件时，用户代理像邮件服务器发出请求，拉取用户邮箱中的邮件 ​ 3、使用客户&#x2F;服务器的工作方式 ​ 4、在传输层使用TCP，端口号为110 工作方式 ​ 下载并保留 ​ 下载并删除 基于万维网的电子邮件1、用户浏览器与Hotmail或Gmail的邮件服务器之间的邮件发送或接收使用HTTP 2、在不同邮件服务器之间传送邮件时使用SMTP 6.5万维网（WWW）www的概念与组成结构概念 ​ 1、在这个空间中，有用的事物称为资源，并由一个全域的”统一资源定位符”（URL）标识 ​ 2、这些资源通过超文本传输协议（HTTP）传送给使用者，而后者通过单机连接来获取资源 内核部分标准构成 ​ 统一资源定位符（URL） ​ 超文本传输协议（HTTP） ​ 超文本标记语言（HTML） 工作流程 ​ 1、web用户使用浏览器与web服务器建立连接，并发送浏览请求 ​ 2、web服务器把URL转换为文件路径，并返回信息给web浏览器 ​ 3、通信完成，关闭连接 超文本传输协议（HTTP）概述 ​ 1、HTTP定义了浏览器怎么向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器 ​ 2、HTTP是面向十五的应用层协议 ​ 3、规定了浏览器和服务器之间的请求和响应的格式与规则 ​ 4、是万维网上能够可靠地交换文件的重要基础 HTTP操作过程 HTTP报文 ​ 1、请求报文 ​ 2、响应报文 HTTP的特点 ​ 1、HTTP是无状态，同一个客户第二次访问同一个服务器的页面时，服务器的响应与第一次被访问时相同 ​ 2、HTTP的无状态特性简化了服务器的涉及，使服务器更容易支持大量并发的HTTP的请求 ​ 3、使用Cookie加数据库的方式来跟踪用户的活动 ​ 4、HTTP采用TCP作为传输层协议，保证了数据的可靠传输 ​ 5、HTTP既可以使用非持久连接，也可以使用持久连接 HTTP报文结构 HTTP是面向文本的 报文类型 状态码 1xx表示通知信息的，如请求收到了或正在处理 2xx表示成功，如接收或知道了 3xx表示重定向，如要完成请求还必须采取进一步的行动 4xx表示客户的差错，如请求中有错误的语法或不能完成 5xx表示服务的差错，如服务器失效无法完成请求","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"第五章:传输层","slug":"第五章：传输层","date":"2022-03-26T12:50:18.000Z","updated":"2022-05-15T10:44:09.337Z","comments":false,"path":"2022/03/26/第五章：传输层/","link":"","permalink":"https://wjjhui.github.io/2022/03/26/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"","text":"5.1传输层提供的服务传输层的功能 概述 传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是面向用户功能中的最底层 为运行在不同主机上的进程提供了逻辑通信 传输层的功能 1)传输层提供应用进程之间的逻辑通信（即端到端的通信） 2)复用和分用 1、复用：发送方不用的应用进程都可使用同一个传输层协议传送数据 2、分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程 3)传输层还要对收到的报文进行差错检测（首部和数据部分） 4）提供两种不同的传输协议，即面向连接的TCP和无连接UDP 5）向高层用户屏蔽底层网络核心的细节，使应用进程好像在两个传输层实体之间有一条端到端的逻辑通信信道 传输层的寻址与端口 端口的作用 1、端口可以标识主机中应用进程 2、让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上端口交付给应用层相应的进程 3、端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的 软件端口与硬件端口 软件端口：协议栈层间的抽象的协议端口，是应用层的各种协议进程与传输实体进行层间交互的一种地址 硬件端口：不同硬件设备进行交互的接口 端口号 服务端使用的端口号 熟知的端口号（1-1023） 登记端口号（1024-49151）：使用这类端口号必须IANA登记，以防止重复 客户端使用的端口号（49152-65535） 又称短暂端口号，通信结束后客户端口号就不存在 数据链路层的SAP是 MAC地址，网络层的SAP是P地址，传输层的SAP是端口。 套接字 IP用来标识和区分不同的主机，端口号用来标识和区分一台主机的不同应用进程 套接字&#x3D;{主机IP地址，端口号} 无连接服务和面向连接服务 面向连接服务 1、在通信双方进行通信之前，就必须建立连接，在通信过程中，整个连接的情况一直被实时的监控和管理 2、通信结束后，应该释放这个连接 无连接服务 两个实体的通信不需要先建立连接，需要通信时，直接将信息发送到”网络”中，让该信息的传递在网上尽力而为地往目的地传送 TCP&#x2F;IP协议族的传输协议TCP：采用TCP时，传输层向上提供一条全双工的可靠逻辑通信信道UDP：采用UDP时，传输层向上提供的是一条不可靠的逻辑信道TCP&#x2F;IP协议TCP提供面向连接的可靠传输服务，增加了许多开销，如确认、流量控制、计时器及连接管理 TCP主要适用于可靠性更加重要的场合，如FTP,HTTP,TELNET等 UDP协议 1、在IP之上仅提供多路复用和差错检测的功能 2、远程主机的传输层收到UDP报文后，不需要给出人任何确认 3、UDP简单，执行速度快，实时性好 4、UDP的应用场景：TFTP,DNS,SNMP,RTP 注意！！！IP数据报和UDP数据报的区别 1、IP数据报在网络层要经过路由的存储转发 2、UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，UDP数据报的信息对路由是不可见的 TCP和网络虚电路的区别 1、TCP报文端在传输层抽象的逻辑信道中传输，对路由器不可见 2、虚电路所经过的交换节点都必须保存虚电路状态信息 3、网络层采用虚电路方式，则无法提供无连接服务 4、而传输层采用TCP不应用网络层提供无连接服务 5.2UDP协议UDP数据报UDP实现了传输协议能够做的最少工作,在IP的数据报服务上增加了两个基本的服务：复用和分用以及差错检测UDP优点 1、UDP无需建立连接（无建立连接的时延） 2、无连接状态（无须维护连接状态） 3、分组首部开销小 8B 特点 1、UDP常用于一次性传输较少数据的网络应用：如DNS、SNMP等 2、UDP尽最大努力交付，即不保证可靠交付，由应用层维护传输可靠性 3、UDP是面向报文 UDP数据报首部 UDP的首部格式 源端口号：源端口号在需要对方回信时选用，不需要时全为0 目的端口号：在终点交互报文时必须使用到 长度：UDP的数据报的长度（包括首部和数据），最小值为8B 校验和：校验UDP数据报在传输中是否出错，有错就丢弃，不需要时全为0 收到数据报 1、根据首部的目的端口把UDP数据报通多相应的端口上交给应用进程 2、如果接收UDP发现收到的报文中目的端口对不上就丢弃，并由ICMP发送”端口不可达”差错报文 UDP校验UDP的校验和只检查首部和数据部分 注意！！ 1、校验时，若UDP数据报部分的长度不说偶数个字节，则需填入一个全0字节 2、如果UDP校验和叫校验出UDP数据报错误，那么可以丢弃也可以交付给上层，但是需要附上错误报告 3、通过伪首部，不仅可以检查源端口号，目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址 5.3TCP协议TCP协议的特点TCP是在不可靠的IP层之上实现可靠的数据报传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题 特点 1、TCP是面向连接的传输层协议 2、每条TCP连接只能由两个端点，每条TCP连接只能是点对点的 3、TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序 4、TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据 5、TCP是面向字节流的 TCP报文段TCP传送的数据单元称为报文段 作用 1、运载数据 2、建立连接、释放连接和应答 报文端格式 字段意义 1)源端口和目的端口。各占2B。端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现。 2)序号。占4B，范围为0~23-1，共2”个序号。TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的字节流中的每个字节都按顺序编号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是 301，而携带的数据共有100B，表明本报文段的数据的最后一个字节的序号是400，因此下-一-个报文段的数据序号应从401开始。 3）确认号。占4B，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则表明到序号N-1为止的所有数据都已正确收到。例如,B正确收到了A发送过来的一个报文段，其序号字段是501，而数据长度是200B(序号501~700)，这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下-一-个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。 4)数据偏移（即首部长度)。占4位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度（首部中还有长度不确定的选项字段)，它指出TCP 报文段的数据起始处距离TCP报文段的起始处有多远。”数据偏移”的单位是32位(以4B为计算单位)。由于4位二进制数能表示的最大值为15，因此 TCP首部的最大长度为60B. 5）保留。占6位,保留为今后使用,但目前应置为0. 6）紧急位URG。当URG&#x3D;l时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据)。但 URG需要和首部中紧急指针字段配合使用，即致据从第一个字节到紧急指针所指字节就是紧急数据。 7)确认位ACK。仅当ACK&#x3D;!时确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。 8)推送位PSH(Push)。接收方TCP收到PSH&#x3D;1的报文段,就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。 9）复位位RST (Reset)。当RST&#x3D; 1时，表明TCP连接中出现严重差错（如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。 10）同步位SYN。当SYN&#x3D;1时表示这是一个连接请求或连接接受报文。当SYN &#x3D; 1，ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使用SYN&#x3D; 1，ACK&#x3D;1。 11)终止位FIN (Finish)。用来释放一个连接。当FIN &#x3D; 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。 12）窗口。占2B，范围为0~216-1。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据。例如，设确认号是701，窗口字段是1000,这表明,,从701号算起，发送此报文段的-一方还有接收1000字节数据（字节序号为7o1700）的接收缓存空同。 13）校验和。占2B。校验和字段检验的范围包括首部和数据两部分出在计算校验和时，和UDP一样，要在TCP报文段的前面加上 12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6。其他的和UDP一样)。 14）紧急指针。占2B。紧急指针仅在URG&#x3D; 1时才有意义，它指出在本报文段中紧急数据共有多少字节〔紧急数据在报文段数据的最前面)。 15)选项。长度可变。TCP最初只规定了一种选项,即最大报文段长度(Maximurm Segment Size,MSS)。MSS是TCP报文段中的数据字段的最大长度（注意仅仅是数据字段)。 16)填充。这是为了使整个首部长度是4B的整数倍。· TCP连接管理TCP连接的管理就是使运输连接的建立和释放都能正常进行 连接节点 1、连接建立 2、数据传送 3、连接释放 TCP连接建立是面对的问题 1、要使每一方都能够却只对方的存在 2、要允许双方协商一些参数（如最大窗口值等等） 3、能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配 连接的建立（三次握手） 1、客户机的TCP首先向服务器的TCP发送一个连接请求报文段 2、服务器的TCP收到连接请求后，就想客户机发回确认，并分配TCP缓存和变量 3、客户机收到确认后，再向服务器给出确认，也分配缓存和变量 连接的释放（四次握手） 1、客户机向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接 2、服务器收到连接释放报文随即发出确认 3、服务器通知客户端TCP连接释放 4、客户机收到连接释放报文后，发出确认 SYN洪泛攻击 1、SYN洪泛攻击发生在OSI第四层，这种方式利用了TCP协议的特性，就是三次握手 2、攻击力发送TCP SYN即TCP三次握手中的第一个数据报，而当服务器放回ACK后，该攻击就不对其进行确认 3、那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，当服务器收不到再确认的花，还会重复发送给ACK给攻击者（浪费服务器的资源） TCP可靠传输 1、校验：和UDP校验一样 2、序号：TCP首部的序号字段用来保证数据能有序提交给应用层，序号建立在传送的字节流的 3、确认：TCP首部的确认是期望收到对方的下一个报文端的数据第一个字节的序号（采用累计确认） 4、重传：超时重传和冗余ACK（收到3个ack帧） TCP流量控制 匹配发送方的发送速率与接收方的读取速率 流量控制机制 基于滑动窗口协议的流量控制机制 1、接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小（接收窗口rwnd），限制发送方向网络注入报文的速率 2、发送方根据其对当前网络拥塞程序的估计而确定的窗口值，称为拥塞窗口cwnd（其大小与网络的带宽和时延有关） 流量控制的区别 传输层：滑动窗口可以动态变化 数据链路层：滑动窗口不能动态变化 TCP拥塞控制 拥塞控制：防止过多的数据注入网络，保证网络中的路由器或链路不致过载 拥塞控制和流量控制的区别 相同点：他们都通过控制发送方发送数据的速率来达到控制效果 区别 1、拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、路由器、以及降低网络传输性能有关的所有因素 2、流量控制是点对点的通信量的控制，即接收端控制发送端，它要做的是抑制发送方的速率，以便接收方来得及接收 窗口 接收窗口rwnd：接收方根据目前接收缓存大小所承诺的最新窗口值，反应接收方的容量 拥塞窗口cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量 实现机制 慢开始和拥塞避免 快重传和快恢复 网络拥塞的处理 发送方检测到超时时间的发生（未按时收到确认，重传计时器超时），就要把慢开始们限ssthresh设置为出现拥塞时的发送方的cwnd值得一半（但不能小于2） 然后把拥塞窗口cwnd重新设置为L执行慢开始算法","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"第四章:网络层","slug":"第四章：网络层","date":"2022-03-17T12:50:18.000Z","updated":"2022-05-15T10:44:03.267Z","comments":false,"path":"2022/03/17/第四章：网络层/","link":"","permalink":"https://wjjhui.github.io/2022/03/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"4.1网络层的功能异构网络互联 异构网络：不同的寻址方案、不同的网络接入机制、不同的差错处理方法、不同的路由选择机制等 网络互联：将两个以上的计算机网络，通过一定的方法，用一种或多种通信设备（即中间设备）相互连接起来，已构成更大网络系统 中继系统 物理层中继 中继器、集线器 数据链路层中继系统 网桥或交换机 网络层中继系统 路由器 TCP&#x2F;IP体系在网络互联上采用的做法是在网络层（即IP层）采用标准化协议，相互连接的网络可以是异构的 网络层以上的中继系统 网关 虚拟互联网络 也就是逻辑网络，即互联起来的各种物理网络的异构性本来是客观存在的，但是通过使用IP就可以使这些性能各异的网络在网络层上看起来好像一个统一的网络 优点：互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节（如具体的编制方案、路由选择协议等） 路由与转发 功能 路由选择（控制层）（确定拿一条路径） 1、根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表 2、按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选这的路由 分组转发（数据层）（当一个分组到达时所采取的动做） 1、处理通过路由器的数据流，关键操作是转发表查询、转发以及相关的队列管理和任务调度等 2、路由器根据转发表将用户的IP数据报从合适的端口转发出去 拥塞控制 在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞 判断拥塞的方法啊 1、轻度拥塞：随着网络负载的增加，网络的吞吐量明显小于正常吞吐量 2、拥塞状态：网络的吞吐量随着网络负载的增加而下降 3、死锁状态：网络的负载继续增大，而网络的吞吐量下降到零 避免拥塞现象：获取网络中发送拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞而出现分组的丢失，以及严重拥塞而产生网络死锁的现象 作用：确保子网能够承载所达到的流量 实现方法 1、合理优化主机、路由器及路由器内部的转发处理过程 2、单一增加资源并不能解决拥塞 流量控制和拥塞控制的区别 开环控制 设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞 优点：一种静态的预防方法。一旦整个系统启动并运行，中途就不再修改 闭环控制 实现不考虑有关发生拥塞的各种因素，采用检测网络系统去监视，即使监视哪来发生了拥塞，然后将拥塞信息传到合适的地方 优点，基础反馈环路的概念，是一种动态的方法 4.2路由算法静态路由算法（非自适应路由算法） 概念 1、由网络管理员手工配置的路由信息 当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手动去修改路由表中相关的静态路由信息 优点：简单可靠，在负载稳定、拓扑变化的网络中运行效果良好 缺点 1、大型和复杂的网络环境通常不宜采用 2、管理员难以全面了解网络拓扑结构 3、发生变化后需要大范围修改和调整路由信息 使用范围：广泛应用于高度安全的军事系统和较小的商业网络 动态路由算法（自适应路由算法） 概念 1、路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定算法优化出来 2、路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优寻路效果 优点：改善网络的性能并有助于流量控制 缺点 1、算法复杂，会增加网络的负担 2、对动态变化的反应太快而引起震荡，或反应太慢而影响网络路由的一致性 动态路由算法 距离-向量算法（RIP协议） 原理：所有节点定期地将他们的整个路由选择表传送所有与之直接相邻的节点’ 路由选择表内容 1、每条路径的目的地 2、路径的代价 更新路由表的条件 1、被通告一条新的路由，该路由在本节点的路由表中不存在。此时本地系统加入这条信的路由 2、来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离 缺点：容易出现路由环路问题 链路状态路由算法（OSPF协议） 原理 1、链路状态路由算法是要求每个参与该算法的节点都具有完全的网络拓扑信息 2、主动测试所有邻接节点的状态 3、定期地将链路状态传播给所有其他节点 特点 1、使用泛洪法向所有相邻的路由器发送信息，然后相邻路由器又向其他相邻路由器发送信息 2、发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息 3、只有当链路状态发生变化时，路由器才可以向所有路由器发送此消息 用于大型或路由信息变化聚敛的互联网环境 优点 1、每个路由节点都使用同样的原始状态数据独立地计算路径，而不依赖中间节点的计算 2、链路状态报文不加改变地传播，因此采用改算法易于查找故障 3、当一个节点从所有节点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚 4、链路状态算法比距离-向量算法有更高的规模可伸展性 层次路由 背景 1、当网络规模扩大时，路由器的路由表成比例增大 2、这不仅会消耗越来越多的路由器缓存空间，而且需要用更多CPU时间来扫面路由表，用更的带宽来交换路由信息 路由选择协议 1、内部网关协议（IGP） ​ 自治系统内容所使用的路由选择协议 ​ 1、RIP ​ 2、OSPF 2、外部网关协议（EGP） ​ 不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径 ​ BGP 特点 1、每个路由器都知道在本区域内如何把分组路由到目的地的习借，但不是知道其他区域的内部结构 2、使信息交换的种类增多，但也会使OSPF协议更加复杂 4.3 IPV4概述 1、IPV4即限制普遍使用的IP 2、IP定义数据传送的基本单元——IP分组及其确切的数据格式 3、IP包括一套规则，指明分组如何处理，错误怎样控制 4、包含非可靠的投递思想，以及与此关联的分组路由选择的思想 IPV4分组IPV4分组格式 1)版本。指IP协议的版本，目前广泛使用的版本号为4。 2）首部长度。占4位，可以表示的最大十进制数是15。以32位为单位，最大值为60B(15×4B)。最常用的首部长度是20B，此时不使用任何选项（即可选字段)。 3)总长度。占16位。指首部和数据之和的长度，单位为字节，因此数据报的最大长度为216-1 &#x3D; 65535B。以太网帧的最大传送单元(MTU)为1500B，因此当一个P数据报封装成帧时，数据报的总长度（首部加数据）一定不能超过下面的数据链路层的MTU值。 4）标识。占16位。它是一个计数器，每产生一个数据报就加1，并赋值给标识字段。但它并不是”序号”(因为P是无连接服务)。当一个数据报的长度超过网络的MTU时，必须分片，此时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。5）标志。占3位。标志字段的最低位为MF，MF&#x3D; 1表示后面还有分片，MF&#x3D;0表示最后一个分片。标志字段中间的一位是DF，只有当DF&#x3D;0时才允许分片。 5）标志。占3位。标志字段的最低位为MF，MF&#x3D; 1表示后面还有分片，MF&#x3D;0表示最后一个分片。标志字段中间的一位是DF，只有当DF&#x3D;0时才允许分片。 6)片偏移。占13位。它指出较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位。除最后一个分片外,每个分片的长度一定是8B的整数倍。 7)生存时间（TTL)。占8位。数据报在网络中可通过的路由器数的最大值，标识分组在网络中的寿命，以确保分组不会永远在网络中循环。路由器在转发分组前，先把TTL减1。若TTL被减为0，则该分组必须丢弃。 8）协议。占8位。指出此分组携带的数据使用何种协议，即分组的数据部分应上交给哪个协议进行处理，如TCP、UDP等。其中值为6表示TCP，值为17表示UDP。 9)首部校验和。占16位。首部校验和只校验分组的首部，而不校验数据部分。 10）源地址字段。占4B，标识发送方的IP地址。 11）目的地址字段。占4B，标识接收方的P地址。 IP数据报分片 1、最大传送单元（MTU）：一个链路层数据报能承载的最大数据量 2、MTU 以太网：1500B 广域网：一般不超过576B 3、分片：当数据报长度大于链路MTU时，就要对其进行分片传输 4、分片会在目的地进行组装，不会再中间路由处组装 5、标志位含义 MF:为1代表进行了分片 DF：为0时，才可以进行分片 网络层转发分组有的流程 1、提取目的主机的IP地址 2、直接交付或者根据路由表进行转发交付 3、若找不到目标路由就发送给默认路由 4、如果最够没有转发成功，就报告转发分组出错 IPV4与NATIPV4IP地址：连接到因特网上的每台主机或路由器都分配一个32比特的全球唯一标识符 特殊含义地址 1、主机号全为1表示本网络的广播地址 2、主机号全为0表示本网络本省 3、127.0.0.0保留为环路自检地址 4、32位全为1（即255.255.255.255）表示整个TCP&#x2F;IP网络的广播地址，又称受限广播地址 5、32位全为0（即0.0.0.0）表示本网络上的本主机 6、实际使用，由于路由器对广播域的隔离，255.255.255.255等效为本网络的广播的地址 网络地址NAT 概述：通过将专用网络地址转换为公用网络地址，从而对外隐藏内部管理的ip地址 优点 只需要一个全球IP地址就可以与因特网联通，由于专用网本地IP地址是可重用的，所以NAT大大节省IP地址的消耗 隐藏了内部网络结构，从而降低了内部网络收到攻击的风险 具体实现 本地地址的主机和外界通信时，NAT路由器使用NAT转换表将本地地址转换成全球地址，或将全球转换为本地地址 注意！ 1、普通路由器在转发IP数据报时，不改变其源IP地址和目的IP地址 2、NAT路由器在转发IP数据报时，一定要更换其IP地址 3、普通路由器仅工作在网络层 4、NAT路由器转发数据报时需要查看和转换传输层的端口号 子网划分与子网掩码、CIDR 子网划分 背景：两级IIP地址的缺点 1、IP地址空间的利用率有时很低 2、两级IP不够灵活 3、会使路由表变得太大而使网络性能变坏 概述：两级IP地址变成了三级IP地址 划分思路 1、子网划分纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络 2、从主机号借用若干比特作为子网号，当然主机号也就相应的减少了相应的比特 3、IP地址&#x3D;{（网络号）、（子网号）、（主机号）} 4、先找连接本单位网络上路由器，然后该路由器在收到IP数据报后，按目的网络号和子网号找到目的子网，最后把IP数据报直接交付给目的主机 注意 1、子网号全为0和全为1的不能作为主机号 2、全为0的表示本网络号，全为1为子网的广播地址 子网掩码 使用子网掩码来表达对原网络中主机号的借位 分类 1、A类：255.0.0.0 2、B类：255.255.0.0 3、C类:255.255.255.0 使用子网掩码的情况 1、一台主机在社会IP地址的同时必须设置子网掩码 2、同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码 3、路由表中必须包含有目的网络地址，子网掩码，下一跳地址 无分类域间路由选择（CIDR） 概述：无分类域间路由选择是在变长子网掩码的基础上提出的一种消除传统ABC类网络划分，并且可以在软件的支持下实现超网钩爪的一种IP地址的划分方法 特点 1、消除了传统ABC类地址及划分子网的概念，因而可以更有效地分配IPV4的地址空间 2、IP&#x3D;{&lt;网络前缀&gt;{&#x3D;html}，&lt;主机号&gt;{&#x3D;html}} 3、将网络前缀都相同的连续IP地址组成：CIDR地址块， 称为路由聚合或超网 4、网络前缀越长、其地址块越小，路由就越具体 优点 1、有利于减少路由器之间的路由选择信息的交换、提高网络性能 2、网络前缀长度具有灵活性 查找路由表使用的数据结构方差：二叉现线索树 IP地址与硬件地址 概述 1、IP地址是网络层使用的地址，它是分层次等级的 2、硬件地址是数据链路使用的地址，它是平面式的 3、在网络层及网络层之上使用IP地址，IP地址放在IP数据报的收报，而MAC地址放在MAC帧的首部 具体关系：在网络层中的路由器相互传输时使用IP地址，当当打目标网络后，使用MAC地址查找目标物理主机 路由器 拥有多个IP地址 拥有多个硬件地址 地址解析协议（ARP） 作用：实现IP地址到MAC地址的映射 ARP表：每台主机都设有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表 可能出现的情况 1、发送方是主机时，要把IP数据报发送到本网络上的另一台主机：这使用ARP找到目主机的硬件地址 2、发送是主机时，要把IP数据报发送到另一个网络的一台主机时：这是用ARP找到本网络上的一个路由器，剩下的工作用这个路由器来完成 3、发送方是路由器时，要把IP数据报转发到本网络上的一台主机：这是用ARP找到目的主机的硬件地址 动态主机配置协议（DHCP） 概述 1、常用于给主机动态地分配IP地址 2、提供了即插即用联网的机制这种机制允许一台计算机加入新的网络和获取IP地址 3、DHCP是应用层协议，他是基于UDP的 实现过程 1、DHCP客户广播”DHCO发现”消息，试图找到网络中DHCP服务器 2、DHCP服务器收到”DHCP发现”消息后，向网络中广播”DHCP提供”消息，其中包括提供DHCP客户机的IP地址和相关配置信息 3、DHCP客户机收到”DHCP提供”消息，如果接收DHCP服务器所提供的相关参数，那么通过广播”DHCP”请求信息向DHCP服务器请求提供IP地址 4、DHCP服务器广播”DHCP确认消息”，将IP地址分配给DHCP客户机 注意 1、DHCP服务器分配给DHCP的IP地址是临时的，因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址 2、DHCP的客户端和服务端需要通过广播方式来进行交互 国际控制报文协议（ICMP） 目的：为了提供IP数据报交付成功的机会，在网络层使用了网际控制报文协议（ICMP）来让主机或路由器报告差错和异常情况 种类 ICMP差错报告报文 1、重点不可达：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文 2、源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢 3、时间超过：当路由器收到生存时间（TTL）为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文 4、参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文 5、改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由器） ICMP询问报文 1、回送请求和回答报文 2、时间戳请求和回答报文 3、掩码地址请求和回答报文 4、路由器询问和通告报文 不应发送ICMP差错报告报文 1、对ICMP差错报告报文不再发送ICMP差错报告报文 2、对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文 3、对具有组播地址的数据报都不发送ICMP差错报告报文 4、对具有特殊地址（如127.0.0.0）的数据报不在发送ICMP差错报告报文 ICMP的应用 分组网间探测PING 1、测试两台主机之间的连通性 2、使用ICMP回送请求和回答报文 Traceroute 1、用来跟踪分组经过的路由 2、使用了ICMP时间超过报文 4.4 IPV6IPV6是解决IP地址耗尽的最根本的方法，缓解方法是超网聚合 NAT等IPV6的主要特点 1、更大的地址空间IPV6将地址从IPV4的32位增大到了128位 2、扩展的地址层次结构 3、灵活的首部格式 4、改进的选项 5、允许协议继续扩充 6、支持即插即用 7、支持资源的预分配 8、IPV6只有在包的源节点才能分片，是端到端的，传输路径中的路由器不能分片 9、IPV6首部长度必须是8B的整数倍，而IPV4的首部是4B的整数倍 10、增大了安全性，身份验证和保密功能是IPV6的关键特征 IPV6地址 基本类型地址 单播：传统的点对点通信 多播：多播是一点对多点的通信，分组被交付到一组计算机的每台计算机 任播：IPV6新增的一种类型，任播的目的是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机 IPV6地址缩写 多个0可以用：：表示，但在一个地址中只能出现一次 IPV4向IPV6过渡 双协议栈：双协议栈是指在一台设备上同时装有IPV4和IPV6协议栈，那么这台设备既能和IPV4通信又能和IPV6通信 隧道技术：将整个IPV6数据报封装到IPV4的数据部分，使得IPV6数据报可以在IPV4网络中的隧道中传输 4.5 路由协议自治系统AS 概述 1、单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同度量来确定分组在该AS内的路由 2、同时还使用一种AS之间的路由选择协议来确定分组在AS的路由 域内路由与域间路由 内部网关协议（IGP） 在一个自治系统内不使用的路由选择协议 目前该路由选择协议使用的最多，如RIP和OSPF 外部网关协议（EGP） 源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时需要使用一种协议将路由选择信息传递到领一个自治系统中 目前使用最多的是外部网关协议的是BGP-4 路由信息协议（RIP） 简介 内部网关协议中最先得到广泛应用的协议 是一种分布式的基于距离向量的路由选择协议，其最大优点就是简单 应用层协议，基于UDP 实现 1、路由信息在相邻路由之间交换 2、距离基本单位为”跳”，每到达一个路由器为一跳 3、最多允许15跳，超过15跳既不可达 4、每30秒广播一次RIP路由信息更新信息，建立并维护路由表 5、RIP协议中每个网络的子网掩码必须相同 特点 1、仅和相邻路由器交换信息 2、路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表 3、按固定的时间间隔交换路由信息，如每隔30秒 缺点 1、RIP限制了网络的规模，它能使用的最大距离为15 2、路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销越大 3、网络出现故障时，会出现慢收敛现象即”坏消息传的慢” 优点 实现简单、开销小、收敛过程较快 开放最短路径优先协议（OSPF) 简介：使用分布式链路状态路由算法的典型代表 实现 1、OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法 2、发送的信息是本路由器相邻的所有路由器的链路状态 3、只有当链路状态发生变化时，路由器采用洪泛法向所有路由器发送此信息并跟新过程 4、OSPF是网络层协议，用IP数据报传送 特点 1、OSPF对不同的链路可根据IP分组的不同服务类型（TOS）而设置成不同的代价 2、负载平衡：如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径 3、所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息 4、支持可变长度的子网划分和无分类编制CIDR 5、每个链路状态都带上一个32位的序号，序号越大，状态就越新 6、使用迪杰斯特拉算法 7、使用洪泛法相互交换路由信息 分组类型 1、问候分组：用来发现和维持邻站的可达性 2、数据库描述分组：向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息 3、链路状态请求分组：向对方请求发送某些链路状态项目的详细信息 4、链路状态更新分组：用洪泛发对全网更新链路状态 5、链路状态确认分组：对链路更新分组的确认 边界网关协议（BGP） 简介 1、是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议 2、边界网关协议常用于互联网的网关之间 3、BGP采用是路径向量路由选择协议 4、应用层协议，基于TCP 工作原理 1、每个自治系统的管理员要选择至少一个路由器作为该自治系统的”BGP发言人” 2、一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，先建立TCP连接 3、再利用BGP会话交换路由信息 4、所有BGP发言人都相互交换网络可达性的信息后，各BGP发言人就可找出各个到达自治系统的较好路由 特点 1、BGP交换路由信息的节点数量级是自治系统的数量级，要比这些自治系统中的网络数少很多 2、每个自治系统中BGP系统发言人的数目是很少的 3、BGP支持CIDR 4、在BGP刚运行时，BGP邻站交换整个BGP路由表，但以后只需在发生变化时更新有变化的部分 报文类型 1、打开报文：用来与相邻的另一个BGP发言人建立关系 2、更新报文：用来发送某一路由的信息，以及列出要撤销的多条路由 3、保活报文：用来确认打开报文并周期性地证实邻站关系 4、通知报文：用来发送检测到的差错 路由协议比较 4.6IP组播组播的概念 概述 组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干主机 因特网中IP组播也使用组播的概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址 组播仅应用于UDP 实现过程 1、主机使用一个称为IGMP（因特网管理协议）的协议加入组播组 2、使用该协议通知本地网络上的路由器关于要接收发送给某各组播组的分组的愿望 3、通过扩展路由器的路由选择和转发功能，可以在许多路由器互联的支持硬件组播的网络上面实现英特网组播 优点：数据只需发送一次就可以送到所有接收者，大大减轻了网络的负载和发送者的负担 注意：组播需要路由器的支持才能实现，能够运行组播协议的路由器称为组播路由器 IP组播地址IP组播使用D类地址格式 组播数据报和一般的IP数据报的区别 1、组播数据报也是”尽最大努力交付”，不提供可靠交付 2、组播地址只能用于目的地址，而不能用于源地址 3、对组播数据报不产生ICMP差错报文，因此在PING命令后面键入组播地址，将永远不会收到相应 并非所有的D类地址都可作为组播地址 分类 只在本局域网上进行组播 在因特网的范围进行组播 硬件地址的映射关系不唯一，因此收到组播数据报的主机，还要再IP层利用软件进行过滤，把不是本主机要接受的数据报丢弃 IGMP于组播路由算法 用途：利用因特网组管理协议（IGMP）要使路由器知道组播成员的信息 特点：IGMP是TCP&#x2F;IP的一部分 工作阶段 1、主机加入新的组播是，该主机向组播组的组播地址发送一个IGMP报文，声明称为该组的成员 2、本地的组播路由器收到PING报文后，将组成员关系转发给因特网的其他组播路由器 3、本地组播路由器周期性地探寻本地局域网上的主机，以便知道这些主是否仍然是组的成员 4、只要有某个组有一个主机相应，那么组播路由器就认为这个组是活跃的 5、一个组在经过几次的探寻后仍然没有一台主机相应时，则不再将该组成员关系转发给其他的在组播路由 实现因特网组播的路由算法 1、基于链路状态的路由选择 2、基于距离——向量的路由选择 3、协议无关的组播（PIM） 4.7 移动IP移动IP的概念 支持移动性的因特网体系结构与协议共称为移动IP，它是为了满足移动节点在移动中保持连接性而设计的 三种功能的实体 移动节点：具有永久IP地址的移动节点 本地代理：在一个网络环境中，一个移动节点的永久”居所”被称为归属网络，在归属网络中代表移动节点执行管理功能的实体称为归属代理（本地代理），它能根据移动用户的转交地址，采用隧道技术转交移动节点的数据包 外部代理：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理 移动IP与动态IP 动态IP：局域网中的计算机可以通过网络中的DHCP服务器动态地址获得一个IP地址 移动IP：移动节点以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变 移动IP通信过程 1、移动节点在本地网时，按传统TCP&#x2F;IP方式进行通信（在本地网中有固定的地址） 2、移动节点到一个外地网时，移动节点向本地代理注册当前的位置地址，即转交地址 3、转交地址注册后，本地地址会将截获的信息通过隧道发送给转交地址 4、到达转交地址，恢复成原来数据，发送给移动节点 5、移动节点在外网通过外网的路由器或外部代理向通信对端发送IP数据包 6、移动节点来到另一个外网时，只需向本地代理更新注册的转交地址，就可继续通信 7、移动节点回到本地网时，移动节点向本地代理注销转交地址，这时移动节点又将使用传统的TCP&#x2F;IP放进行通信 4.8网络层设备路由器的组成和功能 基本描述：路由器是一种具有多个输入&#x2F;输出端口的专用计算机 任务：连接不同的网络（连接异构网络）并完成路由转发 功能：隔离广播域 工作过程 1、源主机和目的主机在同一个网络上，那么直接交付而无须通过路由器 2、源主机和目标主机不在用一个网络上，路由器按照转发表支持的路由将数据报转发给下一个路由器，即间接交付 功能组成 路由选择部分（控制层） 核心构件：路由选择处理机 任务： ​ 1、根据选定的路由选择协议构造出路由表 ​ 2、和其他相邻的路由器交换路由信息然后更新和维护路由表 分组转发部分（数据层） 交换结构 ​ 根据转发表对分组进行处理，将从输入口进入的分组从一个合适的输出端口转发出去 ​ 交换方法 ​ 1、通过存储器进行交换 ​ 2、通过总线进行交换 ​ 3、通过互联网网络进行交换 一组输入端口：从物理层收到的比特流中提取出链路层帧，进而从帧中提取出网络层数据报 一组输出端口：将数据报变为比特流发送到物理层 注意!:如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段 功能 分组转发 1、处理通过路由器的数据流 2、转发表查询、转发及相关的队列管理和任务调度 路由计算：通过和其他路由器进行基于路由协议的交互，完成路由表的计算 路由器和网桥的区别 1、网桥与高层协议无关 2、路由器面向协议的，依据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等 支持协议：OSI、TCP&#x2F;IP、IPX 路由表与路由转发 路由表功能：实现路由选择 路由表结构 1、目的网络IP地址 2、子网掩码 3、下一跳IP地址 4、接口 转发：路由器根据转发表把收到的IP数据报从合适的端口转发出去，仅涉及一个路由器 路由选择：涉及很多路由器，路由表是许多路由器协同工作的结果 默认路由 目的：减少转发表的重复项目，使用一个默认路由代替所有具有相同的”下一跳”的项目","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"第三章:数据链路层","slug":"第三章：数据链路层","date":"2022-03-10T12:50:18.000Z","updated":"2022-05-15T10:44:00.527Z","comments":false,"path":"2022/03/10/第三章：数据链路层/","link":"","permalink":"https://wjjhui.github.io/2022/03/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"3.1 数据链路层的功能概要 数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是对加强物理层传输原始比特率的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 1、为网络层提供服务 无确认的无连接服务 特点 原机器发送数据帧时不需要先建立链路连接，目的机器收到数据帧时不需发回确认 对丢失的帧，数据链路层不负责重发而交给上层 使用范围 适用于实时通信或误码率较低的通信信道（以太网） 有确认的连接服务 特点 源机器发送数据帧时不需先建立连接，但目的机器收到数据时必须发回确认 源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性 使用范围 适用于误码率较高的通信信道（无线通信） 有确认的面向连接的服务 特点 帧传输过程分为三个过程：建立数据链路、传输帧、释放数据链路 目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一个帧 使用范围 适用于通信要求（可靠性、实时性）较高的场合 2、链路管理 概述 数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务 实现过程 首先确认对方已处于就绪状态 交换一些必要的信息以对帧序号初始化 建立连接，在传输过程中则要能维持连接，而在传输完毕后要释放连接 3、帧定界、帧同步与透明传输 概述 两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送 帧定界 讲一段数据的前后分别添加首部和尾部就构成了帧。首部和尾部有很多控制信息，起作用是确定帧的界限 帧同步 接收方能从接受到的二进制比特流中区分出帧的起始于终止 透明传输 采取有效的措施解决误认为”传输结束”而丢弃后面的数据问题 4、流量控制 概述 收发双方各自的工作速率和缓存空间的差异，出现发送方的发送能力大于接收方的接受能力的现象， 实现 通过控制发送方的发送速度，从而实现流量控制 5、差错控制 使发送方确定接受方是否正确收到由其发送的数据的方法 位错：数据中的某些位出现错误 帧错：帧的丢失、重复或失序等等 3.2 组帧功能实现 为了使接收方能正确地接受并检查所传输的帧，发送方必须依据一定的规则把网络递交的分组封装成帧 解决问题 帧定界 帧同步 透明传输 1、字符计数法 实现方法 在帧头部使用一个计数字段来表明帧内字符数 缺点 如果计数段出错，接受双方将失去同步而导致错误 2、字符填充的首位界定法 实现方法 使用一些特定的字符来定界一帧的开始与借宿 在特殊字符前面填充一个转移字符，防止转义字符被误判为帧的首尾界定符 3、零比特跳虫的首位标志法 实现方法 使用一个特定的比特模式，即01111110来标志一帧的开始和结束 在发送信息时，遇到5个连续的1就自动在后面加0 当收到信息时，遇到5个连续的1就自动在后面减0 优点 零比特填充法很容易由硬件来实现，性能优于字符填充法 4、违规编码法 使用条件 在物理层进行比特编码时，通常采用违规编码 违规编码法只适用于采用冗余编码的特殊编码环境 实现方法 正常情况下：曼彻斯特编码中比特”1”编码成”高-低”电平 违规编码：曼彻斯特编码中比特”1”编码成”高-高”电平 具体事例 局域网 IEEE802标准 目前最常的组帧方式是比特填充法和违规编码法3.3 差错控制概要 影响因素：信道固有干扰 解决方法：提高信噪比 但是外界的冲击噪声是产生差多的的重要原因 没有办法提高信号幅度来降低干扰 利用编码技术进行差错控制 自动重传请求ARQ 接收端检测出差错时，就设法通知发送端重发，知道接受到正确的码为止 前向纠错FFC 接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正 检错编码 奇偶校验码 n-1位的数据和1位校验码组成，只能校验奇数位的出错情况，但并不知道哪位错了 循环冗余码 任何一个由二进制数位串组成的代码都可以与一个只含有0或1的多项式建立–对应的关系 计算步骤 假设一个帧G(x)有m位，其对应的多项式位M（x） 加0：在帧的低段位加上M（x）-1位个的0 模2除：G（x）&#x2F;M（x）利用得到的余数位冗余码r 判断：（m+r）&#x2F;M（x）&#x3D;&#x3D;0 纠错编码 海明码 原理 在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分到几个奇偶校验组中 当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，而且能指出错位的位置 计算过程 检错d位 需要d+1位 纠错d位 需要2d+1位 设n为有效信息的位数，k为校验位的位数，则信息位n和校验位k满足 确定校验位的分步 校验位的分布位2**i-1位 校验位取值 校验位的值位对应组的所有位求异或 3.4流量控制和可靠传输机制流量控制、可靠传输与滑动窗口机制 流量控制涉及对链路上的帧的发送速率的控制，以使接受方有足够的缓冲空间来接受每个帧 停止-等待流量控制 基本原理每次只允许发送一帧，然后就陷入等待接收方确认的信息的过程中，因而传输效率低 如果接收方不反馈应答信号，那么发送方就一直等待 发送窗口&#x3D;1，接受窗口&#x3D;1 滑动窗口流量控制 基本原理 发送方都维持一组连续的允许发送的帧的序号，称为发送窗口 接受也维持一组连续的允许接受帧的序号，称为接收窗口 发送方：发送窗口的发小代表还未收到对方确认信息的情况下最多可发送多少个数据帧 接受方：接受窗口是为了控制可以接受哪些数据帧和不可以接受哪些数据帧 机制特点 只要接受窗口向前滑动时，发送窗口才有可能向前滑动 接受窗口的大小为1时，可保证帧的有序接收 数据链路层的滑动窗口协议中，窗口的大小在传输过程是固定的 可靠传输机制 通常使用确认和超时重传两种机制 基本概念 确认帧：是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接受 捎待确认：为了提高传输效率，讲确认捎带在一个回复帧中 超时重传：发送方在发送某个数据帧后就开启了一个计时器，一定时间内如果没有得到发送的数据的确认帧就重新发送改数据帧，知道发送成功位置 自动重传请求：接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法 停止-等待 后退N帧 选择性重传 停止-等待协议 从滑动窗口机制的角度看，停止-等待协议相当于发送窗口和接受窗口大小均为1的滑动窗口 在停止-等待协议中，除了数据帧丢失外，还有其他两种差错 达到目的站的帧可能已经损坏 数据帧正确而确认帧损坏 帧缓冲区 目的：为了超时重发和判定重复帧的需要 实现方法：发送段在发送完数据帧时，必须在其发送缓存中保留次数据的副本，直到收到确认帧才删除副本 后退N帧协议（GBN） 后退N帧式ARQ ​ 发送方持续发送帧，当接收方检测失序的信息帧后，要求重发最后一个正确接受的信息帧之后的所有未被确认的帧（累积确认） ​ 窗口大小 ​ n比特编码 GBN协议重点总结 ​ 累计确认 接收方只按顺序接收帧，不按序无情丢弃 ​ 确认序列号最大的、按序到达的帧 ​ 发送窗口最大为1&#x3D;&lt;w&lt;=2**n - 1&gt;{&#x3D;html} 选择性重传协议（SR） 选择重传 每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传 一旦接收方怀疑帧出错，就会发一个否定帧NAK给发送方，要求发送对NAK中指定的帧进行重传 接收端要设置具有相当容量的缓冲区来暂存那么为按序正确收到的帧 优点：提高了信道的利用率 缺点：需要开辟缓存空间来存储数据 窗口大小 n比特编码 发送窗口最好等于接收窗口 1&lt;&#x3D;W&lt;&#x3D;2**(n-1) 3.5介质访问控制概述 主要任务：为使用介质的每个节点隔离来自同一信道上其他节点所传送的信号，以协调活动节点的传输 介质访问控制MAC子层 用来决定广播信道中信道分配 常见的介质访问控制方法 信道划分介质访问控制（ 静态划分信道） 随机访问介质访问控制（动态划分信道） 轮询访问介质访问控制（动态划分信道） 信道划分介质访问控制 信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离，把时域和频域资源合理地分配给网络上的设备 多路复用技术 多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源 优点：提高了信道的利用率 信道划分介质访问控制分类 频分多路复用（FDM） 将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号 优点：充分利用传输介质的带宽，系统效率高 不足：需要在相邻信道之间加入保护频带防止子信道互相干扰 时分多路复用（TDM） 时分多路复用是将一条物理信道按时间划分成若干时间片，轮流地分配给多个信号使用 缺点：由于计算机的数据的突发性，对子信道的利用率不高 优点：统计时分多路复用（STDM,异步时分多路复用） 采用STDM帧 波分多路复用（WDM） 在一根光纤中传输多种不同波长的光信号，由于波长不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来 码分多路复用（CDM） 采用不同编码来区分各路原始信号的一种复用方式。与FDM和TDM不同，它既共享信道的频率，又共享时间 码分多址 随机访问介质访问控制 不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率 ALOHA协议 纯ALOHA协议 思想：当网络中任何一个站点需要发送数据时，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直到全部发送成功 缺陷：数据碰撞的概率较大，那么网络吞吐量很低 时隙ALOHA协议 思想：所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始时才能发送一个帧 优点 ​ 1） 避免了用户发送数据的随意性 ​ 2）减少了数据产生冲突的可能性 ​ 3）提高了信道的利用率 缺陷 每个用户都是想发就发，碰撞概率还是很大 CSMA协议 1-坚持CSMA 思想：一个节点要发送数据时，首先侦听信道 ​ 如果信道空闲，那么立即发送数据 ​ 如果信道忙，那么等待，同时继续监听直到信道空闲 ​ 如果发生冲突，那么随机等待一段时间后，再重新开始侦听信道 缺陷 ​ 传播时延对协议的性能影响较大 ​ 存在碰撞现象 非-坚持CSMA 思想：一个节点想要发送数据时，首先侦听信道 ​ 如果信道空闲，那么立即发送数据 ​ 如果信道繁忙，那么放弃侦听，等待一个随机的时间后再重复该过程 ​ 优点：降低了多个节点等待信道空闲后同时发送数据导致冲突的概率 ​ 缺陷：增加了数据在网络中的延迟时间 P-坚持CSMA 思想：一个节点想要发送，首先侦听信道 ​ 如果信道空闲，那么以p概率发送数据，以1-p的概率推到到下一个时隙 ​ 如果信道忙，就持续帧听，直到信道空闲 优点 ​ 降低了冲突概率 ​ 减少了时间延迟 CSMA&#x2F;CD协议 适用于总线型网络或半双工网络 思想：发送数据时先广播告知其他节点，让其他节点在某段时间内不要发送数据，以免出现碰撞 基本概念 ​ 载波监听多路访问&#x2F;碰撞检测协议是CSMA的改进方案 ​ 载波监听：发送前先侦听，即每个站在发送数据之前先要检测一下总线上是否有其他站点正在发送数据，若有则展示不发送数据，等待信道变为空闲时再发送 ​ 碰撞检测：就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化，以便判断自己再发送数据时其他站点是否也在发送数据 ​ 最小帧长&#x3D;总线传播时延*数据传输率*2 ​ 争用期：以太网端到端的往返时间，只要度过了争用期才能确定本次传输不会发生冲突 二进制指数退避算法解决碰撞 ​ 基本概念 ​ 定义参数K作为第几次重传 ​ min{K,10} ，在[0,2^k -1]随机取一个数为r ​ r*争用期：重传需要推迟的平均时间随重传次数的增大而增大，降低发生碰撞的概率，有利于整个系统的稳定 CSMA&#x2F;CA协议 适用于无线连接的局域网 思想：发送前侦听，边发送边侦听，一旦出现碰撞马上停止发送 采用二进制指数退避算法实现碰撞避免机制 ​ 预约信道：发送方在发送数据的通信向其他站点通知自己传输数据需要的时间长度，让其他站点在这段时间内不发送数据，避免碰撞 ​ ACK帧：所有站点在正确接收到发给自己的数据帧后，都需要发送发回一个ACK帧 ​ RTS&#x2F;CTS帧：可选的碰撞避免机制，主要用于解决无线网中的隐蔽站的问题 CSMA&#x2F;CD与CSMA&#x2F;CA区别CSMA&#x2F;CD可以检测冲突，但无法避免；CSMA&#x2F;CA发送包的同时不能检测到信道无冲突 CSMA&#x2F;CD用于总线型的以太网，CSMA&#x2F;CA用于局域网的802.1等 CSMA&#x2F;CD通过电缆中的电压变化来检测，CSMA&#x2F;CA采用能量检测，载波检测和能量载波混合检测 轮询访问介质访问控制：令牌传递协议 通过一个集中的监控站，以循环方式轮询每个节点，再决定信道的分配 令牌再固定次序中转圈，拿到令牌就可以发送数据 使用与负载很高的广播信道 3.6局域网基本概念 在一个较小的地理范围内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络 特点 1、为一个单位所拥有，且地理范围和站点数据均有限 2、 所有站点共享较高的总带宽 3、较低的时延和较低的误码率 4、各站为平等关系而非主仆关系 5、能进行广播和组播 局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，最重要的是介质访问控制方式 常见的局域网拓扑结构 1、星形结构 2、环形结构 3、总线形结构 4、星形和总线形的符合结构 传输介质 1、双绞线、铜缆、光纤 2、双绞线为主流传输介质 介质访问控制方法 1、CSMA&#x2F;CD 2、令牌总线 3、令牌环 局域网拓扑实现 1、以太网：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构 2、令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构 3、FDDI：逻辑拓扑是环形结构，物理拓扑是双环结构 逻辑链路控制子层（LLC） 向网络层提供无确认的无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型 媒体介入子层（MAC） 向上层屏蔽对物理层的访问的各种差异，提供对物理层的统一接口，主要功能包括：组帧和拆卸帧、比特传输差错检测、透明传输 以太网与IEEE802.3 采用总线形拓扑结构 简化通信 采用无连接的工作方式（尽最大努力交付） 差错的纠正由高层完成 传输介质的使用情况 网卡 局域网中连接计算机和传输介质的接口 功能 实现与局域网传输介质之间的物理连接和电信号匹配 实现帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存功能 介质访问控制地址（MAC) 网卡在出厂时都有一个唯一的代码 用于控制主机在网络上的数据通信 以太网的MAC帧 网卡从网络上每收到一个MAC帧，首先用硬件检查MAC帧中的MAC地址。如果是发往本站的帧，那么就收下，否则丢弃 高速以太网 100BASE-T以太网 在双绞线上传送100Mb&#x2F;s基带信号的星形拓扑结构以太网 使用CSMA&#x2F;CD协议（半双工） 支持全双工方式，也支持半双工方式 吉比特以太网 在1Gb&#x2F;s下用全双工和半双工两种方式工作 半双工方式使用SCMA&#x2F;CD协议 10吉比特以太网 使用光纤作为传输媒体 只工作在全双工方式，因此没有争用问题，也不使用CSMA&#x2F;CD协议 IEEE802.11IEEE802.11是无线局域网的一系列标准，包括802.11a和802.11等。它们指定了MAC层协议，运行在多个物理层标准上 由固定基础设施无线局域网 802.11标准规定无线局域网的最小构建是基本服务集（BSS) 组成：一个基本服务集包括几个基站和若干移动站 所有的站本BSS内都可以直接通信，但在与本BSS外的站通信时都要通过本BSS的基站 无固定基础设施无线局域网自组网络 由一些平等状态移动站相互通信组成的临时网络。各节点之间地位平等，中间节点都为转发节点，这些节点都具有路由器功能 移动自组织网络把移动性扩展到无线领域中的自治系统，具有自己特定的路由器选择协议 令牌环网的基本原理 令牌环网的每一站通过电缆与环接口干线耦合器（TCU)相连。TCU的主要作用是，传递所有经过的帧，为接入站发送和接收数据提供接口 控制机制 分布式控制模式的循环方法 拿到令牌就可以占有信道发送数据 物理上采用星形拓扑结构，但逻辑上采用环形拓扑结构 3.7广域网广域网的基本概念 通常是覆盖范围很广的长距离网络 广域网由节点交换机以及连接这些交换机的链路组成 节点交换机用来分组存储和转发 广域网和局域网的对比 广域网 覆盖范围：很广，通常跨区域 连接方式：点到点连接 OSI层次：物理层，数据链路层，网络层 着重点：强调资源共享 局域网 覆盖范围：较小，通常在一个区域内 连接方式：多点接入 OSI层次：物理层，数据链路层 着重点：强调数据传输 PPP协议 概要：使用串行线路通信的面向字节的协议，该协议应用在直线连接两个节点的链路上 目的：主要是用来通过拨号或专线方式建立点对点连接发送资源 PPP协议是在SLIP协议的基础上发展而来的，它既可以在异步线路上传输，又可在同步线路上使用；不仅用于Modem链路，也用于租用的路由器到路由器的线路 SLIP主要完成数据报的传送，但没有寻址、数据校验、分组类型识别和数据压缩等功能，只能传送IP分组 组成部分 链路控制协议（LCP)：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路 网络控制协议（NCP）：PPP协议允许同时采用多种网络层协议，每个不同的网络层要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接 一个将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元（MTU）限制 帧格式 注意 PPP协议提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验）。它是不可靠的传输的协议，因此也不适用序号和确认机制 它仅支持点对点的链路通信，不支持多点线路 PPP只支持全双工链路 PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信 PPP是面向字节的，当信息字段出现和标志字段一直的比特组合时 PPP用在异步线路（默认），则采用字节填充算法 PPP用在SONET&#x2F;SDH等同步线路，则协议规定采用硬件来完成比特填充 HDLC协议 概要 数据报文可透明传输，用于实现透明传输的0比特插入法易于硬件实现 全双工通信，有较高的数据链路传输效率 传输控制功能与处理功能分离，具有较大的灵活性 所有帧采用CRC检验，对信息帧进行顺序编码，可防止漏收或重发，传输可靠性高 两种配置方式 非非平衡配置的特点是由一个主站控制整个链路的工作 平衡配置的特点是链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要的来对方复合站的允许 站类型 主站：负责控制链路的操作，主站发出的命令为命令帧 从站：受控于主站，按主站发出的命令进行操作，发出的命令为响应帧 复合站：可以发出命令帧和响应帧 3.8数据链路层设备路径选择算法（源路由网桥（选择的是最佳路由）） 源站以广播方式向目的站发送一个发现帧作为探测之用，然后根据经过的节点生成最佳路径 路由选择由发送数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行接收和转发 缺陷：如果发现帧过多，会导致网络出现堵塞 局域网交换机机器工作原理 局域网交换机 又称以太网交换机，从本质上说，交换机就是一个多端口的网桥 能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽 优点 对工作站是透明的，管理开销低廉 简化了网络节点的增加，移动和网络变化的操作 方便地实现虚拟局域网（VLAN） ​ VLLAN可以隔离冲突域，而且可以隔离广播域 原理 检测以太端口来的数据帧的源和目的的MAC地址，然后与系统内部的动态查找表进行比较 若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口 特点 工作在全双工方式 碰撞地传输数据 转发表也是通过自学习算法自动地逐渐建立起来的 使用了专用的交换结构芯片，因此交换速率较高 独占传输媒体的带宽 两种交换方式 直通式交换机 只检查帧的目的地址，数据帧可以马上被传输出去 优点：速度快 缺点：缺乏智能性和安全性，也无法支持具有不用速率的端口的交换 存储转发式交换机 先将收到的帧缓存，然后检查数据是否正确 ​ 正确就发送出去 ​ 发现帧有错，那么将其丢弃 优点：可靠性高，并只能支持不同速率端口间的转换 缺点：延迟较大","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"第二章:物理层","slug":"第二章：物理层","date":"2022-03-01T12:50:18.000Z","updated":"2022-06-20T01:36:59.439Z","comments":false,"path":"2022/03/01/第二章：物理层/","link":"","permalink":"https://wjjhui.github.io/2022/03/01/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"通信基础 2.1 上基本概念 通信的目的是为了传送信息 数据 传送信息的实体 信息 数据的电气表现或者电磁表现，是数据在传输过程中的存在形式 码元 固定时长的信号波形(数字脉冲)表示以为k进制数字 代表不同离散数值的基本波形 这个时长内的信号称为k进制码元 信源 产生和发送数据的源头 信道 发送端信源发送的信息经过变换成合适的信号后在信道上传输到信宿 信道是信号的传输媒介 噪声源是信道上的噪声(对信号的干扰),及分散在通信系统其他各处的噪声的集中表示 信宿 接受数据的重点 传输方式 串行传输 将表示一个字符的8位二进制数按由低到高的顺序发送 速度慢，费用低，适合远距离 并行传输 将表示一个字符的8位二进制数同时通过8条信道发送 用于计算机内部数据传输 速度快，费用高，适合近距离 通信交互方式 单工通道 只有一个方向的通信而没有反方向的交互，仅需要一条信道 半双工通道 通信的双方可以发送或者接受信息，但任何一方不能同时发送和接受，需要两条信道 双工通道 通信的双方可以同时发送或者接受信息，需要两条信道 传输&#x2F;通信方式 同步传输 数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输 在传送数据时，需要先送出1个或者多个同步字符，在送出整批的数据 异步传输 将比特分成小组进行传送，小组可以是8位的一个字符或者更长，发送方可以在任何时刻发送这些比特组，而接收方不知道他们会在什么时候到达 传送数据时，加一个字符起始位和一个字符终值位 速率 码元传输速率(码元速率，波形速率)： 单位时间内传输的码元个数 单位 B(波特) 信息传输速率(信息速率，比特率): 单位时间内传输的二进制码元个数(比特数) 单位 bps(比特每秒) &#x3D;波特log2 码元状态数 带宽 模拟信号系统中 最高频率与最低频率的差值 单位 HZ(赫兹) 数字设备中 单位时间内网络中”最高速率” 单位 bps(比特&#x2F;秒) 奈奎斯特定理和香农定理nice定理R&#x3D;2Wlog2 V 单位 bps(比特&#x2F;秒) 理想低通(没有噪声，带宽有限)的信道中，极限码元的传输速率为2W波特 结论 1.任何信道中，码元的传输速率是有上线的 2.信道的带宽越宽，就可以用更高的速率进行码元的有限的传输 3.nice准则给出了码元传输速率的限制，没有给出信息传输速率的限制(即没有对一个码元可以对应多少个二进制位给出限制) 香浓定理R&#x3D;Wlog2(1+s&#x2F;N) 单位 bps(比特&#x2F;秒) 信噪比&#x3D;10log10 S&#x2F;N 结论 1.信道的带宽或者信道中信噪比越大 信息的极限传输速率越高 2.对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的 3.香农定理得出的是极限信息传输速率，实际信道的传输速率比他低很多 通信基础 2.1 中编码与调制 基本概念 数字数据 数字数据—-数字发送器—&gt;数字信号（编码） 数字数据—-调制器———&gt;模拟信号（调制） 模拟数据 模拟数据—PCM编码器——&gt;数字信号（编码） 模拟数据—-放大器调制器—&gt;模拟信号（调制） 数字数据编码位数字信号 数字数据编码用于基带传输中，在不改变数字信号的频率的情况下，直接传输数字信号 非归零编码 高电平代表1.低电平带代表0(或者相反) 优点：容易实现 缺点：无法使得双方同步，没有检错功能 归零编码 高电平代表1.低电平带代表0(或者相反)，每个时钟周期的中间跳变(跳变提供同步机制) 优点：提供同步机制 缺点：归零需要占用一部分带宽，所有传输速率受到一定限制 曼彻斯特编码 将一个码元分为两个相等的间隔，前高后低为1，前低后高为0(或者相反) 优点：提供同步机制 缺点：占用的频带带宽为原始基带的两倍 ，因此传输效率为50% 以太网使用的编码为曼彻斯特编码 差分曼彻斯特编码 若码元为1，前半个码元的电平与上一个码元的后半个电平相同，若码元为0则相反 优点：可以实现自同步，抗干扰性号 主要使用在局域网 4B&#x2F;5B编码 将发送的数据流每4位作为一组，然后按照4B&#x2F;5B编码规则将其转换为相应的5位码 5位码共有32中组合，但是只用其中的16种代表4位码，其他的16位作为控制码（帧的开始和借宿，线路的状态等等） 传输效率只有80% 数字数据调制为模拟信号 幅移键控（ASK） 通过改变载波信号的振幅来表示数字信号1和0，载波的频率和相位不发生变化 比较容易实现，抗干扰能力强 频移键控（FSK） 通过改变载波信号的振幅来表示数字信号1和0，载波的频率和相位不发生改变 容易实现，抗干扰能力强，应用广泛 相移键控（PSK） 通过改变载波信号的振幅来表示数字信号1和0，载波的频率和相位不发生改变 氛围绝对调相和相对调相 正交振幅调制（QAM） 频率相同的前提下，将ASK和PSK结合起来，形成叠加信号 设波特频率为B，采用m个相位，每个相位有n种振幅，传输率R&#x3D;Blog2(mn) 模拟数据编码为数字信号（PCM） 采样 对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号 采样频率&gt;&#x3D;2W W为频带带宽 量化 把采样取得的电平幅值按照一定的分级标度，转化为对应的数字值并取整数 这样就把连续的电平幅值转换为离散的数字量 采样和量化的实质就是分割和转换 编码 把量化的结果转化为与之对应的二进制编码 模拟数据调制为模拟信号 需要较高的频率 使用频分复用（FDM）技术，充分利用带宽资源 电话局和本地局交换机采用的编码方式 模式的声音数据是加载到模拟的载波信号中传输的 通信基础2.1 下电路交换 数据传输钱，先建立一条专用（双方独占）的物理通信路径 直通方式传输数据 电路交换的三个阶段 连接建立 数据传输 连接释放 优点 通信时延小：通信线路双方专用，传输时延非常小 有序传输：双方通信按发送顺序发送数据，不存在失序问题 没有冲突：不同的通信双方有着不同的信道 适用范围广：可以传输模拟信号，也可以传输数字信号 实时性强：双方的物理通路一旦建立，双方就可以随时通信 控制简单：电路交换的交换设备（交换机等）及控制均比较简单 缺点 建立连接时间长：电路交换的平均连接建立时间对计算机通信来说时间较长 线路独占：使用效率低，只能供通信双方使用 灵活性差：只要通信双方的任何一点出现故障，就必须重新建立连接 难以规格化：数据的不同类型，不同规格，不用速率的终端很难相互进行通信 无数据存储能力，难以平滑通信 报文交换 数据交换的单位是报文，报文携带有目的地址，源地址等信息 报文交换的时候使用存储转发方法 优点 无需建立连接 不需要建立专用线路，随时可以发送报文，不存在建立时延 动态分配线路 当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择一个合适的空闲线路将报文发送出去 提高线路的可靠性 如果某条线路路径发生故障，那么可重新选择另外一个路径传输数据，因此提高了传输的可靠性 提高线路的利用率 通信双方不是固定占用一条通信线路，而是在不同的时间一段一段地部分占有 这条物理通道 提供多目标服务 一个报文可以同时发送多个目的地址 缺点 数据进入交换节点后要经过存储、转发，所以存在转发时延（包括接受报文、检验正确性、排队、发送时间等） 报文交换对报文的大小没有限制，所以网络节点要有较大的缓存时间 现在已经很少使用，多使用分组交换方式代替 分组交换 采用存储转发方式，限制了数据块的大小上限 优点 无建立时延 不需要为通信双方预先建立一条专用的通信道路，不存在连接建立时延，用户可随时发送分组 线路利用率高 通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通道 简化了存储管理 因为分组的长度固定。相应的缓冲区的大小也固定，在交换节点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易 加速传输 分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间 传输一个分组所需的缓冲区比传输一一次报文所需的缓冲区小，这样因缓冲区不足而等待发送的概率及时间也会少 减少了出错概率和重发数据量 分组较短，出错概率减小，重发的数据量也减小，提高了可靠性，也减少了传输时延 缺点 存在传输时延 需要额外的信息量 每个分组都需要加上源地址，目的地址和分组编号等信息 当分组交换采用数据报服务时，会出现失序，丢失或者重复分组，到达目的地后要对分组进行排序工作 无连接的数据报服务 网络层提供无连接服务，发送方可随时发送分组 每个分组有着完整的目的地址 每个分组独立的进行路由选择和转发 不保证分组的有序到达 不保证可靠通信，可靠性由用户来保证 出故障的节点丢失分组，其他分组路径选择不发生变化可以正常传输 由用户主机进行流量控制，不保证数据报的可靠性 分组在交换节点存储转发时，需要排队等候处理，这回带来一定的时延。当通过交换节点的通信量较大或网络发送堵塞时，这种时延会大大增加，交换节点还会根据情况丢弃部分分组 网络具有冗余路径，当某一交换节点或一段链路出现故障时，可相应地更新发表，寻找另一路径转发分组，对故障的适应能力强 使用突发性通信，不适于长报文、会话式通信 面向连接的虚电路服务 必须建立连接 仅在建立连接阶段使用，每个分组使用长度较短的虚电路号 属于同一条虚电路的分组按照同一个路由出发 保证分组的有序到达 可靠性由网络保证 所有经过故障节点的虚电路都不能正常工作 可由分组交换网负责，也可以由用户主机负责 双绞线、同轴电缆、光纤于无线传输介质双绞线 简介 最常用的古老传输介质，由两根采用一定规则并排绞合的相互绝缘的铜导线组成 绞合可以减少对相邻导线的电池干扰 屏蔽双绞线（STP）：在双绞线外面加上一个由金属丝编制成的屏蔽层 非屏蔽双绞线（UTP）:无屏蔽层 优点 价格便宜 适用范围广 使用范围 局域网、传统电话网 模拟传输和数字传输 距离过大 模拟传输使用放大器放大衰减的信号 数字数传使用中继器将是失真的信号整形 同轴电缆 由内导体、绝缘层、网状编织屏蔽层和塑料外层构成 50欧姆同轴电缆 传输基带数字信号 70欧姆同轴电缆 传输宽带信号 主要用于有线电视系统 优点 良好的抗干扰性 广泛用于传输较高速率的数据 传输距离更远 缺点 相对于双绞线较贵 光纤 利用光导纤维传递光脉冲 利用光的全反射原理在光纤中不断的传输 多模光纤 从不同角度入射的多束光线在一条光纤中传输 单模光纤 光纤的直径减小到仅一个光波长度时，光纤就相一根波导那样，可使光线一直向前传播而不会产生多次反射 优点 1、传输损耗小、中继距离长、对远距离传输特别经济 2、抗雷电和电磁干扰性能好 3、无串音干扰，保密性好、也不易被窃听或截取数据 无线传输介质 无线电波 具有较强的穿透能力，可以传输很长的距离，所以被广泛应用于通信领域 使信号向所有方向传播，因此有效距离内的接受设备无需对准某个方向，就可以与无线电波进行通信连接 微波、红外线和激光 相同点 需要发送方和接收方之间存在一条视线通路，有很强的方向性，都沿直线传播，有时统称为视线介质 不同点 红外通信和激光通信要把传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在光线中传播 微波通信的频率高，频段范围宽，载波频率通常为2-40HZ，因此通信信道容量大 微波通信的信号是沿直接传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力 卫星通信 优点 卫星利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制 通信容量大、距离远、覆盖广 缺点 端到端的传播时延长，一般为250-270ms 物理层设备放大器 将模拟信号方法再转发出去 中继器 功能：将数字信号整形并放大再转发出去，消除信号的失真和衰减 原理：信号再生 优点：局域网的环境下扩大网络规模最简单、最廉价的互联设备 缺点： 不能够连接具有两个不同速率的局域网 中继器出现故障，相邻的两个网段都会产生影响 限制 5-4-3规则 5段通信介质，4个中继器，3段可以挂接计算机 集线器（HUB） 功能 实质是一个多段口的中继器，也可以对信号进行整形 收到信号后，就将信号从其他端口发出 如有多端口输入，输出时就会发生冲突，数据无效 优点 扩大网络的传输范围 缺点 不能具有定向传送能力 只能工作再半双工状态下 Hub每个端口连接的网络部分是同一个网络的不同网段 不能分割冲突域 多台主机同时交互时，会使其工作效率降低","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计网例题1","slug":"计网例题1","date":"2022-01-12T12:50:18.000Z","updated":"2022-05-07T14:57:14.398Z","comments":true,"path":"2022/01/12/计网例题1/","link":"","permalink":"https://wjjhui.github.io/2022/01/12/%E8%AE%A1%E7%BD%91%E4%BE%8B%E9%A2%981/","excerpt":"","text":"一道关于GABN和信道利用率的题的解法两台主机之间的数据链路层采用后退N帧协议（GBN）传输数据，数据传输速率为16kbps，单向传播时延为270ms，数据帧长度范围是128～512字节，接收方总是以与数据帧等长的帧进行确认。为使信道利用率达到最高，帧序号的比特数至少为（）。 信道利用率。 信道利用率是对发送方而言的，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。其中发送周期T&#x3D;发送方从发送数据到收到第一个确认帧为止的时间若在T时间内发送了L比特的数据，发送方的数据传输速率为C，则信道利用率为**(L&#x2F;C)&#x2F;T** 解：设数据帧长度为x，窗口大小为w，因为要令信道利用率最大，即为1，则信道利用率为： 所以经化简后 由此式可知，传输的数据帧越小，达到100%信道利用率所需要的窗口就越大，那么为了使发送128~512字节的数据帧时都能达到100%信道利用率，只需令窗口大小能满足128字节传输时达到100%信道利用率，该窗口大小就能满足更大数据帧。 所以此时令x&#x3D;128*8算出最大的窗口大小w&#x3D;10.4375 该情况下发送128字节的数据帧时，信道利用率为100%，而发送大于128字节的数据帧时，信道利用率大于100%，就保证了信道利用率永远最高。 又因为1&lt;&#x3D;w&lt;&#x3D;2^n-1所以n&gt;&#x3D;4即帧序号的比特数至少为4结束","categories":[],"tags":[{"name":"计网例题","slug":"计网例题","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%BD%91%E4%BE%8B%E9%A2%98/"}]},{"title":"hexo+github搭建Blog","slug":"hexo+github搭建Blog","date":"2022-01-11T12:50:18.000Z","updated":"2023-06-08T11:29:56.572Z","comments":false,"path":"2022/01/11/hexo+github搭建Blog/","link":"","permalink":"https://wjjhui.github.io/2022/01/11/hexo+github%E6%90%AD%E5%BB%BABlog/","excerpt":"","text":"一、安装环境nodejs安装 ​ 教程：https://www.cnblogs.com/liuqiyun/p/8133904.html ​ 官网：https://nodejs.org/en/download/ git安装 ​ 教程：https://www.cnblogs.com/xueweisuoyong/p/11914045.html ​ 官网：https://git-scm.com/ 安装测试：node -v ​ npm -v ​ git –version hexo 下载 ​ npm install hexo-cli -g 二、搭建仓库仓库名:账号名.github.io 勾选一下Add a README file 三、生成SSH keys​ 1）右健打开git Bash ​ 2）git Bash输入ssh-keygen -t rsa -C “邮箱地址” ​ 3）在C:\\Users\\Administrator.ssh出打开id_rsa.pub 复制密钥 ​ 4）github–setting–SSH and GPC keys–new SSH keys 粘贴密钥 ​ 5) 测试绑定 git Bash输入 ssh -T &#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#99;&#111;&#x6d; 四、本地Blog创建空文件夹Blog ​ 1）右健打开git Bash ​ 2）初始化hexo hexo init ​ 3）本地运行 hexo s 五、发布到GitHub仓库​ 1）Blog&#x2F;_config.yml ​ deploy: type: git repository: https://github.com/XXX/XXX.github.io.git​ branch: master ​ 2）打开git Bash ​ npm install --save hexo-deployer-git ​ 1）hexo g ​ 2）hexo d ​ 3）git config –global user.email “&#x35;&#x31;&#x39;&#x35;&#57;&#x33;&#48;&#51;&#43;&#88;&#88;&#88;&#64;&#x75;&#115;&#101;&#114;&#115;&#x2e;&#110;&#x6f;&#x72;&#101;&#x70;&#x6c;&#x79;&#x2e;&#103;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#109;“ ​ 4）git config –global user.name “XXX” ​ 访问https://wjj-hui.github.io/ 六、picgo加载图片​ 1）GitHub创建仓库作为图床，并设置Touken ​ 2）picgo设置 ​ ​ 3）typora设置 ​ 七、常用命令1）hexo generate 该命令执行后在hexo站点根目录下生成public文件夹 2）hexo clean 把 1）中的public文件夹删除 3）hexo server 启动服务，默认地址为http://localhost:4000/，4000端口 4）hexo deploy 部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub。 5）hexo new [layout] [title] 注意 出现此错误时，删除.deploy_git文件","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"https://wjjhui.github.io/tags/blog/"}]}],"categories":[{"name":"机器器学习","slug":"机器器学习","permalink":"https://wjjhui.github.io/categories/%E6%9C%BA%E5%99%A8%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://wjjhui.github.io/tags/DeepLearning/"},{"name":"机器学习","slug":"机器学习","permalink":"https://wjjhui.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wjjhui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wjjhui.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计网例题","slug":"计网例题","permalink":"https://wjjhui.github.io/tags/%E8%AE%A1%E7%BD%91%E4%BE%8B%E9%A2%98/"},{"name":"blog","slug":"blog","permalink":"https://wjjhui.github.io/tags/blog/"}]}